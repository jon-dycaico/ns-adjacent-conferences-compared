he
[Music]
back back
back
back back back
back back back o
w
back back o
let back
back e
back back back back
o
everyone good morning everyone uh thanks
for coming and and thanks for your
patience as well I'm Moritz and Antonio
and I are the co-founders of fluid key
um and today we'd like to talk to you
about ways to give your users better
privacy um with stealth addresses um
this is mostly coming from the work
we've done with fluid key over the past
year also implementing this for our
users um and uh we are first going to
show you a little bit of the theory
around stealth addresses and how it
works bit of an explainer and then we're
going to do a session where um self
addresses so you really understand also
at a deeper level how this works and how
you can implement this into your apps as
well so that's the plan for today um so
for the first 20 minutes I'll be talking
a little bit about stealth addresses in
general how they work why they're useful
um and then I'll hand over to Antonio
for the live coding part after that um
along the way please feel free to also
ask any questions I think it's going to
be a a longer session so it's great to
make it interactive and kind of also
make it more of a discussion and and
understand how you'd like to use steal
addresses and so on and so forth if
there's any specific questions around
this great so with that let me start by
also telling a little bit a little bit
more about wi self addresses are
actually a pretty cool way to give your
users privacy um the first part I want
to talk to you also a little bit about
how we got started um so we are pretty
heavy ethereum and evm chain users and
um maybe I can ask you also a question
first who year has more than five
different ethereum addresses that they
own accounts okay two three pretty much
everyone actually I think if uh yeah so
so we have also tens of different
accounts right and um one reason we have
so many accounts is because if you have
you know one address you tie all of your
activity with anybody can see forever
what you've done with this address um
who paid you who you paid and how much
money you have on this address and so on
and so forth and so what most users do
then is like they use their wallet and
they just create different accounts for
different use cases and so that's one
reason to have many addresses and um
that gets really difficult to manage and
is also just not ideal because in the
end you don't create a new address for
every transaction you make you just
create it once in a while right and so
you don't have much more privacy and you
have a lot of you know headaches
managing that and so that was kind of
also our starting point in in exploring
stealth addresses because with stealth
addresses you can actually get much
better privacy with a ux that's much
easier to use um than uh having you know
tons of different accounts across you
know a normal wallet
um so a few more questions to also
getting to know you a little bit better
just to show off hands um who yeah has
heard of Steal addresses
before okay so half of the room I would
say um who has used a product that uses
self addresses
before okay that's great then uh today
you will at least get to see a product
that uses telf addresses we build it
together um and then the third question
is um we is working on a product that
would benefit from better
privacy okay okay good amount of of
people in the room as well great then um
let me start by telling you a little bit
about how stealth addresses actually
work I'll start by showing you um how
this works in practice with fluid key
just to illustrate this very easily and
then I'll also talk a little bit about
the you know Tech behind the scenes um
so with with fluid key specifically the
way this works is every user has an ens
so this is my ens over year.
fk.
e um
and usually when you have an ens like
that what happens is every time someone
puts it in their wallet and resolves it
the same address gets returned right and
um in this case it's very different
because every time you know you resolve
this ens you basically get a new address
and so you see here 0x 78 B8 if I
refresh the page
sorry all right if I
refresh the page what you'll see is that
um the 0 x78 will be gone and there's a
new address here 0x7f E9 and so every
time somebody puts this U you know enss
in their wallet um or on ether scan or
anywhere a new address is generated and
that address is fully self- custodial
only I can you know spend the funds that
are received through that address and um
but this address can be generated by
Third parties and so I don't need to be
on the other side of somebody having to
send me money um to you know create that
address and time I can just have this
ens and the service with fluid key for
example and then this address is
automatically generated by fluid key
without fluid key being able to touch
your funds in any way and so that's the
the power of self addresses because
otherwise you could say I can just use
my you know metamask or any other wallet
and just generate these HD wallet
addresses where you can create more and
more addresses but yeah the cool thing
with steal addresses is anybody can
generate these addresses on your behalf
without being able to touch the funds
that go into these address addresses um
and on the other side then you know
inside of fluid key for example you see
all of your balances in one place so
here for example this is my total
balance in in in this account um but
then if I go on chain and look at for
example this one uh usdc payment what
you'll see on uh on Bas scan in this
case is that sorry I might have to zoom
in a
bit
um yes you see that this address only
holds one right and so I could have
$100,000 in this account you wouldn't
know by just sending me money into this
uh into this address and into this CNS
and so that's kind of at a very high
level how steal addresses work and and
the benefit of of using steal addresses
um any questions so far maybe already at
this kind of high level
yes
addresses uh if I want to withdraw my
phones from a set of stal or set of
addresses yeah I should uh provide and
transactions yeah so the way it works is
that these telf addresses let me um let
me switch back to that tab actually um
these telf addresses are actually um
counterfactual smart accounts so the
moment you want to withdraw money it's
actually a smart account that is a safe
smart account that is deployed at this
address and what that helps you to do is
that you can can do gas sponsorship for
example so say you receive usdc in an
address um otherwise you'd have to like
fund that address then with eth and then
you know that would dox you because
you'd have to send that E from one of
your other addresses and so on and so
forth um and with smart accounts the
other thing is that you can batch
transactions so in fluid key basically
every time you send money out um the the
way it works is that we are Computing
the generic most private see preserving
path for it right so say you received
$10 $100 and $100,000 in the past and
you want to send $90 out that would come
from the $100 address because that would
just tie one address to that outgoing
payment and so so that's one thing and
then on the other side um you can also
label addresses and then basically
decide oh I just want to you know pay
out this payment from this specific
label so you can also have full control
still over which funds you disclose to
wh whomever you're paying does that make
sense
awesome any other
questions then let me
continue um yes let me get back in
here great so basically as I mentioned
just before the the big unlock is that
you can generate self- custodial
accounts for your users um that aren't
publicly linked to your users and you
can generate as many as you want without
them needing to do anything once they're
set up so that's basically um the the
power you get from from stealth
addresses and uh how you can also
provide your users with better privacy
because then in your product one user
doesn't need to be one address but can
be you know many different addresses
basically and can um can yeah basically
in the end then have much more privacy
from
that so also just to illustrate that
again I think right now the status quo
is if you have a normal wallet pretty
much all of your transactions coming in
and out to the same address and
everybody being able to see your balance
what you're doing and so on and so forth
and now in in this new model um you have
lots of different addresses they're not
publicly linked to your ens so somebody
looking at ether scan wouldn't know that
this is an address that was generated by
your ens before um and all of these
addresses are also not tied together so
each of these addresses its own kind of
like small uh account that just holds
one asset and and isn't tied to any of
the other addresses in any way
now I want to talk also a little bit
about you know the cryptography behind
it so this is pseudomass right like not
not going into exactly how the elliptic
curve cryptography works but just
explaining at a very high level as well
what's happening so you get a better
intuition for it so um when I receive
money from you know from someone that
wants to pay me um what's happening is
that there's uh three elements here um
every user that wants to use telf
addresses needs to generate at what's
called a user meta public key that
public key can be basically um you know
put on chain anybody can know about it
if you know about that public key you
you can't know the stealth addresses
just from that so that's basically the
you know openly shared parts that that
anybody can um can have access to and
then the second part is that you
multipli this by a secret um and so this
is elliptic curve multiplications right
these are not normal multiplications and
um you know that secret is basically
what allows you to generate a steal
address and only if you know the secret
can you know the steal address and can
you know that that steal address is you
know connected to the user who has this
specific public key so so that secret is
is pretty important here because that's
what um allows you to have the Privacy
as well um and you have you can have an
infinite amount of Secrets and so you
can have an infinite amount of stealth
addresses on the other side right now
the question then becomes Okay so so now
I generated a steal address for uh for
Antonio for example and I sent him money
how does Antonio know that uh a steal
address was generated and that he
received money on that self address
right and so there there's a few
different ways to do it there's an ERC
ERC
announce these transactions on chain in
an encrypted way where only Antonio with
his viewing key is able to um decode
these transactions and see that these
funds are actually you know meant for
him um another way in which self
addresses were actually you know created
and thought of is that you can also use
a trust a third party to basically index
These funds on your behalf and so what
that means is that um you know you don't
have to you know scan the blockchain for
like hundreds of transactions to see if
any of of those is related to you but
you can have like a trusted third party
that basically does that on your behalf
and tells you hey you know year there
were funds basically um that um that
were received in one of the addresses
related to you um and then the final
part and this is also how fluid key
works is that um this secret can be can
be pseudo randomly generated and in this
case if it's pseudo randomly generated
um you can basically just replay all of
the tal addresses because you you know
how the secret is sud sudo randomly you
know generated and then you can replay
all of the tal addresses um that were
generated one by one and check if there
are funds on it so that's another you
know way to to think about it and that's
why on fluid key you know if fluid key
disappears tomorrow you can always
recover your funds because these
addresses are so sudo randomly generated
based on you know your private keys and
as long as you have access to your
private Keys you can recover all of
these addresses without any any third
party awesome then the second part is
when you want to send money out of this
telf address how do you because this is
a this is an address this is a public
key so it's just a public address you
can't really access the funds from from
this um but then then when you send the
money out um there's another set of uh
of keys here you have the user meta
private Keys which are basically the the
private Keys related to the public ke
Keys here and if you multiply those by
the same secret you basically get access
to the stealth address private keys and
so what's really important here is that
the user meta private Keys should always
stay only with the user and uh never you
know be shared with anyone because
that's what makes uh this whole system
self- custodial and and uh basically
allows the user to have full control of
of their funds uh only um and then yeah
the secret is is the same secret as this
secret so if you you multiply these two
things together you get access to the
the private key and from that you can
spend the funds uh of this uh of this
address that's at it at a very high
level any any questions around around
this all right then let me talk about
one more um one more topic which is um
the difference of privacy you get with
stealth addresses versus other systems
right so um with stealth addresses you
get something that's called
unlinkability um and what that means is
that you can generate generate addresses
that are not related to your public
address and are not related to each
other so they're not tied together on
chain in any way um but you don't B you
don't break traceability so you can
still follow the funds basically right
so um money that was sent to that to a
steal address you can still see where
that money came from initially and where
it came from and so on and so forth um
and so the advantages of Steal addresses
is that they they're really fast to
produce you can you know do that uh
elliptic curve cryptography I was
showing to you before fully off chain
takes milliseconds so you know there's
you can generate them in real time when
this ens I showed before is um you know
returning a new address that address is
generated in real time basically while
uh the ens is queried um the other thing
is that these are just normal ethereum
addresses and what that means is that
they're compatible with you know every
counterparty and every contract on
public evm chains that means you can
send me money from your metamask account
from any other account and my
counterparty doesn't need to know that
I'm using fluid key for this to work
right I can use fluid key and just
receive uh payments with better privacy
without the other person having to do
anything specific um on their end and I
think that's really important because
most other privacy systems basically
require you to have both parties in kind
of more of a shielded pool environment
where you can then trade um with each
other and here you don't need to to have
that um the downside obviously again is
that it doesn't break traceability I
would say it's um it's a downside in one
way in another way a lot of the the
users that use fluid key for example um
like this property because it's much
easier to also disclose where your funds
came from and so if you want to offer
ramp them or you know kind of disclose
what you yeah how you obtain the funds
it's pretty easy to show because you can
show that you have access to this
address and you can show where the funds
came from so there's not the risk of you
mixing funds with a third you know party
that uh did something illegal or
anything like that because all of these
addresses are fully self- custodial and
only your addresses and you're never
mixing those funds with anybody else and
so that's um I guess the the plus side
of of this property um on the other side
untraceability so meaning that you can
break um the the path your your tokens
took so say say somebody sends you usdc
and you want to you know make sure that
uh nobody can know who sent this usdc
that's what's called untraceability and
that is enabled by systems like privacy
pools like tornado cache for example as
well um and I think there the downsides
versus telf addresses is that it's much
slower right so you have to move your
funds into this Shield protocol and
it'll take um you know multiple hours
for you to basically be able to take
them out safely with uh you know privacy
because otherwise if you just you know
move them in and out at the next second
you basically don't gain anything
because you can tie those you know those
movements together so usually you have
to leave them in a system like like rail
gun as well for at least three hours and
uh and so that's like also a little bit
of a slower slower thing um the second
thing is that it's a you have a limited
set of operations you can do with within
a privacy pool right so you can maybe
send money to others but they also need
to be part of of that uh you know system
and then you can do in in systems like
rail gun for example you can do swaps
and a few other things but you can't
interact with every you know contract on
an evm chain just like um you would do
with a normal address and so that's
another um you know downside there the
plus side is that it breaks traceability
so um that's uh that's the the really
big plus side on on that side and so
what we think you know is kind of the
ultimate uh privacy stack in in the
future is that you you kind of combine
these two things together and have
something where um you have stealth
addresses where you can you know receive
payments day-to-day very easily um
without your counterparty having to do
anything on on their end um and you know
you can just interact with any contract
through that but then if you want to
break traceability on your end say you
receive a million dollars and then you
want to you know spend on the other side
smaller amounts with that you receive
your million dollars into a self address
pass it through a privacy pool on the
other side you can send that to many
different self addresses of say $10,000
each and then um you can spend from
those self addresses and just interact
on chain with those addresses as well
and so you get that um you know break in
in in tracing um but also benefit from
having addresses that are just
compatible with any contract and and
anything on chain and so so yeah that's
kind of way where we're seeing things
going but uh there's a lot of work I
think on both side both both on stealth
addresses and privacy pools still to be
done to make this super user friendly
and and so we're really um also focused
on on that um any questions on this
part then the final uh point I want to
make before I hand over to Antonio is
talking also a little bit about the ux
problems to solve still with stealth
addresses um two specifically one is key
management so um the way steal addresses
work is that you have uh they're
basically EAS right and then you can
have an EA that controls a smart account
so you have basically one out of one
safe for example with an EA that is a
stealth address um the problem with that
is that if you have thousands of
different addresses with those keys if
you want to rotate those keys for
example you'd have to do thousand
unchain transactions to rotate those
keys so that's not really practical and
you also have the issue then that um you
know if you rotate the same keys at the
same time over a thousand addresses you
can link all of those addresses together
and so on and so forth um and there we
are really excited about what's
happening with key store rollups um the
idea with key store rollups in a in a
really um quick explanation is that you
decouple the smart accounts from the
keys themselves so the keys are stored
in a key store rollup or a smart
contract basically where you have a slot
for every user so the user user a says
um you know these are my keys and then
every time you deploy a smart contract a
smart account you basically point to
that slot in the in the key store and by
doing that um you can just rotate the
keys in this one key store slot and they
automatically rotate your keys on all
smart accounts that that are pointing to
that um to do that privately obviously
you can't just point directly to that
slot obviously otherwise it would tie
everything together so you need to have
ZK proof signatures and so on and so um
you know there are like proof of
Concepts around this but this is all
still in pretty much in beta and so this
is something that um I think we'll see a
lot of uh improvements around as well in
the the coming months um the second
issue is around dap interactions so say
you have all these telf addresses in
fluid key for example and you connect to
Unis swap right and then you want to um
you know swap some of your funds how do
you do it without having to move all of
your funds to one address because when
you you connect to uniswap for example
you have to connect with one specific
address and uniswap would look on chain
the balance of this address right and so
you need to have enough balance on that
address to be able to make the swap
right now and and that's a huge you know
problem because then you have to move
funds before even making the Swap and so
on and so forth um with ERC
communicate to daps what uh properties
the the user already has so the wallet
can just say fluid key can just say in
this case for example hey um you know
this user has $100,000 we're not telling
you where these $100,000 are but they're
year they're 100,000 usdc somewhere and
just assume that that's true and then
prepare the transaction for us and then
at the moment of the signature and the
transaction being executed that's when
we then in that transaction also move
the funds to the address but the user
doesn't have to move funds before
executing any transactions or
interacting with any deps and so that's
I think also a big ux um Improvement we
need to still uh work on and and that's
being worked on um with ERC
questions before I hand over to Antonio
for the more practical
part
yes this one uh yes this one um do did I
correctly understand that this POP key
and priv priv K yeah is the same that
extended public K and extended uh
private K in bip uh
wallets yeah so so the no the key is a
bit different it dep so there's
different ways to to kind of do it and I
think Antonio will show you concretely
how it looks for example with FL fluid
key um usually with self addresses you
have a viewing key and a spending key
and so um you kind of have like two keys
actually um and the the spending key is
there to um allow the user have uh
access to the funds and then uh the
public key is there to to you know
multiply by the secret but um but yes
you're correct that in the end these are
just like ethereum public and private
keys so it's the yeah it's it's kind of
similar in the in the sense that you
know they're yeah they're the same kind
of private keys and public Keys it's
okay so the function that uh returns me
STS private key yeah is uh
multiplication uh extended private Key
by secret yeah and if I want to get uh
steals public key uh the function is the
same uh is this priv uh private key stes
private key much to stes public key yeah
yes so the private key and the public
key are connected together exactly
they're like one set of keys in a way
right it's like the same way when you
know you have your normal ethereum
account you have like a public key and
public address and then you have your
private keys that can control that yes
but in uh bip uh 32 yeah uh this
function uh functions is not the same
not uh multiplication in uh first yeah
uh not the same that multiplication in
second it's more complex yeah I think we
for sure it is more complex so again
this is like a simplification just to
explain at a very high level you know
get an intuition for it Antonio will I
think show you the code exactly how it
works um and maybe then you can uh ask
questions if it's uh yeah unclear
questions good then yeah let me hand
over to Antonio for the the second part
of this session over to
you thank you morit for the uh intro and
hi everyone I'm Antonio I work as a CTO
at flute key and uh today I want to try
to show you in practice how statuses
work to do that uh uh let me uh uh show
you the structure of this project you
get a screenshot of what it looks like
at the beginning of the slides in the
end uh will be react app a very simple
app we run on Local Host uh there will
be also a deployed version of it uh at
the end I will show you uh what this app
does the app will manage and create St
addresses locally and then through
wallet connect we will try to connect to
the safe uh app web UI and we will
deploy a safe controlled by one or you
can even play around so even more of the
St address you generated and this
basically allows you to have different
saves controlled by different addresses
so apparently they seems completely
disconnected users but under the hood
all will be controlled by the same user
and the same master key now we will get
familiar even more with the names of the
different parts that compose St taces
what this allow you to do then of course
is then through wallet connect maybe
connect this safe to any dap as Mor
mentioned before these are regular St
addresses so connect to any it up and do
literally whatever you want controlled
by your uh your stal safe so this is the
the goal of
today the couple of notes on the
implementation details and this is where
I want to like step in St addresses are
H in some parts are also Concepts and
this is what matters most for me to give
you today is that there are some parts
like the elliptic multiplication that
these are mathematical constraints so we
cannot change how those thing works
otherwise stilles won't work anymore but
to get there there are some steps that
are conventions but not like conventions
that uh you know someone imposed with an
ERC or whatever there are erc's okay but
there are you know parts that uh can be
interpreted or done based on what are
the needs of what we want to do and
these are the implementation theils for
the demo of
today first of all we use the way that
like fluid key wordss assult addresses
are Pudo randomly generated this means
that uh uh if you have the viewing
private key and then we Le more to
details you will be able to regenerate
those addresses okay it's a private key
it will stay with you but that's how you
will be able to regenerate in a way that
if a third party disappears you will be
able to regenerate those addresses
always the same
way we will use the viewing key so now
let's start getting familiar with these
names when a user want to generate set
addresses on convention it's two keys
one is called the viewing key the other
one is called the spending key together
they are the meta key so we get familiar
with
names why they are separate why there
are two we'll see it later but it brings
a lot of practical advantages when you
want to self-control funds but let
someone else generate Ste addresses on
your
behalf as I mentioned these addresses
can be easily recreated in the future uh
we don't need to to emit a nonchain
event because everything will be run
locally and this is meant for trusted
third party or personal project think
about you know you want someone to set
up with this example you want someone to
set up saves on your behalf saes that
only you can control but you don't want
to be there every time to tell them oh
this is my address this is my address
and you don't even want to send him a
list of pregenerated address that you
can control it's enough to share the
viewing key with that trusted third
party that trusted third party will
generate the saes for you and then
whenever you want you will be able to
move money out no one will be able to do
that unless
you uh
this private sorry viewing key should be
kept confidential I mean you can share
with trusted or party if you share with
anyone anyone will be able to compute
your addresses that's it their part to
simplify this um uh Workshop we have
used the stt account kit it's a SDK uh
JavaScript SDK that we coded it has been
audited back this uh June and uh we will
go also in the code of this kit but this
will allow you to create an app
generating and controlling St taluses
within really a few lines of code and
that's what we will do in this
Workshop we will have three goals for
this Workshop that are the three main
phases that also Mor show before in the
um slide where he was showing how stes
work first goal will be generate the
metaal keys of the user so the spending
and the viewing goal number one goal
number two generate one or more St
address goal number three will be
generate the private key to control
those St addresses I on purpose to
separate phase two and three to show you
that it's possible to generate a address
without knowing its private key then
generate the private key to control the
address knowing the spending private
key I know it's quite a lot of uh of
things so we will tackle one by one and
we will go into that so now let's go to
code and uh I will leave this for you so
the way it works I have created this uh
GitHub repository it's under fluid
/ dc7 St
address uh I will leave you time if if
you want to uh to clone it this
repository has uh uh a main branch and
three branches called stage one stage
two and stage
three I I've done Ive set up it in this
way because we will start coding from
stage one so if you want to code along
with me just clone stage one but if for
any reason you you messed up you you you
lost a piece you have an error or
whatever once they move to stage two
that's when we will create the the
address it's enough for you to pull the
stage to branch and you will be up to
that point and in the end at the end of
the session we will be at the main one
so the main one is the final version
we're going to code to that today you
don't need to understand how react works
you just need uh and there are
instructions on this uh R so let me go
here this is the repository you will
just need to
clone and uh run yarn install and then
yarn start to have the app going and we
will add code just in one
file so just let make me sure that I am
on stage one perfect so I'm stage one
and this
is okay now we need to zoom in and how
was that that works like this no I even
zoom out okay much better I would
say can you read it or you want
bigger okay if you if you don't see
something just raise your hands and you
want bigger
sure okay I think that could be better
um in general if you need to ask
questions or or if you miss no a part
just stop me and I I I don't want to
lose anyone uh on the path towards the
the goal of this
session as I was saying a second ago I
will uh I have already run yarn install
or npm install whatever it's the best
for your laptop and now now I will uh
launch the application with a with a
start command
sure don't worry so the repository is
gab.com
SL uh no sorry that's the wrong one
gab.com fluid key slash dc7 St address
let me go back to the slide so you can
see
bigger don't worry
perfect let me meanwhile go back here so
I have uh uh just hit start let me also
open the console that just will help us
going through what we are what we are
doing so again I just clone uh the
repository yarn install yarn start and
you will have a fully functional react
application that technically if you get
there in a website you will say oh okay
just generate a master key if you click
that it says oh generate metast stel
keys not implemented yet and that's the
first task we need to go
through now this is a demo application
okay so I have a remove some parts that
in a regular application you will have
there the most practi IAL and hopeful
one will be to have a connect wallet
button like if you want to connect your
metam mask in into this to simplify that
part and now avoid a lot of problems so
my metamask doesn't connect and so on we
will generate a private key right here
and from that private key that's like if
it's your wallet private key we will
generate The Meta keys and I show you
how to do that again this is a
application if you want after the
session to propose a PR and have a
proper connect button feel free to do
the code is open source and you can do
whatever you want okay so let's start
coding this first part and let's go
into our project and the project there
is a uh I'm sorry this part I can zoom
but there's a source folder SRC folder
inside there is an helper folder that
has a file that's called St address.
TS
again I don't know why it's losing the
zoom perfect this is the only file we
will we are going to uh edit and this
file has three function one for each
step the first function is called
generate metast
keys and at the moment you see there's
an alert that's the alert we just saw in
the code okay if if you scroll down
there is a second function that
generates salt address that's the second
function second stage of the uh workshop
and then the third one that's the eval
St address private key and that's a
third third stage once we get down to
this point we will be able to have a to
deploy a safe and control the safe with
the address we are
generating I have set a lot of todos
that will guide us through what we have
to do and if you don't mind I would like
to start with the first step so let's
see how to generate The Meta stall
Keys as I mentioned uh for this demo I
have uh you know simulate that I don't
want to connect an external wallet just
to simplify but on average what you will
uh mostly commonly do to generate the St
addresses is ask the user to connect a
wallet
and generate a s uh and sign a message
the signature is a deterministic
signature this way is a nice way to ask
a user a unique string the signature
that only his private key can
generate and uh you know that it's tied
to the user Master private key without
asking the private key to the user the
wallet private key okay because if you
go on a website and the first thing you
ask a user is can you please pass here
your private key of your wallet that's
like will be targeted as a scam website
your application so you cannot do
that here what we have done to simplify
we just uh generate the private key here
you will see that key appearing here and
uh uh we will
uh think about a message in this case I
put hello defon 7 this is the message
that must be always is the same to
always obtain the same signature from
the user if we change this message the
signature changing and those the metast
keys under the hood will change so let's
keep it
static we will then input to this
function a private key a wallet private
key and we will return the spending and
the viewing private
key the first part out of these three
internal steps two of three will be very
simple VM function so let me go to the
first one I will just create an account
by calling the function private key to
account and passing the master private
key receive as input of this
function let me go a little bit okay so
the this function is a master private
key and this generate an account this is
exactly as having a metamask account
connected okay so nothing more than that
into that this is again a VM function
and the second one I want to obtain a
signature and I have to use the await uh
it's an await yes account
dot okay sign mess but this is
wrong and we have to pass the message to
authenticate and that's s like
this and again if this account represent
metamask wallet connected through wagm
for example this is exactly how you have
to do just require message and there is
not wait because the user will have to
click and approve the signature and now
we have obtained a
signature that's everything that's the
last part not related to St addresses
from now on will be only St address
related
functions and uh we will use the first
function from the St account kit so we
need to let's read the comment use St
account kit to derive meta St keys from
the
signature think it's time to go back
into our St account
kit Let Me Maybe still Zoom a little bit
more that's it I don't know how to close
this honestly let me see if I can no
more than but it's fine if you go into
our St account keit or you clone it in
the source folder there there will be a
series on function to simplify we put
one function per file that's easier also
to
read each one will be used at a certain
stage of our of our
Workshop what we will need
now is generate keys from
signature just quickly show you what it
does basically this function takes a
signature and Returns the spending and
key how does it how it does very simple
take the signature split by two each
part of the signature is used as a
initiator to generate a key and then
Returns the two keys you don't have to
write all this
code you just need to go here and says
uh
generate uh keys from signature and you
pass the signature and then of course we
need to store that an function and then
we need to return keys.
spending private
key and keys.
viewing private
key okay this we you start seeing the
utility of the Steal account kit you
don't have to know all that
part this specifically part is a
convention it's not a a must to do for
St addresses
in your H you want to generate the
viewing and spanning proper key
independently with your algor algorithm
that's fine okay it's not something that
you have to do this is a the easiest way
so that a user can connect this wallet
generate a signature and make sure that
even if your front end disappear is
always able to generate a signature and
then following a simple program being
able to uh generate the
keys let me also put here a
console.log of key of keys and let's see
if it
works now let me um just clear
cache go back to console clear it
refresh the page so before we were here
and when we were clicking the button we
were getting an error now let's click
the same button
and we got keys
okay and as you can see this is a if you
go in the react code it will generate a
random private key of course if I copy
it I clear the cache and I pass this key
inside here again the metaal keys
generated that we can see here will
always be the same so this 0x d8 BC as a
spending and 0x 8944 ab as a view in
private key that will always be the same
if this changes all the c t are going to
change okay so that's the first part
stage one completed if you didn't follow
along you can uh pull stage two of the
gab rle and you will be exactly at this
point like I am
now we are read to go into the most
interesting I would say part of the uh
of the process that's generating this St
address that's also the one that
requires a little bit more of steps and
in our react application would be just
okay generate your first
account if I click uh this application
allows me know to add also a nickname
whatever I want and if I had now I got a
message generating St addresses not
implemented yet and this is what we will
do in the stage two of this uh Workshop
console and go
here so let's start by removing this
alert and as you can see this generate
St address has two input parameters that
are set by the react application and
needs to return two things so sorry
three input parameters the first one is
the viewing private key the second one
is the spending public key and the third
one
is a numeric
nuns first thing you notice there is
only the spending public key because
it's a public key I can share with
anyone and this is what guarantees me
that my funds are self- custodial to
generate a St address you just need the
spending public key not the spending
private key and this is the the first
important part the second part is the
nons the nons is a number can be any
number up to 2 power 256
okay so like large amount of number for
Simplicity in this demo application we
will rotate from zero on so we'll pass
the nons zero one two the changes of
these nons will change the the generated
St address so once we have stat like
once you have the meta Keys then it's
just enough to increase the nons and
every time I will generate a St address
that's completely uncorrelated to each
other and even if you know that two
address are controlled by the same
private key let's say I generate three
address of you out of these three or any
address I am not able to recreate the
controlling public or private
key what this function returns this
function Returns the St address and the
Emeral private key and now we asking
what's an eal private key
in the high level slide uh we had before
in a mod
session at a certain point there was the
know the public or private key
multiplied by a
secret that
secret is obtained from a mathematical
operation we will see from a ephemeral
private key this private key can be
generated by who generates a the
address generate the address to that and
then can can throw away the private key
and just keep the public key this I
don't go into too much details at the
moment just consider that you need also
this private key but it's a randomly
generated private key at the moment or P
randl generated if you want to recreate
them consistently and this is what we
will see
now also here three steps all three
related to St addresses and uh this we
go back into what I I consider
convention not a mandatory mathematical
operation you have to do for St
addresses when we uh decided to know how
to set up fluid key we thought that
sharing a viewing key even if it's a
private one let's say in another way
sharing a private key whatever it is
it's always a bad
attitude you don't you never have to
share private key but as as a a trusted
third party I need a viewing private key
to generate Sal addresses on your behalf
so how how do you do how did we end up
solving this uh
problem we ask user to share with us a
bip32 node of the viewing private key
see uh in a simple way you have a
viewing private key the one I we
console.log in the browser
before and from that viewing private key
you are generating a sub private key
that you share with us following a a
standard that's the
bip32 why you say why that why this
extra complication because the day you
don't trust me anymore if you have
shared with me your
viewing uh key there are from the master
key you have to sh you have to change
the master key and those changing go the
spending key and all the address you
have you need to go through each of
those and change a controlling key if
you have shared with me a
sub a private key der for your viewing
private key the day you don't trust me
anymore you just need to start
generating still Tes with another sub
viewing private key and the spending key
stays the same so I as a trusted third
party know all your addresses up to that
moment but I don't know anymore your
addresses from that moment on while you
keep controlling also the next addresses
with the same spending
key this just to say that in a couple of
lines of code we will generate this sub
uh viewing private key we will call a
viewing private key
node and uh we will use the node number
zero of course we are just generating
now we use number zero the day you don't
trust a thrusted to part anymore it's
enough to put this as one and you will
start generating other St addresses
control all by the same private key but
the other party won't be able to know
that are your addresses
those first step is use St account kit
to extract the specific node from the
viewing private key required for
generating the FML key so what I just
said we are going to do with a with a
one simple function that we take from
the steal account kit and uh if you look
at the list of
function uh it's called extract viewing
private key node and as you can
say we are just using this is I don't I
don't I'm not going to details but it's
a standard
bip32 the purpose is
reflects the ERC around St addresses
nothing special around that and the not
is the number we just said 0 1 2 every
time you change the node the derived
viewing private key completely
changes so this function accept two
parameters the private viewing key and
the node and returns a a a a node the
htq is a
node so if we go here
and just say con viewing private keyn
Noe as you can see it already knows what
I what I need to do and
uh yep and this is the uh the
implementation so basically I am
extracting view imp key node passing the
viewing private key that's an
input on the function and the
current uh node number the number
zero we can pass this new num as a
parameter of this function yes of course
but it's usually it's something that you
change really once in a while so for the
demo is fine to have in the
code finally we have the viewing priv
key we will use to generate all the St
addresses
from we can go to this next step and
here we have to use St account kit to
generate an ephemerial private key using
the extracted viewing key node and the
provided
nons so we will use this just generated
key to
generate this fmr private key that's
basically what forms the secret that you
just show before okay we need this one
to generate the secret
when in the slide before we were putting
secret we were hiding this intermediate
passage that's needed at code
level to do that let's go back in our uh
Sal account kit and the function that
we'll need to use it's the longest one
actually but
um generate eeral private key that's
it this function accept
four parameters actually two are mutual
optional the first one is the viewing
private key node that's the one we just
generated okay see it as a view private
key but in a way that if I want to
rotate it I don't have to change my
master
key the N is the one that we passed know
the 0o 1 2 3 4 that every time we change
change the still tles generated so this
change quite often this is why we put as
an input of the function and then the
chain ID that's why you can generate
still is specific for a specific chain
here we will pass chain ID zero that
what does it mean it's an address that
you in your mind can use on any chain
not on just specific chain okay why this
is done because sometimes you want to
know Force some
addresses from a logical point of view
it's not like from a practical or
mathematical point of view to work only
on a specific chain because you will
deploy a smart contract controlled by
that Ste account that's available only
on one chain okay and that's an easier
way for you to generate St addresses
that are for you connected to a specific
chain again this is a concept not a
mandatory uh mathematical
constraint
uh the the non should be to get
different St addresses is so the
question is like I have a nouns can just
change that for different chains if you
think you want one address for one chain
works the moment that you might have two
addresses for the same chain um you
might start you might not not
remembering that the approach we do for
example at fluid key we have always
chain zero and we deploy saves because
we have saves through the canonical
Factory that that generate the same
address the same smart account address
across all the chains so we don't have
this problem and also it's an advantage
because if by mistake I send money to
the wrong chain I know how to recover
that that that amount of money
okay the chin is never
uh I will see um reviewing with the
current CH you can choose anyone that's
you like AB absolutely absolutely
instead of you can choose two power 25
again this is a concept not a
mathematical constrain so whatever you
want so uh let me go here I put this and
then let me don't ah my
bad and okay these are type parameters
so uh the viewing private key node is
the one we have above the non is the one
passed to the function and the
um chain ID we said we're going to put
zero and this
returns
a Emeral private
key uh feel free to go through the code
the idea is that uh we also do here Bap
standard uh we I added a lot of
explanation around what it does I don't
want to Deep dive as I think will remove
the focus from what we are doing
now and finally so that I can finally
see the steal address being
generated we will use the stealth
account kit to generate steal addresses
using the spending public key and the
generated emal private key if we go to
this St account
kit you can there's a function generate
St
addresses that
accept uh an array of spending public
Keys we set up an array because you can
generate multiple uh addresses in one
shot and the uh emal private
key
so this this is the function uh
technically might have picked this up
the problem is
that this needs to be an
array and probably uh me misses an S
here
perfect and now we can return the Ste
address generated and the okay
uh like this because return to type one
and then the private
key I could have also technically
returned the F public key now that's
just more to keep those connected to
each other as I've generated those
Tes now with the set of okay I have the
viewing private key I extract the node I
generate the FML private key so
basically I generate the secret let's
see this way and from the
secret I gener the Ste address if we
want to go into how this function work
this is what probably you were
mentioning before you will see that to
obtain the Ste address in the function I
do analytic C multiplication between the
spending public key point and the hash
of the share secret the share secret is
an hash uh the hash of the share
secret comes for the share secret and
the share secret comes from the F
private key and the spending public key
okay again uh these are the advantages
of using the Ste account keit you don't
have to remember all the steps in memory
just use a function but that just to
prove you that there's a elliptic
cryptography under under the
hood now I'm confident that if we go
here and we click generate your first
account and we add the account appears
now if you add another
account another one appears and if you
add a third one a third one appears all
are different this has nons zero nons
one nons two if we look on them on chain
uh we will use base uh chain just for
Simplicity it's an empty address there's
nothing on it it has no connection to
each
other it's also empty because we have
just generated them no but uh that's to
prove you the power of this
tool now we can uh go to the start doing
the fun part and uh try to deploy a save
control by one of this to do this we
will need
to uh
wallet connect to
the safe
UI and we using wallet connect so please
fing across that it
works I have set up this here let
amazing now what else you want strange
because I pretty sure I added this uh AP
maybe my bad uh didn't update the the
code one oh strange it's here why does
complain Mor is an
idea
pop pretty
strange but
uh let me see seems to go now I don't
know why uh but it's done it's 95 for
because yesterday we had this same issue
but 954 F it's it's right here
so if I continue with that let me deploy
this on base of course as you can see I
have connected a specific St address 954
F that's the first one in the
list I want it to be deployed on safe
one out of one it's
fine and uh just pay now luckily safe
allows to sponsor the deployment so
that's it I don't have to approve any
transaction and in a few second the safe
will be the deployed on chain and we
will have address connected to
that let's give a second that it deploys
and then we will move actual money on it
we'll move a few scents of it and then
the last part will be try to move them
out and we will need to create the
private key for
that this is the safe generated it has
an address F7 A1 blah blah BL
blah uh let me uh switch to basos wallet
connect so that's all year all done
perfect now I have the address and I
will send money to this uh to this
address to do that I will use uh my food
key account just because it is
uh it is
faster let me S like
uh worth of it and uh
this is the f71 double check f71 perfect
send
pin as you as you were mentioned before
uh fluid key no relays the transaction
for you under the hood this money is
coming from a St address a St safe okay
that's a I'm just using that to simplify
the process okay so money is being sent
yeah so the the safe I deployed here I
basically told the safe UI this is the
signer and it was one of the Steal
addresses I generated trust me I have
the private key CU I connected through
wallet connect then safe deploy the safe
because we are on Bas the sponsor the
transaction it's is gasless they pay the
gas for for us coinbase is sponsoring
the gas and uh that's it we have a safe
control with a one out of one signature
from this St address what we will have
to do is generate the private key to
move this money
out if we go to the assets we have just
received three cents worth of
e now and this
safe now if I want to move money back
let's send this money back to my account
but you know we have still addresses so
back to another address of myself and
say okay I want to empty it send it all
out if I go next it works I mean it's
safe it's the saf
UI H it's just simulating and say okay
wonderful execute it now when execute if
I go back
here it throws me an error it says
evaluating Sal outs private key not in
implemented I cannot you know do the
transaction for you and uh uh if I go
back you know there is a user rejected
signature there's an error so we have to
fix this error and we should be able to
move money out and uh complete the
workshop this is the easy part of that
because we re the hard part we've
already done the easy part is just one
function and you can pull stage three if
you want or that's the last part we have
and we have to go to the evaluate St
address private key so let me remove the
alert and then need to use the St
account kit to generate the St private
sending key using the provided spending
private key and the fal public
key so out here is where I need the
spending private key and that's the only
time you have seen me using that and the
Emeral public key
spend one minute explaining why I need
the public here but it's also a logical
way of doing that you never have to
share a private key so if I'm in a
scenario where I want to generate the St
address for you for
example I don't share the secret because
if I just share the secret everyone will
be able to see a secret and everyone
will be able to to to the computation
understand who is owning that
address I share I generate an eeral
private key that allows me to generate
the secret then I share with you the
public Epal public key that you can use
to generate the same secret too it's a a
lot of elliptical multiplication but
that this allows a uh a trustless
environment where there's no risk of
encrypting stuff on chain because if you
encrypt something on chain today is
encrypted who knows in 10 years if that
same stuff is still encrypted someone
can broke that encryption on on
chain so this is literally one line of
code uh with one function let me go here
for the last time in the Ste account kit
and get a function that's called
generate St private
key and if you enter and you see how it
is it's very short you input the
spending private key and feral public
key the same input we had in our uh
function we recompute the share sequence
of course the output of this computation
is the same of the one we do when we
generate the address but this time we
multiply the spending private key with
the ephemeral public key if you remember
before to generate this secret we
multiplied the spending public key with
ephemeral private key right so all the
piece are coming
together and I am able to regenerate the
secret hash it exactly like we were
doing before
and doing a slightly different tic
multiplication that's not like proper
multiplication because we have like then
to limit for the end of the curve and
get the private
key from here we have the private key
and if we input to to see if that
works so see we get here uh maybe got it
yep
perfect and that's it but we'll leave it
code for
here uh for sure it's not like this it's
like this because it returns a type
parameter so I have just called the
generate St priv key the function I just
show you runs under the hood and returns
me the private key that I return to
control the transaction and for example
how this code works the private key is
generated only at the time of the
transaction I don't keep store private
key that I I don't want to store and
after is thrown
away now if we go back to our safe
wallet and I ask again to execute the
transaction and I go back here
technically finger crossed like before
yes it works forget about the error the
error just react we have received a
signature request from metamask see
metamask good night from uh
safe this is the uh body of the
transaction if if I approve I'm using
the St address private key just
generated to confirm a
transaction and if we go back
here H try again maybe was timeout
something like
that let's see okay
T okay
of course it's the beauty of
the okay
somehow the connection with wet
connector broke I have no idea
why so that's why it wasn't working
because wet connect was no more
connected now it says it connected let's
try last
time so this is where I want to send the
money I want to send at all next PR
transaction otherwise I will reset the
connection with wet
connect let's see if it
works okay let's
approve no there is something it doesn't
like so I know what to
do
disconnect
refresh request to connect again with
connect regenerate the
connection amazing it's connected
perfect try to execute again one last
time let's
approve perfect and now it worked
this is why I was asking you to keep
finger crossed with wet
connect so uh if you notice we are
sending money back to the account that
sent me actually we are sending money
back to another address that send money
but controlled by the same owner and
this is the power of St addresses if you
look on chain you will see money coming
from A to B and B to C and you have no
idea if a and b are the same owner and C
A different one or like in our case A
and C are the same owner and B was just
the Middle where we went send money
through
as you can see we just receive 0.001 e
that like 3 cents and if I look at that
on base can I will be able to see that
you know it was sent to this address
that has just uh three cents of worth of
e while in my wallet I have
$5 you can do a lot more I'm not doing
that now I want to like leave some space
for the questions you can for example
wallet connect safe UI to Unis Swap and
control it add another signer generate a
two out of two signer by for example
here in the settings add another signer
and this signer you know can
be another St address of the one you
generated and you say why doing that I
have no idea but maybe you want you know
to to show you have one out of two or
for some reason and I'm adding a second
signer uh to that and so on
I'll go back to the slide but there's
time for questions and that was my main
concern is leaving like a 15 minutes to
discuss on go
on
um you can find the final version of
this demo app on dc7 fluid key.com just
in case you want to play a little bit
around and uh make sure also to check
the repository uh I will also add the
link to repository on this page now it's
currently missing
and uh one last slide if you want to
learn more around the St address or you
want to start building please uh scan
this QR code we have put together a
series of uh links and useful links
to um learn more about that and there's
also a link to our Ste account kit the
SDK we just used there's also a telegram
group specific for St addresses there
are like nice discussion going on if you
want to be added just uh send a mess
message on telegram to moris fluid key
and we will be super happy to add you to
that uh telegram account
group with this there open to questions
but thank you so much for your attention
on behalf of moris and myself thank
[Applause]
you there's a question there behind you
y
uh for me it's still not clear how the
each key relates to each other like can
we somehow explain it maybe with math or
with simple slide if you have uh I
understand that you need to arrive to
the stealth private key and public key
and the path to go there should be like
through different Keys could you please
explain math behind it like um the
beginning just to just to understand
because we showed one slide with the
receive and send did you see that just I
watched it on why YouTube so maybe so
that wasn't what wasn't clear from that
slide maybe or like let me go yes better
with the mic
exactly
perfect H okay yeah here we
go so yeah basically the the whole point
of stealth addresses right like again
otherwise you could also if if you want
to generate new address for yourself you
don't need to S addresses because you
can just use like um an HD you know path
to like create a new address every time
right and and that's controlled by the
same private key the whole power of self
addresses is that you can share a public
key with um you know anyone you want and
then they can share um a an address they
can create an address on your behalf
that they know only you can basically
control right so in the case of what we
built just now one one examp example is
for example say you're getting added to
lots of different multi sigs right and
you don't want your main address to be
added to on your metamask you just want
to share you know basically your your
your meta public key and anybody adding
you to a save can basically just
generate a new address on your behalf
add you to that multisig and you'll have
full control and basically access to to
to also control that that's again at a
maybe high level so is there like what
do you like yeah maybe you can explain
better what you're not yeah like you
shared with them uh public Emeral key
and how they can generate additional
address for you is it or do what do you
should I think yeah it would be better
if you explain the specific math of
multiplication of elliptic curve
equations if you have because it will be
more clear sure so I think we can go to
our repo maybe and uh show you that the
public one uh start from generates the
address this
one a little bit
more awesome do you want to do you want
to run through it actually y
so uh this uh why I I don't I would just
point with this so um this line here
still public key is spending public key
multiply by the Shar secret okay this
line here is on the slide this line here
okay to get to this one we need to
generate this uh
secret the secret here um forgetting
about like generating a random one like
how we implemented
here uh we generate a a point to do
Elric mulation you need to generate a
point that why doesn't work from a um
sorry here we generate the hash okay
from the secret so that we have a fixed
length over that okay and then uh the
multiplication happens from the point on
the curve of the spending public
key with the ash of the share secret now
there's this share secret still like up
in the air
the share secret ear comes from the
ephemeral private Key multipli by the
spending public key you might say hey
but where is the viewing key and all
this steps the viewing key is used to
generate the feral private key in our
case so the eeral private key is somehow
derived from the viewing
key recompute the same sequence only if
in this case only if you have the
viewing private key and so if I want you
to compute the address for me I share
with you my viewing private key a node
of it okay you then generate the F
private
key and then the spending public key is
public so I can even publish on chain
it's not a problem and then from here
you arrive to generate the thir address
again there are even other methods to do
that but the idea is that uh only the
spending public Keys is here and this s
secret needs to be generated in a way
that depends on the use case in our use
case for example it want a way that is p
random generated for the use case and
this is why you use the viewing private
key to generate this FM private
key and uh do you remember that we used
the nons 0 1 2 3 4 for the different
addresses a different nons will generate
a different FM private key and this is
why the secret changes and this is why
the final address
changes it's like a butterfly effect uh
from uh from the
nons when it comes instead to the to the
other way around it's quite easier
because we have already the fal uh key
generated okay so like you generate a
private key you also have a public key
of this FAL and then when we go
to generate still private key that's the
function you already have the feral
public key you have the spending private
key and that's uh you you compute the
same if you if you take this share
secret and the other one done the other
way they're exactly the same and this is
something that you cannot change this is
a mathematical constraint this is how
electric multiplication like basically
uh works with a share
secret then you hash it and then the
operation is slightly different because
we are working with private Keys here
not public keys but under you can think
is the same is Li multiplication with a
module that limits its size uh on on on
the Cur otherwise you can have values
that goes out of the max available for a
key okay but you need to store somewhere
if meral public right in
storage so in our case since it's um
pelo random generated we can always
recreate and this is also why we were
returning from the St uh generate St
address this is why here we were
returning ah sorry my
bad uh I got it so you this FAL public
key array you generate using HD f for
the pretty exactly but then but then
with ERC 5564 for example the public key
you could you could put that on chain
and then only if you have the private uh
spending key you can then also like
regenerate as address and and see that
it's your address basically so yeah
there's there's definitely different
ways to go about that that part as well
yeah and this is the part I was speaking
before about based on your use case you
can adapt one or choose another or you
even find a third path that we haven't
explored yet uh and do that okay okay
thank you got it you're
welcome awesome yes thank you everyone
if you need more questions we are here
thank you
e
back o
good
back oh
it's
o back back
oh
back back back back back
good back back back
all right thanks everyone for coming uh
we have a session today on uh building
ecosystem Health metrics with open data
sources um should be accessible for you
know anyone whether you're super super
deep in the data uh kind of more of a
data fan or just getting started and
like pretty pictures of charts on
screens um this is all kind of based on
our work building within the optimism
super chain ecosystem but should be
applicable for any L2 any wide ecosystem
maybe even like any business so uh yeah
so with that we will jump in uh so I'm
Michael uh data analyst at op Labs been
there for about about 3 years uh seeing
the wide range of things from one chain
apps you can count on your hands to uh
now where we're at with many chains and
trying to keep track of
everything um and uh I'm Trin I've been
working at op labs for two years and has
always been navigating onchain
data oh so um for today's today's agenda
I'm going to talk about um what is
ecosystem Health what are we going we're
going to talk about the collective data
vision and we'll have some C any time
for everyone as
well oh so before we start I would like
to start with a multichain universe
little trivia time so um going to get
some hands um how many chains are there
anyone has any guess just feel free to
raise your hand shout anything how many
chains 200 200 it's close there's more
um any other
answers it's more than 200 give me a
wild number
say 500 500 oh it's lower but
okay we're still uh so okay so this data
is as of like end of last month which is
October um there's already 322 chains um
according to Def Lama so guess how many
rollups are
there given number there's already a
reference number
now anyone shout 200 200 m H
interesting um actually is much slower
so according to defal Lama is about 38
and also l2b is about 48 so different
providers last question just guessing
how many chains are part of the super
chain ecosystem so it's another subset
but give it a number again please
anyone 30 30 is what you're saying
Lizzy okay so it's actually 21 we and we
have this data avail able in a Google
sheet with all the super chain ecosystem
members so now we're going to talk about
what is ecosystem health and I'll hand
it to
Michael yeah so how we think about uh
measuring the health of art ecosystem uh
the whole you know super chain L2 space
uh kind of a very very simple question
to kind of try to answer is are we doing
well um this being about chains seems
like a very very easy question to answer
um but it actually becomes super super
difficult and it'll go into a little bit
why
one we just went through how many chains
there are super hard to keep up you know
who can name 300 chains you can barely
name 20 chains um a lot of things going
on even mentioned youed to able to count
chains and apps on your hand now
absolutely no way to um so a lot of
information to try to keep up with uh
second there's often a gap between what
you think you're measuring what you're
actually measuring I think one tangible
example I can give when I first started
at optimism um trying to find what
things us users might be interested in
uh decided to take all the users on L2
take those addresses look what they did
on L1 try to get some understanding of
what they were using uh at the time we
saw some real world asset apps we saw
some like fixed straight lending things
and I made this assumption like oh it's
all these fancy defi things that's what
these users want that's we should kind
of go after and build uh turned out
those were all just apps that hadn't
launched a token yet so I thought I was
looking at what users wanted to do it
was actually looking at people you know
doing their farming activities uh and
this is actually kind of a you know
dangerous assumption to make especially
for making decision
or figuring out where to invest
engineering resources product resources
if it's based on thinking you know
something that is actually not what you
think it is uh yeah put you down a bad
path so ideally we kind of know what
we're measuring and don't get fooled by
other things uh third I think throughout
the week there's been a few kind of you
know data sessions data conferences uh
heard a lot of people say like this is
the metric that we should be looking at
everything else is bad this is the one
uh and depending on who you talk to what
their perspectives are like what areas
they focus in there be many different
ideas of what doing well is and the
first question are we doing well many
many different ways someone could look
at that and make that uh
judgment and so with that I'll go into a
few of these ways of what doing well
could mean uh I think our approach is
generally you know start with some
intent we want to measure uh like some
something we think is healthy for our
ecosystem and then what metrics are kind
of proxies for that so A few of them you
know very early on we're like user
engagement and adoption you'll hear that
everywhere some sample metrics
transactions people doing stuff gas used
compute stuff uh and then users so a
good outcome of going of focusing on
these things is you know you scale your
chains you reduce fees let people do way
more stuff on chain you grow all good
bad outcome is if you're just focusing
on making the transaction number go up
all kinds of programs things you can do
to artificially inflate that potentially
to some short come outcomes or
short-term outcomes um and kind of waste
of time there the asterisk is on users a
soap box for another talk but no one
knows what a user is uh we could talk
about that later I guess hopefully
getting there soon uh second one so you
know talk about the demand side what
about the supply side uh developers
building things on chain mind share
people coming to you to build their cool
applications so some metrics here
onchain contract deployments maybe look
at GitHub for Stuff a little further
Upstream good outcome build good
developer tools kind of simple there bad
outcome is you're just like give me as
many contract I can get you know kind of
lose sight of you know quality or
long-term sustainability there um and
yeah that's a bad outcome there economic
activity is another one you know total
value locked so it could be you know
tokens deposited into Finance
applications um or any kind of volumes
like transfers trades things like that
Devcon rough on The Voice um so good
outcome address real real would be good
Real World Financial
opportunities uh bad is you know again
short-term liquidity stuff comes in
stuff comes out low retention right back
where you
started financial performance the last
one we go through you know why go
through all this complication why don't
you just look at are you making money
are you making fees you know we already
have some some metrics for that kind of
well known across any industry um what
Revenue profit are good outcome General
measure product Market fit people
willing to pay you can measure that uh
bad outcome is so focused on that you're
like keep fees High money's coming in
like we're good um could be at the
expense of user experience and people
churn you lose
them uh so a theme Here each indicator
has some good intent to start off with
measure something useful you can you
know tell yourself it's all good um but
over optimizing for one has some bad
outcomes um so yeah so we kind of like
realize there's not like one key metric
for everything uh so we had to figure
out how we move forward with that so
what do we do you should help
us next
slide okay so um this is kind of like
ecosystem Health metrics framework that
we've been using to approach the
dashboard that we're going to show you
later um but generally you want to start
as kind of like a fun analysis and you
want to think about what are the um what
are the drivers or um kind of the levers
that you can pull for the ecosystem
system and I think this framework
actually not just only apply to chains
but also apps or basically any other
product you want to build um and then we
want to come to the network effect so
for example like brand product
decentralization how is it going to impa
impact your network and here as a chain
operator what you want to look at is as
you grow the chain you want to attract
developers more develop developers
building apps and they will attract
users and more chains come in so this is
a flyware effect and um the proxy that
we want to use to measure this F fly
will effect is onchain usage and this is
not a static metric because I think
everything is evolving and when there
are better metrics coming we just
measure them and right now we're just
using transactions and gas usage as axy
for onchain usage and down and at the
very bottom of the funnel is just
Revenue which is measuring the
sustainability but is the impact of that
is usually seeing at um I think at the
very
last so before we share sh anything more
does anyone have any
questions are you guys still
following don't be shy okay I see some
people nodding so we can keep going um
so yeah now I'm going to introduce what
we build and I'll hand it over to
Michael
again yeah so some of you may have seen
this uh so kind of going with the theme
of there's no one metric no one big
number we really want to focus on um we
decided like you know we have many many
things that uh we think are you know
potentially good proxies for ecosystem
Health um so rather than over optimizing
for one they all matter in context of
each other um you see one one metric
going up one going down that tells you
something uh everything going the same
direction may give you more confidence
that uh you could be seeing like real
growth or a real health of your
ecosystem um so this is like one view
into there not not don't don't worry
about what each metric is now we'll go
through some of that now um but think
there is something too you'll see like a
lot of people will you know make things
or or make statements about like what
are your incentives that drives what you
do um and so I think there's some role
when you're building either your
ecosystem dashboard or whatever your
source of Truth is or what people are
looking at as the canonical thing they
rally around whatever metrics you put on
here in a way will drive what people are
doing what they're optimizing for so it
is a very powerful kind of role you play
here um which is why it's important to
yeah or at least our views it's
important to show many many many things
so you're not creating some some unknown
outcomes everyone wants to be the top of
a leaderboard so it's very important uh
you know how that is
sorted so now we're going to uh quickly
go through each of the metrics in detail
we won't spend too much time on it
because that's not the most important
part um but yeah the first metrics that
we want to show here is
transactions um and then yeah so is very
self- explan explanatory and the reason
we choose transaction is because it
touches like every participant on the
blockchain would touch transaction for
one reason or the other and um but the
transaction by itself doesn't really
mean anything if you don't put it into
the context because it can go up for
various reasons there may be bosss there
might be that the macro trend is just
going up in general so you want to
compare that to the the market or the
market share that you want to measure
against and anyone can Define what your
metrics is for example like you can just
say I want to measure against L2 or I
want measure against the market share as
the whole crypto ecosystem or it could
be vertical wise as well so that's
something that the that's something you
can kind of like Define what the market
is looking like and you want to know
like oh am I growing is my growth
outpacing the industry versus just like
I'm growing because I'm writing the
trend um and then usually when we see
this like kind of transaction numbers
going up the natural question that
follows is um where is the transaction
growth coming from and we have a very
nice dashboard that kind of like tells
us uh where the transaction is coming
from by the project or the contract and
the very important thing here is about
the contract mapping because without the
without proper like labeling is just
really hard to understand what's behind
the meaning of each of those like hex
code um so yeah so this is just one
example of how we kind of like dissect
uh what's happening in in each of the
chains next one I'm going to talk about
is uh the L2 gas use per second and this
is just a metrics that measures like how
much compute a chain is doing and
usually this number will go hand inand
with like transactions but there are
also examples where uh you will see like
the gas per second going up and sunsense
Plateau but the transaction number is
not going up and that's because uh
usually for example on any of the al2s
when the when gas per second hits the
limit the network will be congested and
people don't want toay P because it's
expensive and transaction number will
actually go down so uh this is just one
example that you can't just look at one
metrics and say something uh because you
can have lots of stories behind uh next
one I'm going to quickly talk about uh
is the app tvl and also the assets on
chain uh the difference between this two
number is just that um usually I think I
we kind of like Define the the app tbll
as the economic value that is all the
liquidity that is that is locked inside
ecosystem and then on the other hand the
asset on chain is just like the sum of
any kind of tokens that is locked in the
canonical
Bridge um and also any of the Native
tokens that is on
L2 and the other one that we show is
just Collective revenue and the revenue
definition at least that we're using
here for uh for the super chain
ecosystem is any any chains that
contribute maybe like 2.5 the higher of
the 2.5% of the sequence of Revenue or
the 15% of the net onchain value and the
last one is governance which is
something that uh we also focus a lot
and here we're just measuring like the
total vable op
Supply the reason that we care about it
is because it's about capture resistance
and we also want to see like actors
acting rationally to make economical
decisions um yeah there can be lots of
analysis that comes behind this looking
at concentration voting power behaviors
of voting Etc uh for the optimism
Collective and back to
Michael yeah so now we've gone through
all this you can kind of see some of the
intents we wanted to you know view as
health for the ecosystem we mentioned
those all before and the metrics that we
chose to represent those uh I think
another good kind of case study here is
if you were you know we talked about
over optimizing for one thing or not uh
you can kind of see how all these charts
May Trend in similar directions
different directions one obvious kind of
Divergence that you may have seen as we
went through is you know wire
transactions going up gas use going up
Collective revenue is just you know kind
of straight down uh and that's kind of
like been an interesting case study I
think we saw after EIP 4844 the whole
blob thing that launched uh in March of
this year uh transaction cost on l2s
went like straight down which you know
great for user experience way cheaper to
to do things on chain uh then we saw a
lot of these L2 chains hit congestion of
what they could actually process on on
their chain and that led to fees going
up price of
skyrocketing uh opportunities for you
just to go churn uh so where the
decisions were made to try to keep
transaction fees down let there be you
know way more transactions that could
happen on chain uh you did see Revenue
go down in that sense so if you're only
optimizing for that you'd be like this
is crazy what are we doing um but if
you're kind of taking a longer term lens
looking at ecosystem growth um this may
be uh you know the things you see to
make it uh seem like a rational decision
there um and so some questions we often
get are made a nice dashboard like why
does it matter I think some influence
that we see is there's um you know
source of Truth rallying point for the
whole Collective hard enough within one
company to do this um then we have a
whole bunch of stakeholders in the
ecosystem those like the labs company we
both are Foundation teams running chains
delegates voting on governance grants
councils all these kind of things huge
huge long list of people who you know
make decisions within the collective um
helpful to have one chronical source of
Truth Versus I heard this here I heard
this there um so helps kind of bring
some order to our decentralized chaos
that exists uh growth opportunities so
you know whether it's the raw number or
something of looking at how you're
comparing versus total industry some of
these market share metrics uh could open
up some growth
opportunities like where are you lagging
where are you leading um could open up
yeah areas of where to go deeper uh and
like we kind of briefly touched on with
going a layer be under transactions into
what contracts are being used what's
driving that uh opens up opportunities
for for future research um you know see
something moving or see something
changing you know why is that happening
leads to one questions to five questions
to 10 questions and uh then you're going
going deep there but hopefully helps you
prioritize towards the most impactful
things U versus what may seem kind of
interesting at the time uh in general
goal setting um you know whether
whatever your targets are it's helpful
to have this to rally um behind and I
think you'll often see sometimes numbers
change or metrics change kind of
represents where the direction we're all
we're all going is is trending
towards uh very briefly so this is a
public dashboard here I I'll go through
back through everything here um so I'll
have links in in GitHub that will show
soon how we built this very briefly
using a bunch of you know public apis
that exist hold this down here some
chain indexers we use you know not a
complicated uh system database table
business logic um you know building
metrics joining stuff um then the
dashboard
there okay so now before the fun stuff
after to listen to us talk uh any other
kind of yeah questions comments uh on
what we've gone through so far yeah go
ahead I can I can repeat the question it
was like uh analysis on secondary
markets for SWAT value um yeah I think
that's like maybe goes into the economic
oh sorry is it something different lock
oh lock value
so you mean secondary what do you what
do you mean by secondary markets of lock
value
cont oh yeah
yeah yeah yeah so it's
like yeah it's like some some Nuance on
top of like value being locked I think
there's something that's interesting
what we've tried to do is um so like use
like defy Lama as our like total value
locked and apps Source um and there's
like I guess like a maybe it's similar
but an issue there with kind of like
double counting like you can deposit
here do this do this do this do this and
you make like one token represented 700
times um so at least like def does a
good job of trying to exclude that
double counting which helps maybe not
totally related but um maybe it's in
like the yeah business logic segment of
like is that what you described like you
know good or bad you want to filter it
out or included or you know call it out
as being important um I think definitely
different perspectives whether you're
like a
yeah it generalized chain ecosystem like
a specific version like a specific app
um hopefully it answered a little bit
but we can talk maybe after about it too
anyone else yeah go
ahead I think my question is how
accurate like how do you like know that
your data that you um show is
accurate yeah good uh prompt for uh some
stuff coming soon so yeah so there's I
guess like a few different data sources
but one is yeah I mean like General
trust and that we do use like ones that
are you know the examples of like the
defama gry l2b groups um that do the
curated data so he's pulled that that
raw result um yeah there's an element of
like trust in there too um but think as
well like there's you know if their data
was wrong it's like that's no one would
use it I guess uh but yeah it's
definitely like a a point of even though
like General data quality something pops
up it looks weird figure out like go
deeper into it I think for a chain
indexer perspective like you know we're
building things that are checks to make
sure like are all the blocks there does
the amount of gas match up and things
like that too but uh yeah I guess trust
trusted sources and verify stuff I guess
when it comes up as well but yeah a good
point it'd be bad if it was wrong um
yeah anything else cool fun stuff
time uh so kind of a workshop here if
you have a laptop with you you can you
can start uh building on some things
together but if not no worries like you
know find a friend next to you and you
know we're going to go build some cool
charts
together um so find out the best way to
navigate people to a GitHub repo um
there's a QR code but you know phones to
computers Apple's done some stuff it's
kind of cool we'll see if that works too
um so yeah so we have like our op
analytics repo we build everything in
it's getting cleaner um but there is a
dedicated folder for you know demos
Devcon 2024 here and try to find that uh
there's some yeah optional work for if
you're like beginner intermediate with
you know SQL or python you can uh jump
in and see the code but we're going to
go through what exists there too um you
and for everyone we'll get to a spot
where you can make pretty charts with
curated data so maybe give a few minutes
for that and walk around if people need
help doing things
anything cool
um and once you get a QR code um there
are two ways you can do it if you are
very familiar with GitHub you can just
do git clone and copy the entire repo uh
we'll have we'll make constant updates
there but if you just want the demo
folder you can just go to like download
directory github.io put our put the QR
code link there and then you can just
get the folder in a zip file um do we
also have a link for the oh we don't
have the link or we should show the link
later okay yeah back to the QR
code and then fun
stuff maybe get like a minute and we can
kind of walk through what is in this
repo while people pull it up too
in a minute
okay maybe assume it's enough time if
you can't uh don't want a Forker clone
like on the GitHub UI you can probably
see enough to kind of scroll through
anyway um so we can talk to a little bit
about what you'll see in there before we
run wild and build
stuff okay
so I'll walk through a few data sources
that we use you know curated some some
scripts kind of to go run through now
shall We join them together um build new
ecosystem charts and potentially do uh
yeah call out some of the interesting
stuff people go build so what you'll see
in this repo General read me with you
know links you'll see two at the top
that are uh we had like a Google sheet
up now with the end result data that you
can just use if you want to skip to that
part um as well as the the links what we
just showed here before um we've kind of
cured here is for each of these like
apis we're using so defile gy LT right
now some python files you know functions
in there was told it was boring to go
through those so we'll skip over those
um and go through some notebooks that
we're using to pull the data join it
together kind of show a walkthrough of
how this all kind of comes together uh
then yeah get to the final data csvs
that we can then build cool things with
so walk through some of these data
sources um similar stuff you'll see on
our health dashboard but just for what
it comes through here raw So Def is what
we use for the total value locked metric
here's our chart for across the whole
crypto ecosystem um and if you break it
down by Chain this is the actual data
that we pull from their API uh what is
very cool about this is it gives you a
like total crypto ecosystem wide view
not just l2s not just EVMS you know has
everything on here see like top three
ethereum sonotron Bitcoin farther down
bunch of other ecosystems as well um so
it is good to kind of yeah compare not
just within the ethereum world but
everything else outside as well
uh other one we'll show is l2b I think
what's cool you'll see here is there's
like a similar kind of approach of
showing multiple metrics together um
what's useful here is just like a huge
wide list of Layer Two Chains um you see
like total assets on chain total
transactions what's useful here there a
lot of metadata for each chain too so
some element of like security level with
the stages there um what type of chain
it is what stack it is you know all
these kind of things that are useful
you'll see for show sample charts later
but hopefully it Sparks some
ideas uh third one's grow the P another
layer two specific one uh smaller list
of chains but definitely has a much you
know kind of wider set of metrics so
again I was like pulling these today I
was like oh cool you know more metrics
all kind of together up top uh and then
a whole wide range of stuff but yeah
from their API we pull all these metrics
as well um so you could use them pull
them all
together so iess what you'll see steps
here download the data don't expect you
to go through the code here call those
API functions uh then we try to join it
together um I think one thing
interesting to call out here is like
eventually it' be nice to figure out
some like interoperability between all
these kind of data sources um whether
could be some use chain names
differently some use chain IDs
differently um but you know do the best
we can with some of this stuff now uh
then the end result you finally see is
like processing it uh making these
metrics so Group by month now average
sum all the fancy stuff you want to do
um but you'll see like most of the
metrics that we show on that Health
dashboard you know transactions you know
onchain profit all these things um come
in through
here and then I think is cool this like
big CSV of data um We join all together
we have all these Mets we talked about
we see all this cool kind of metadata
that we can kind of slice things by um
was kind of interesting too is like we
you know our experience building stuff
we kind of filter this to
optimism but there's definitely a lot
more to think about from an ethereum
wide perspective whether it's like all
the L1 and all l2s maybe like a certain
you know stage of decentralization for
um these l2s but yeah a lot of different
kind of filters and things you can
do so kind of inspiration some things I
was playing around with a little earlier
um you know take the whole ecosystem
show transactions per day cut it by you
know L1 L2 L3 um using these data
sources here um it was kind of cool to
be like you know we know that after
March transactions increased you we see
like L1 is always kind of flat as
expected L2 start to grow what was
surprising to me is seeing from like
March April as well how much the L3
started to cut into share of all
activity um so maybe you have some
approach looking at Health where you
want to look at any one of these kind of
subsets um but I that was kind of cool
it's kind of fun
thing uh second one so like from LTB we
can get like the current latest stage of
each chain um and kind of a cool joining
experience is grow the pie has gas per
second so plotted those two together um
and this is just the the latest stage of
each chain like you probably go back
historically if you wanted to um but it
was interesting to see like you know
majority of gas use now is like
currently stage zero chains I know some
have plans to go to stage one but I'm
sure you can make a case to say like
let's look at stage one plus I think LTB
made that case you know earlier at this
Devcon um so there could be a case where
if you're looking at health of the L2
ecosystem maybe this is a split you want
do but now if you go through if you're
in the GitHub rep you'll see the link to
this Google sheet with all those uh
there's like a tab for the the raw data
there so your turn if you want to go and
go build and and poke around at some
charts um you know we use Google Sheets
because it's kind of easy to share stuff
but you know definitely any analysis
charting tool of your choice whatever
you enjoy I think we use like streamlit
plot leaf flourish bunch of other cool
stuff um yeah and I think do we have
stuff for this oh yes so
so we have uh we have some special op
swags to give away which is super
limited uh we have three tot backs there
and we are really looking forward to
seeing some really interesting nice
charts insides you don't have to build a
full dashboard use the data show
something nice and um yeah we'll have
three uh tote bags yeah I think maybe
let's give it another 30 minutes for
people to play around we we can walk
around answer questions
yeah yeah so we'll come back in 20 or so
minutes but yeah we'll walk around let
people go and go build
stuff yeah and I'll walk through a
little bit too just pulling up the data
here so yeah hopefully you can all find
this link uh this is like the r data tab
that I showed earlier uh so you can
build pivots on this download it
whatever you want to
do little sample tables we went through
earlier um but also if you're in the
GitHub you can download the raw csvs and
you know put it in wherever um yeah
we'll be walking
around e
all right we'll come back here
right all right I think we'll go through
uh things everyone kind of put together
uh after towards the end um but let's go
through into some other kind of closeup
thoughts and things but yeah thanks
everyone for joining participating uh
was cool walking around and seeing uh
everything
cool uh so I'm going to wrap it up with
uh the collective data vision
um so as you can tell cross-chain
analysis is still as hard as cross-chain
messaging and data source inability is
also very important I'm just going to
highlight here and also completeness as
well so it's really hard to connect the
data from so data providers and also
chains have inconsistent names um like
is optimism op mainnet or whatever and
also not everyone uses chain ID um the
other one we're going to talk about some
of the specializations that we wish to
exist as open data set open data sets
such as whether something is an active
human is that a real
user um yeah like you can use any trust
algorithm or maybe like um world ID or
anything else um also active developers
there's so many different ways to
measure a developer is it just like an
onchain address or is it going to be
GitHub uses or something else uh there's
also some interesting discussion about
cross chain activity and also asset
transfer especially where uh when
everyone is is trying to develop intable
inability across the chains and also
continue building on the Chain ecosystem
level
data okay so I'm going to wrap up with
this workshop for three takeaways um one
is why should you build um so
metrics have so don't just take
everything for granted when you see a
metric be skeptical is is that real or
not uh always question that and also you
want to always have a holistic view of
the market um and think about things in
the ecosystem wide like why certain
things are going up and how is it doing
in the ecosystem and also metrics are
not static they're always evolving
there's no metric that is perfect so um
keep building on that the next takeaway
is about uh like some of the open data
sources that we wish we could have
including your own ecosystem real uses
stable coins decentralized governance
cross chain assets and also any other
emerging Trends and also everything we
build is open to anyone uh you probably
have seen the op analytics repo and
we've been constantly updating that so
stay tuned for more to
come oh yeah and one more
thing if you're staying until the end uh
so this is another QR code that we have
and we have this optimism super chain
raw onchain data that anyone can get
access to uh in Google bit query so
click that and subscribe cribe um right
now we have all the super chain data
sets here including blocks transactions
logs and traces so the dream is just to
select star from the super chain uh
right now it's still work in progress
and we only have like there's no promise
of latency or anything it's just like
still testing but I would like to
welcome everyone to just try it out give
us feedback uh the data set right now is
only in October and September but this
is the most complete super chain data
set that you can get and yeah go wild
with that do we have anything
else okay uh that's all but uh we are
here for questions and also we're going
to oh for anyone who wants to who wants
to get the tote back raise your hand uh
show us the dashboard and yes uh
yeah okay so can do I'll read the
question the yeah I read the question
out uh what guys do dat today do work
with protocols if so what tools use to
analyze protocol specific data yeah I
could answer wide for this um yeah think
it's like
our I we kind of have like a bunch of
stakeholders or some internally whether
it's like our you know product teams
like Business Development teams growth
teams uh so yeah so a lot of kind of
like projects with them I think the main
kind of questions there is going deeper
into what's driving oning activity or
you know what kind of things we see as
as you know potential kind of growth
areas uh
that's we do kind of work mostly with
like you know beyond that uh you know
other kind of chain teams like some of
them do have data teams that we like
work closely with um some don't and you
know use kind of stuff that we produce
um so we started doing like a weekly is
kind of uh like super chain Health
Report that we share within op Labs with
all the other kind of chain uh teams as
well um that kind of goes through our
just like rundown kind of what happened
on the week like what's in what's going
up what's going down
um our takes there anything to look out
for so just trying to like use our data
as a way to kind of like show the
reality to the ecosystem uh you know
it's easy to see you know how many
transactions there were um but it's hard
to kind of be like go the next step be
like what does that mean and um yeah how
do you kind of go on beyond
that
okay anything else this is a long long
yeah long session was
cool cool I guess we can leave it at
that um yeah like we said I think we'll
go around and look at um yeah some
charts and things and uh yeah beyond
that oh there's a hand oh there's not a
hand you do have a hand yeah okay cool
um I don't know uh cool yeah thanks
everyone for coming uh I think we have
some time left in this room so we can
walk around and and keep keep talking
about stuff yeah thanks
everyone back
n
hey hey
back back I'm
back I'm back I'm back
back I'm
back I'm back
hello everybody thank you for for coming
on this Workshop we are Carlos and
ignazi and we work at the protocol team
at at polygon today we're going to do a
workshop about optimizing the zbm throw
this is the series 2 we already did a
talk about this uh a few months ago on
Brussels on the
FCC um but this one will be like the
continuation but anyway you will can
follow although you were not in the in
the first
one so first of all all the code that we
will be explaining uh you don't really
need to code during the workshop but in
case after after the workshop you want
to check it you should follow
this okay um the beginning of the
presentation will be the same as the
other session we did because it's the
one where it's the the part where we
explain how the ZK assembly the language
works we'll do an overview we explain
the register the instructions we'll do
some examples and we will talk about the
the counters which are the the main
measure to measure the performance of
the ZK
evbm after that the second part this one
is the one that will be different than
the other presentation we will explain
um two optimizations
um well first we explain some new
registers and new tools that we had on
the Z assembly to optimize it and we
will do two practical examples on we
will see the code before optimizing it
and after op optimizing it with the
explained tools we will see the the
optimization of the op code of push
which is a very well I think it's the
most used up code in the evm and we will
also see the optimization of the ml load
X and m x which are two tools that are
using all along the the zbm to interact
with the with the
memory but first of all let's get into
the ZK Assembly
Language the ZK Assembly Language it's
develop developing house is a language
that looks like like
assembly and it's used to write a
program that it compiles in a way that
can be fit to an Executor and after that
the executor with this tra when he's
processing a state transition of a badge
a badge is a group of blocks and a block
is a group of transactions so it's um
generating with this Trad he can
generate a proof of the state transition
of a few
transactions so this language it's done
like um very customized to be um the
best performance on doing this the
language as you can see on this image
looks like this it's very similar like
like assembly we will go deep in this
code um later but let me also talk you
about the compiler the compiler is the
one that gets the files in ZK assembly
and convert it into a trace where it
completely defines each one of the steps
that are represented on the lines of
code of the GK
aam now let's check the the code um I
will go to the um build file it's a Json
file that is the output of the CK
compiler of these lines to start with uh
start like seeing how the Cod how the
code
looks so I think I'll
go maybe even
bigger okay so the the CK assembly the
the first threat always starts in the
main CK ASM file and these are the two
First Steps each one of the lines is a
step and as you can see here we have a
resistor called step and with this we're
assigning the value of a step to a as
this is the third step the step this
step resistor increases by one on each
one of the lines of the code so here the
step value is zero and in this second
line we do an assert an assert is an
instructions that checks that the value
in resister a is the same as the value
in the left part of the line of the
assert in in case it's not the execution
will fail and the profile cannot be
generated so here what we are doing is
checking that indeed we are starting the
execution from the very beginning where
a step is zero now let's see how it
looks when it's
compiled when you build the gkbm it
outputs the following file it's the
drum.
Json and it's a very long file where it
has it a Json it has a program with an
array and a lot of objects in it each
object sorry each object is a step let's
analyze the first step following this
first line where we are assigning step
a as you can see we have the in Step
this this um this trace of Json is the
one that um is used by the executor how
so when he reach this first object of
the aray he will know that he has to get
as input the value of the the resistor
step and set it to a this one is the
flag where it says to the executor set
um the resist a with the value of a step
and these three lines are just metadata
that it's very useful for for the
bagging so the representation of the
first line is the representation like
this when it's compiled and the same one
happens with the the same thing happens
with the second line This assert it
repres like this first of all we have as
input a constant with is which is zero
and then we have the flag of assert to
one It means that we have to do an
assert on this
step okay this was to do like a first
heat up a first contact with the with
the language and understand a bit how
the compiler
works okay now you want continue
Carlos hi
okay so um what I'm hi my name is Carlos
Matana I'm going to explain a little
explain a little bit the language that
we use the Z assembly inasi kind of did
of an introduction of how to use it and
show some code examples and basically
what I'm going to describe right now is
the language itself I will describe all
the registers that we do on the Z
assembly and all the instructions that
are available in order to code the Z
assembly ASAS said the the Z Assembly
Language it's pretty much like an
assembly language that uh you can you
can use a standard one but uh well we
have different instructions and
different regist and it behaves a little
bit different okay so let's first
explain uh the registers we have two
types of registers I would say we have
long registers and a small registers the
long registers basically are registers
that are composed by eight
elements each one of those elements is a
goldilux prime frame number and
basically it's almost uh 64 bits and
basically what we use it's only the less
significant 32 bits if you basically
join all of them together you have a
register uh multiplied by 32 bits you
finally have 252 bits which is the
standard operations on the evm
basically why are we using the goldilux
prime field number basically because
it's a zero knowledge uh friendly uh
prime number so you can you can do a lot
of operations in the very quickly uh
when you compute uh the snacks the
hashing and so on on the other side we
have registers that only have one
element this element is again a goldilux
prime frame nbol and basically well yes
it's just I would say one register that
contains one element
okay now that we know that we have two
different types of registers let's say
the the registers uh by themselves so we
have five different registers we call it
kind of a generic registers and they are
basically a b c d and you can do with
them whatever you want we'll see later
on how to use them we also have a
register which is uh the state route as
you may know in the zbm uh we have a
spar we use an Spar Merle tree and the
summary of this sple three is the root
and basically this uh register um is
basically the state root of the state
three also we have the rotat left uh C
register we will know uh we will see
later on how to use that um in order to
do some optimizations we'll explain
later and then we have a kind of a lot
of registers but those registers are one
slot register uh again just one gold the
L Prime frame uh number and those
registers are basically all the counters
context St pointer from counter gas GK
counter return step Maxim H po here it's
important to mention I mean all of the
register um you can be familiar or not
but what is important to mention that we
have the pram counter in order to
read smart contract bite code so we
point to the smart contract bite code
and then we we read the B code and then
we have the zero knowledge pram counter
which is the the counter of the program
itself of the ROM
basically okay so we saw all the
registers that we have available in the
Assembly Language now we're going to see
all the instructions that we have
available uh that uh we can use when we
code DK
assembly the two first ones are I would
say very typical uh in Assembly Language
memory load memory store you get some
value from the memory and you load it
into a register or you just save into
the memory some value that it's on some
register then um we support three
different hash functions kak posidon
they all have exactly the same structure
and basically in order to do uh one of
those three uh hashing uh you need to
use Hash k Hash k Len and Hash k Digest
later on I will explain in details how
to use those instructions but the
summary could be that in the HK imagine
that you have kind of a buffer empty
buffer of bites and with the HK you are
adding bites to that buffer with the
haska length you are basically closing
that buffer and with the haska deest you
get the
result okay exactly the same for the
hash P which is hash poson
and then as the other Assembly Language
uh you have this kind of a jump in order
to jump to another sub routine and you
have kind of uh conditional jumps in in
this case we have the jump negative and
jump carry but they are in a sense they
are basically conditional
jems okay I would say that uh the next
two ones are for it's kind of a sugar
syntax because um when you are
developing on on Z assmbly it's very
convenient uh instead of jumping to a
sub routine saving the ZK program
counter and when you end the routine
jumping again to what we where you were
before instead of that you you can just
use this call and return instructions
and I would say the the the program does
it for you it automatically save the
program counter and if you just uh write
the instruction return it will again uh
return to the previous
point then we have the assert
instruction just basically uh you assert
that some value is exactly as other
values and then the next two ones are
also very important which is basically
the S slot and s store and this is
basically storage load and storage slot
when you want to read some value from
the Merkel Tre from The Spar Merkle tree
uh you somehow need to H use those
instructions on those instructions
basically I will not get into the
details but basically the key0 key1
basically defines the Merle path to
travel across the Merle Tree in order to
value and here exactly the same but you
are storing some value the value will be
stored on registers uh D and registers C
A and B are used in order to travel
across the Merkle tree
then the next one is the Arif
instruction this instruction is uh
basically us it in order to do
multiplications for U 256 bits and also
in order to prove divisions you can use
multiplication as well and the next ones
are basically oper standard operations U
with 256 bits number which is basically
addition subtraction less than sign less
than equal and bitwise operations all
those ones from the addition until the
exor they are basically using uh what we
call the binary State
machine okay and this one is
outdated why because uh we're going to H
kind of explain um how this instructions
evolve in order to optimize some of the
op codes but in order to understand it
better we wanted to First explain uh
very briefly how this old instructions
works this is basically memory align
read memory on right and memory align
right eight as you may know in ethereum
uh you have three different op codes uh
memory read memory right uh 256 bits and
memory right 8 Bits that why we kind of
did exactly the same instructions but on
the ZK assembly uh those instructions
basically works with 32
but we have a special one which is the
memory align right eight and this
basically matches the up code of
eum we will see later on that uh this
approach was nice but in order to
optimize uh the code and some up codes
um we kind of uh did I would say a
dynamic memory align where you can
select the offset the bites that you are
reading and the end the basically
okay now we will go a bit deeper on how
the register uh works the
taxonomy they are easy to use but it's
true that they have some nuances that we
will see now to do the zbm we have five
registers a b c d and e each one of each
is an8 element goldilock Prime file
number so it's 32 bits so eight elements
of 32 bit it's 32 bytes to 156 bits so
for example uh here yes and if we have a
inside we have these eight elements that
we number them from A7 to a z from the
most significant to least significant so
register assignment it's very simple uh
you do it like this you assign five to a
so in this case from A7 to A1 all the
values is zero and a z is five
the same way you can assign the value of
a register to another registor like this
so after this step the value of C will
be the same as
a now we'll try to put a very big number
in register B this is the maximum number
that you can do with 32 bits in this
case as before from B7 to B1 we will
have zeros and on b0 we will have like
the max maimum 32bit value which is
fs and here is the Nu on I was talking
about if we do a plus b we will be
having an
overflow um because this value it's not
expanded to the other elements when you
do it this way so in this case from B7
to B1 you will still still be having
zero values and on b z you will have
this value which as is a signed number
it will be like
negative if you really want to do um
this this addition without overflowing
you will have to consume a counter uh
you will have to consume an arithmetic
or or yes or a binary uh
counter so uh it's very important when
you are developing the zbm to have this
thing in mind because it can create a
lot of problems you need to know that
when you some vales to the resistors the
resistors will be in at some moment
greater or not than 32 bits because in
case they are greater to operate with
them you will have to use binaries or
arithmetic
instructions let's go to the next
slide now I will explain more visually
uh the instruction Carlos talk about and
which is the rotate
LC and it's very interesting because
some optimizations that we explain later
use it so I wanted to go a bit deeper on
it it's very simple to understand and
it's also very useful when you want to
operate with 32 bits in a register but
playing with the different Slots of the
same register Let Me
Explain If in see we have this 32 bytes
number which is very very big I have
splitted them in slots of 52 as all the
element from the element C7 to c0
so the r rotate
LC will have the same value but C7 it's
put in the position of c0 this way
you'll see the blue one now it's the
last one this is very useful when you
want to apply some operation in one
specific element of the
register now some flowing flow control
operation
um I'm not going to extend a lot on it
it because they are very very simple to
understand jump and when you call it um
if you put the resistor that you put at
the left of the instruction if it's
negative you will be jumping it's like a
condition instruction you will be jump
will be jumping on this level but it's
important to understand that it's only
checking the a z op so it's only
checking the last 32
bits the same happen with the jump Z
zero which will jump if the value is
zero jump no zero which is the
opposite the jump carry it's um
instruction that it's used and it will
jump to the level when there is a carry
on the left operation and the Sham No
Cry it's exactly the same but the other
way we have an example here of jump
carry with the lower than instruction so
in case this condition of lower than is
succeed we will be jumping on the carry
level else we will be jumping on the no
carry
level now I will explain as I mentioned
before how The Hash k hashen hash uh
works I did work I did an overview but
basically as I mentioned with uh there
are three instructions hhk Hash k length
and Hash k the and you can imagine kind
of a kind of a table okay a table where
at the very beginning the buffer of
bytes that we are going to Hash
basically it's
empty and then we are going to add some
bytes over there so in order to add some
bytes into this buffer we will use the
instruction Hash k and this Hash k
instructions is dependent on two
register hash POS and D register and
basically this hash POS and the
registers means hash POS is basically
the offset and the and D is the size so
at which point do we want to add bytes
and how many bites are we going to
add and then what we call the op uh
which is another kind of input of the
instruction it will be the bytes to add
so for example in the in these three
lines of code
basically we're going to start at
position 32 so for example this Arrow
here in the middle we are going to write
going to write basically the bytes that
are in register a then we we use the
Hash k
instruction this e that you can see here
is kind of an ifier of the hash we can
have so many hashes open and we can fill
a lot of bites on those hashes that are
open so basically the E is kind of a an
identifier of that
hash okay another instruction that is
important uh not for the optimization
that we're going to explain uh today but
it was very important for the
optimizations that we playay on Brussels
is the assert the assert instruction B
of course assures you that some value
must be equal to another value and this
is very important the must because if an
assert is triggered it means that the
proof cannot be generated and basically
this is used to
verify what we call free inputs what is
a free input we have it here free input
is that the prover can provide the value
that the prover wants it is not checked
at all so normally when we do that it's
because we want the pr to provide some
value but then later on we want to
verify that that value is correct and
this kind of opens uh some kind of
optimizations that instead of computing
some value you just let the pr to
provide the value that the pr wants and
later on you verify so not compute but
verify okay so uh uh we talk about
optimizations we talk about the language
but what are we going to optimize
basically what are we going to optimize
are the ZK counters I did a presentation
yesterday about uh the ZK count what are
the ZK counters what are the ZK counters
types that we have on the ZK assembly
and what are those numbers but very
briefly you can imagine the zik counters
as the gas in ethereum it's a resource
that is limited on the ZK side so in
ethereum you have a unit which is a
block this block the resources on this
block on the execution side is measured
in gas and it's unid dimensional it's
only the gas on the zbm the unit is the
bch and this batch has some resources
which are the Z counts and there are
many of them so it's
multi-dimensional here we can see that
we have eight different resources the
steps arithmetics binary memory
alignment kak poson padding posidon and
Shad
uh the numbers that you can see here are
the available resources that we have in
a batch for example the steps the steps
are basically you have here about
instead of a steps maybe you have he
about the Cycles or clocks no in other
projects so here the steps are each uh
row that you hit on the zik the in the
ziki R so it's very straightforward each
each line of the r it's one step so we
have plenty of them because it's very I
would say simple but on the other side
for example the kak state machine we
only have 2,000 around 2,000 uh kikx
State machines available why is that
because the KX machine is way far more
complex that for example the binary
State machine or the AR State machine
that that that's why we have way less
resources of on this K
Machine okay
so
here what we are going to talk a little
bit is about all the optimizations that
we did on the language itself those
optimizations uh came after a deeper
analysis on what we can optimize on the
ROM what are what is the code that is
commonly used that is used everywhere
that we can optimize in a very
straightforward way
so we realize that for example uh when
we call a sub routine on the zik ZM ROM
inside that sub routine we needed to use
for example the arithmetic estate
machine and the arithmetic estate
machine the inputs are the register a b
c C D and and E so what happens that
when we call that function at the very
beginning we need to kind of save some
kind of an snapshot of the values of the
registers do the functionality and then
recover that value again and this is
basically
consuming one step two steps three steps
four steps for example here in the the
example uh we are consuming four steps
in order to store the value and four
steps more in order to retrieve the
value again so what we did on the Z
assembly side uh we introduced two
instructions in order for just in one
step store a lot of registers just in
one step so that's why we introduce
these two instructions safe restore so
instead of using four
steps now here we are just using one
step but we are calling a new
instruction which is the safe and in
order to recover those values we are
using the
restore another optimization we realize
that uh in the there are in in the code
there were a lot a lot a lot of lines of
codes I would say wasted uh because we
needed to somehow loading some variable
from the memory into a register and then
just do an addition of two registers
okay this is basically consuming two
steps but what if the memory State
machine instead of
verifying the the the O op basically the
op is the I would
say the the op it's all that you have on
the left side I would say and so instead
of verifying the op you can verify the
free input the free input basically is
the dollar
here so this means that b basically we
can join two steps into one step super
easily by introducing this new
instruction okay so internally in the in
the in the pill we have this uh
introduction of assume free flag this
indicates that instead of verifying the
op it verifies basically the the free
input and this is this was very useful
because it allow us to again reduce the
steps us it in any function
basically okay nowas will explain the
memory
Aline another optimization that we did
is regarding the memine state
machine as we've said the Mema line what
it does it's like verify the correctness
of uh of some bites in session in the in
the memory the main problem that we
found of the first version of the Mema
line is that it only supported as an
input 32 bytes so what was happening is
that you had like to create this in case
you wanted to insert less than 32 bytes
you had like to create um shifting we
will see it also later like Shifting the
this 32 B that you wanted to insert
retrieving the memory that was already
stored in in the
memory so we add a new feature a new
input to this um State machine which is
stored in the register C
called mode which is like coding some
information that we need the Mema line
to to have in order to operate we can
add the offset
bites in case we want to insert in an
offset of the slot remember that
ethereum has a slot of 52
bytes this I mean this mode is coded in
in a in an array of bytes so the first
playing with um two sequentially slots
we can make an offset from0 to 64
bytes the next one is the length that we
want to insert into the memory and
finally we can
also set the if you want a left or a
right alignment putting a zero or a one
in position
Indian or big Indian I'll show you a
more deep example
now so to read memory we need to read
the two consecutive address of of
ethereum here
are represented like m0 and M1 and we
need to store them in a and b and then
we have the value that we want to update
in the memory in the r we put this value
in a variable called bites to store we
will see it also and in C it's where we
put this codification of how we want to
insert this value in the
memory so the first
parameter it's
the yes the the well the first one is
the the offset the second one is the the
length and the third one is the the
alignment in by default the alignment is
on right with the value of zero and we
will be storing the value in the left of
the 52 bytes slot and other way if we
put the value of this alignment as one
it will be stored in the left in case
you are St 32 byes obviously um the
alignment left and right is exactly the
same so it doesn't really
matters and the same happen with the
Indian type if we put it as Zero by
default we use big Indian and if we put
it as one it's little
Indian this is the value that it's
updated in the memory
so find um the last register is the
memine right um in this case you will
have to put the original value of the
memory of the first slot that you are
using to a and the second one to B and
the result of the memory after inserting
the value to D and E and the value that
um you want to insert it's in the in op
in the op we will see maybe now it's a
little bit difficult to imagine how it
work but we will see it in the code and
it will get far easier although not that
easier here um this is an example of how
we've been doing the Mema line before
the optimization the thing is that we
wanted to
read um this 32 bytes so we had to put
the value of the thir or the first slot
that we we want to read to a and the
second one to B and we can choose the
offset and we put it on c as you can see
um
here this well these symbols Mark the
btes that we want to read and we start
in the offset 12 as we have said here in
C and when we do this mem line r it will
put the value of the r output on a and
with this assert well this is like a
test with this asset we will see that
indeed the rate value of mign read is
this 32 bytes that starts on 1 C like
here 1 c and ends in like a3b
a3b and more or less happens with the
memine right but in this case you have
to put the original value of the memory
on a of the first slot and the second
slot on B and the result value of the
writing on D and E and doing this last
last instruction what we are doing is
like asserting that um indeed the stored
B it's this one which is 0 E1 and it's
that's like here also 0 E1 and ends with
be they will have their correctness Pro
it pro it and they will they will
work another optimization is the arith
mode and
this one is very useful in the ckvm for
doing the this easy recover and also for
doing the M mode up code um previously
of this optimization we were doing it
like manually the aration with only the
AR with the AR machine so it really get
very very very more simplified and here
this is an example
of another useful usage of the modular
to compute them Dem
mod thanks okay so uh now let's get into
the details a little bit so now we are
going to see some code some J assembly
but first uh I would like to explain a
little bit the push of code how it works
a little bit on the
zbm so um as I mentioned uh we have
kind of a buffer of bites this is
basically um hash it and when you hash
the bite code this is the the hash bite
code that's introduced on the SP Merkle
bites okay and this buffer of bites uh
it has on the on the zbm it has some
limitations you can read this buffer of
bites but you need to read it always in
the same way so if I'm reading from bite
one to bite three I always need to write
those bytes in the same way I mean I
cannot read it again in a different way
otherwise uh the proof will be broken
basically so since a bite code you need
to interpret the bite code and we don't
know where the pushes are basically uh
we need to write the we need to read the
bite code one by
one so again imagine that you have the
bite code it's bite after bite okay you
imagine a bite code of an smart contract
and then when you do a push operation
basically you are getting a bite code
from the bite code and then you are
inserting into the
stack so here we are reading push one uh
we are reading uh the first bite code
the first bite of the of the bite code
of the smart contract and then this will
be um added into the stack basically the
bite that we read is the I would say the
less significant bite just for example
when we have five bytes we are reading
the first five bytes of a bite code in
case on a on a push five and then those
bites basically are um saved in a
register this example is basically the
register will be the final value and
there's the this fin value will be saved
to the stack okay this is a little bit
um how the push op code works on the
Zia how we did kind of this performance
test so basically we just kind of lot
some random uh bite code in this buffer
of bytes that represents the the hash
hash smart contract bite code and then
we perform a lot a lot a lot a lot a lot
of uh up pushes up codes okay of course
we assert that the result is okay uh so
for example uh here we uh test the push
one basically we are starting we are
starting reading the bite code from
position zero and we're we're reading
one bite so for example here we are
reading 01 okay so basically
basically we are doing here an assert in
order to verify that the result is
correct when we call the push
zero uh this case also is very
straightforward we are just reading
three vites from the very
beginning so the very beginning is the
BR counter we are reading three bites we
are calling the push the push the read
push basically is a generic function
that reads as many bites as uh are
stored in the registers d and e Okay so
so here basically the result should be
reading 3 by 0 1 02 03 and in this case
this is a push 32 if we start at the 44
the first row are 32 byes or around here
okay we're starting around here to read
and how many bytes are we going to read
we're going to read 32
bytes because we set here 32 in register
DNA so this is the final result that we
will get on the final value
okay
so spoiler uh the old implementation of
the push um given those test consumes
kind of a a lot of steps you can see
that it consumes almost 6,000 steps it
consumes 278 uh binary State machines
and the new implementation of the
push uh it reduced dramatically uh the
cost of the push op code as you may know
the push up code is the most used op
code in in the smart contract in eum
basically H you can see that the
reduction
is amazing it's it's a lot so instead of
consuming 278 binaries we're consuming
just only one and the steps uh we are
getting a 6X basically over
here credits and thanks to F A guy that
is is here on the presentation uh mostly
of the all of the optimizations we have
thought about with him and I think that
I push him a little bit in order to do
those optimizations let's see some code
H in order to check the the
push to
check okay
so let let's
start by
reading the previous
implementation of the push op
code it's not easy to understand and I
will not get into the details because I
would rather pref I I would rather to go
into the optimization one in order to
explain it how it works but
basically you can this uh this push
functionality in so many ways in so many
ways so when we first code this
functionality we were thinking to code
it in a way like you Cod it in Rust in
go or in JavaScript so you need to do
some kind of looping uh some kind of for
H you need to kind of shift right in
order to accumulate the value and so
on here it's not straightforward to
follow again but uh basically what we uh
did here is uh we have all these bites
in the in the buffer of the of the hash
we are divided into four bytes blocks
then we need to do some operation in
order to compute in order to do this
kind of division and then when we have
we are reading from the very end we are
reading four bytes in
blocks we are restoring those bites into
the final value and at the very end we
are reading the what we what I call here
bytes so you can have one one block of
four bytes and then one by two bytes or
three bytes no so we read first the
blocks we store it on the final value
and then we read the left bytes and then
we store it on the final value
again this uh it's I mean if if you
think about in in in in some standard
language this is quite uh trivial and
straightforward to do just do one one
division one and and that's it but when
you go to the zig assembly it gets a
little bit messy because as I mentioned
here this third part is only the
division basically here
um the the rut block basically it's
reading from um in blocks of four bytes
and storing into the final value but in
order to store into the final value
without using arithmetics Ste machines
and binary Ste machines we do this trick
of using the rotat the left but how how
many rotat left do I need to know well
again another loop in order to rotate as
much block as you have depending on the
index of the
block this is basically this code and
when we kind of end this first Loop we
enter in another loop which is the loop
that uh reach the missing bites what we
call uh before the left bites and then
those bites also are kind of shifted
again in order to move it to the most
significant bit so here basically it's
kind of
a two Loops uh shifting
right it's a little of messy it's very
generic the code it's a little of messy
so it's it it's consuming a lot of
basically a lot of steps a lot of steps
because every time that you do a loop
even if you do in JavaScript when go in
Rust when you do a loop you need to
maintain uh the the E you need to do the
the four e equal to Z equal to 1 equal
to to blah blah blah so here ex exactly
it happens the same so you need uh to
maintain a registor in order to do the
loop properly check if it's zero then
jump to the other loop blah blah blah so
here the trick
was okay let's kind of let's unroll the
loop so let's not do the loop let's
unroll the loop then the code
looks let me find the code
here so then you can see that now the
optimized code of the
push looks very
repetitive but it's
because it's
because we don't need uh to do Some
Loops the loops are unrolled so we don't
need to maintain a temporal variable in
order to do again and again and again
the same so it's unrolled that's why the
code is very repetitive so the Cod
probably gets longer but it's much much
much optimiz it in terms of
steps so let's I I will just do one
example of this uh I will do two
examples uh how to follow this this
function of the r push optim with push
so uh this is basically the internal the
input which is d and e which is the
bytes to read that's it and then the
output will be in the register
e then what we are doing here is okay uh
we are entering into the function read
push okay how many bites uh do we want
to read one bite and this basically it's
a jam to an specific code this is a way
to say that uh we want to JB to an
specific line of code in this case the e
as I mentioned is the number of bers we
want to run we want to read so depending
on the we are going to jump on a
different level so if I want to read one
bite I will jump to the read push one if
I want to read to bite read push two and
so on so imagine that we need to read
just one bite then we will jump to the
read push one then we assign the program
counter the BR counter you remember that
is the BR counter of the smart contract
B code the very the very beginning so
and then we need to read just one bite
perfect remember that The Hash k
instruction as I mentioned it was for
writing bytes into this buffer of bytes
that we have the smart contract but it's
also us it not just only to write but to
read bite as well it is US exactly in
the same way but instead of writing
you're
reading okay that's why here we assign
the pr counter to the hash post register
and then we jump to this level the r
push
one in the r push
one basically we
are as I mentioned on The Hash k hash P
or hash
s uh the E what we put here
it's basically a pointer to the it's
it's it's a it's an identifier of the
hash okay and here basically we are
reading one bite from the in in in in
the in the bite code of the smart
contract we are reading one bite and
that bite we are storing it on the E and
then we kind of finish the function this
is quite a straightforward isn't it so
imagine that we are reading two
byes and here it start the the tricky
thing so here we are doing instead of uh
jumping uh to the r push one we are jump
to the r push two and here we are
reading the first bite which is the most
significant bite and then in the second
line we are reading the second line the
second uh bite this second bite since we
are using the
um checking the using this kind of the
free input check functionality assume uh
free we are loading that bite into the
dollar here in the same line we are also
Shifting the first value that we read
the first bite H
value well eight bytes and one by sorry
and then we are restoring that value on
E and then we are
returning okay so we are reading first
bite then we read the second bite and in
order to store in the register we take
the the first bite we shift it and then
we put here the second bite then we have
kind of built the value that we
return same happens with read push three
and read push four and
basically this uh since the most upcodes
us it in ethereum is R push basically R
one um you can see that basically
consumes very very very few
steps then if you have if you have a
push between five or 32 it B basically
it jumps to a more uh generic way of
reading
bites and Stor into the stack so for
example imagine uh the example that I
will explain is read push five for
example in order to to make it
short okay so let's uh jump to this
level uh which is re push
X and basically this re push
X okay here as I mentioned before it's
just a identifier of the high that we
want to read here here it kind of
initialize some variables because they
will be using before afterwards and then
here we are
basically these are I love this trick
but basically we are kind of jumping in
a reverse way in order to accumulate the
value properly of the heights that we
are reading from the buffer of uh of
bites so here for example what uh in the
example basically you can imagine that
the E is five so the read push base
table level is here is this
line then we are subtracting five so we
are just jumping to 1 2 3 4 5 to this
line here and here what are we doing we
are reading one bite the first
one here as I mentioned uh we have kind
of initialized those registers so in C I
will have the first bite that I have
read on this buffer of bites
then I will write I will read another
bite remember that I have in C the first
bite then in a I will
accumulate
this the next four
bytes and what we are doing here the
trick is that we are
shifting one slot I mean we are
shifting um you remember that a register
is called composed by eight elements so
we have shifting one element of C that
remember that it has one bite we are
shifting to the left and we are adding
the a value and then we have the final
value in order to add it to the
stack you can do exactly the same
exactly the same uh example but instead
of five uh just imagine 15 16 or or
whatever okay this trick is very clever
because it saves it saves a lot a lot of
steps of the push off
code and the off push off code is very
us it on ethereum and basically here we
are using two techniques the first one
is the
unrolling uh Loops so instead of doing
the looping you just do all the steps
that you would do in a loop so you don't
need to maintain these temporary
variables and then uh we use also here
this uh assum free uh instruction
okay okay that would be it uh want
to okay so the next thing I'm going to
explain is the optimization of the M
load X and m
x so um now we will go deeper on the
code of how the state machine of the
Mema line works but first before the
optimizing the dis estate machine
remember that I said that this estate
machine only oops only was
supporting as input 32 bytes so what
happened is that we had like to if we
wanted to store a value with less than
cannot choose the length so what we have
to do is to read the current memory that
is restored start shifting um this
memory with the value that we want to
insert to generate this 32 by slot and
then use them
mign with this input here is an example
of how we were doing bit before to
understand the how over loading or was
or doing it before the optimization
imagine we want to store these bites is
two
FS that in with an offset of four bytes
and in the current memory we have this
slot of 52 bytes with this all A's so at
the end we want to put these two Fs in
offset four so we want to put them here
what we have to do is read the corrent
memory read all the
A's shift left
and uh an amount of 32 bytes minus
offset minus the length and shift right
so that we had this value in a
registor after that we need to get the
other side of the of the value so we all
again took the current memory and we do
it now the other way we shift right and
then we shift left so we have this a a a
and all zeros and finally we had to add
the three slots so we add this one the
that we want to store the shifted right
ones and the shifted left ones and we
get the result and this is the input
that we put to the mign state machine
luckily now it's far more easy because
we can choose the length that we want to
the Mema line to to prove so we just
have to give him the value these two FS
say the offset and say the
length now let's
see um in the code how was done before
and how it's done
now and as you can see here this is this
function the M storage function it's
widely used among the zbm and it's used
when we want to store a b of less than
lot of of of
codes this is the not optimized code as
an input we have the offset where we
want to store the the value and we also
have the length and previously I will
not go line by line because this one
it's very very long but well we always
check first that we have enough counters
to do this function here we are storing
like making a snapshot of all the
resistor as you can see we are not using
the save here because it's not optimized
we do some checks of the memory
expansion the gas if it's correct to do
the this store and here we start to
do jump to the m X2 here we do these
shiftings that I've shown in the in the
slide it was a shift left and a shift
right and here we have the value in a we
shift left this value then we shift
right this value then we make the
addition we shift right again everything
to obtain this 52
bytes that we want to insert in the
memory the case is that it was very very
very tricky and it had like a lot of
complexity also shift right and shift
left operations are very very step
consuming and when we had the the we had
this this value that we want to to store
it's on that moment that we were doing
the M align State machine here as I've
said before we put the value of the
first slot on a the value of the second
slot on B and the resulting values on D
and E here we do it with a free input
and finally we do the
mign state
machine and with this ml Lo we are
asserting that it has done correctly
that indeed it's inserting the bites
that we want to to insert and now we
will see how is it when it is
optimized you will see that the lines
have been reduced
dramatically we the same way check that
we have enough counters as you can see
we only checking steps and memine and
few few very few steps in comparison
with the other that in the in a first
view means that really it's very very
optimized comparison with the other one
we do this same length check and here we
use the
save so instead of using I think it was
four or five steps for snapshotting the
register we just do the save and they
are all stored in just one
step this function it's super super
optimized actually it uses some
optimization that we have not explained
yet that makes it a little bit more
complex to to understand but well I'll
try to explain line by line as a it's
it's only used
for trying to store memory of less than
it's more than 32 we throw an error
and
here in this I would say like less than
before like in I don't know a 100 we use
this free input with this zero we assure
that this free input it's less than 32
bits that it's storing in a at least
this well this are like the same checks
that we were doing in the other version
but this one are are optimize
it also we check here that the that
we're writing the memory in a lower slot
than the maximum expansion bytes the
maximum expansion bytes actually it's a
constant we can check it yes it's a
constant that is the maximum memory that
you can arrive in the ckvm OR in any
evbm with the 30 millions of gas that
you can do in a ethereum block
here we do it's like an optimizing way
to do the offset U that we before here
having the offset we get in which slot
and which offset inside the slot we are
trying to insert this new value for the
for the
memory here we do some more checks and
finally here as you can see we don't
need to do any shifting because this new
mine State machine supports setting the
length of the value that you want to to
insert so any value lower than 32 bytes
supported so the same way we insert the
value of the first slot on a the second
one of the second slot on B and by
threee input we get the new value after
inserting the the value that you want to
insert and you do the M align State
machine now this is the the new one and
with this ml we are checking that indeed
this the result that it's being
inserted it's the one that we wanted to
insert so now I will I did like a test
of Mema line that it runs the same code
to the not optimized function and after
we will run it with the optimized one
okay I have
it
here well this R me it's in the QR that
we shared at the beginning of the
presentation first we show uh we execute
this test and while this test is doing
some State and some mine State machines
she's calling the m
x and as we can see the nonoptimized one
it's spending like 12
seven AR 12 binaries 200 steps and for
the new
one it's only using one M line and 25
step so the optimization is huge and it
really impacts a lot in how many
transaction can be fit in a batch and it
also this impacts a lot in the price of
the transactions when you do it in the
zbm so um now this seems like leral
optimizations but they really make a
very big impact in the pricing on the
ckvm so in the competitivity in the ckb
and with other chain so they are really
really
important so I think that that will be
everything from our side thank you very
much for coming a special thanks to F
for for his contribution on the
optimizing the ckvm and well hope you
had a out time Carlos thank you for
being here
any
questions
obvious you're saing 10x
instruction
ring
number that need to beated by by and
obviously Ames across the entire supply
chain from normalization
agregation
basically work yes oh thank you so uh if
you have kind of a push that consumes
to prove 1,000 steps you will
take just as an example one minute but
if you need to prove 100 steps so the X
less
basically uh the time in order to
generate that proof will be way less
okay it that means that you need to rent
no the Inu you need to rent in order to
generate that proof also will cost you
cheaper and if it cost you cheaper it
means that the impact of the layer to
transaction of the user also will be
cheaper also if you generate the proof
much much much faster you can aggregate
uh in advance of course because uh you
need to when you finalize some proof
then you finalize another another and
then uh when all the proofs are finally
uh generated then you start the
aggregation phas face so I mean if you
finish the proofs before you will start
the aggregation before as
well yeah yeah of course exactly AIG
difference yeah yeah yeah yeah yeah
exactly exactly so optimizing this
meaning optimizing everything at at at
the very end everything speeds up
everything uh it's uh cheaper so it
benefits not just only the approver the
sequencer not just only the appr but
also the sequencer and the
users but it takes a lot of time to do
those
optimizations it's not easy when you
analyze uh the code and the offenders
and the bottlenecks and so
on what do you
mean
iume to iume the
codas signicant
how many I mean uh the ROM basically is
an evbm implementation in zero knowledge
language H we did it by hand so line by
line H how many lines I don't
know more than 1,000 yes totally I think
I think only the painting no well the
pting I would it's very difficult it's
very diff well we have some
autogenerated code of the e in the pting
that it's maybe 500 lines that Tor did
modular exponentiation also it's
crazy um more than 200
lines uh if we left kind of aide the
precompiled which you know are kind of
difficult to to to do on the ZK side the
rest of the code should be
around two 2,000 or 3,000
lines
thinking yes sure totally no I
mean yeah yeah I mean for example what
uh what we did is um instead of going to
the code manually and check if every
line and can be um optimize it what we
did is basically analyze some traces of
some transactions in ethereum that just
to happen ethereum like a Unis swap swap
uh once we got those traces we kind of
build a ratio between um how many times
a op code appears on that Trace I would
say a defi Trace generic defy trace and
then understand the bottlenecks and then
we then uh analyze the compiler and the
code in order to perform better that's
why we put the focus on that specific op
codes because those OP codes were the op
codes most us it in ethereum most us it
in uh defi uh transactions and it was
they were the most offender of codes the
the one that consumes a lot of steps for
example and binaries and arithmetics so
we decide to put the focus very focus on
on on those of
codes thank you for the
question any
more anything else
yes well this basically happens on the
proving s uh so we have kind of the main
State machine the main State machine
calls this secondary State machine which
is the memory align State machine and in
order to prove uh memory readings and
writings we
basically uh sort all the memory all the
actions memory that uh we did and then
we prove that they are
correct yes but I mean
yes yeah yeah yeah that's why if if you
put all the MS stor and M in
order uh you will have the flow of an
specific memory region and we are sure
that it's okay on the proving
side if you have more question about
proving and and how the state Machin
works we have here the the guys also
know yeah
instruction initial
very first
value add for first value the
instruction right so that that's so
that's why I that's
ex time loading that right then you need
to prove that whatever manipulation
happened before was done correctly so in
principle so you would have to carry the
proof for that particular address the
sucessful over and then first pro that
recurs
Pro
ver Pro that you have anur the entire
history of the manipulations for that
address was done correctly otherwise you
don't have that
right
I
maybe we have like one minute for one
more question maybe but very fast I
think we canate later on we will talk
later
question youal about
optim and you
about yes and uh um because you optimiz
of course you reduce uh
C and uh yeah okay maybe youe this but
uh how you
configure the conf of the
good back back
hi welcome
everyone I'm excited to introduce uh
today bit Beckers AKA Ken who will give
a workshop on how to Kickstart impact
funding with hypers certs and I'm
excited that you guys are here to learn
what we have built and how to use it and
um just to share a little bit of from
the history of hypers certs it it
started really as a research project at
protoc collapse where we were interested
in how to all the amazing things that
people in the world do but are not
rewarded it and recognized for
appropriately and out of that research
we started the hypet project and right
at the beginning we were like actually
we just like need to build it and try it
out and then Ken and some others came
along and we're the first people
actually building the first prototype
and um Ken uh is still working on this
uh which is amazing he has been um
basically the core contributor to all of
the stuff that we have built um that's
why I'm very excited for this workshop
and um Ken take it away thank you hul
does it work can you hear me okay great
um well thanks everybody for being here
I'm uh Ken or bit beers has hul
introduced me um I'm going to be hosting
the workshop today we're going to be for
a little more than an hour what I'm
going to do is that we're going to run
over hypers and what is the hypers stack
basically what have we done over the
last summer so to give you the tools
that you need um and then we're going to
really start in the workshop part and
for the workshop part we uh want to help
you define how you want to use hypers
certs look at your project and look at
your Project Life Cycle and then get you
started with our template repository so
you can basically Define your own little
context for uh using hypers certs maybe
to be uh to begin who in this room is
familiar with
hypur I see doubts I think think I've
pitched it with you many times but we'll
get there um so it's half half so what
I'll just do I'll slowly just go through
like hey what's the idea what is the
mental model how do we do this if you
have questions there will be a few
natural baking points if you have urgent
question feel free to share and then
we'll move to the workshop
stage I might move um let's see so
what's what's the problem that we're
trying to solve for with hypers certs
hypers certs um um no sorry wrong
direction so we have contributors in our
ecosystem and our contributors uh invest
time and resources and impact for work
these can be many different things uh I
think the most familiar for most of us
is working on open source software but
it can be empowering local communities
it can be environmental activities
social events coordination stewardship
research it can be many different things
but we um I think for everybody who's
native in rep 3 space we have a huge
grants ecosystem allocating large
amounts of money to many many projects
for the work that they're doing and um I
think with the current explosion of
Grants programs and matching funds we
also should start thinking about
accountability why is this
important because if an impact funer is
looking for opportunities to allocate
grants of funds depending on the amount
that they want to give they want to be
more certain about what is the
effectiveness of that amount right so
let's say you want to give somebody
Kickstarter Grant Kickstarter Grant will
probably won't be 5 million it'll be a
lower amount you also have
like more flexible criteria to allocate
those funds and vice versa if you have
something with a very high amount you
want to be more strict and this is a
common notion that we're discovering in
our space is that we working on not only
on grants and allocation but also on
accountability and accountability also
flows into reputation and can fund into
new funding
streams so this impact fun is looking
for opportunities to fund impact for
work work on open source software alism
personal involvement Rising ties raise
all boats they can have many many
reasons why they want to do this but we
know we have a world
where basically people with bags or
organization with bags are allocating
funds to people that would need us to do
their work so we know that we have
impact creators we know have impact
funders if we just put them in the same
Marketplace everybody's happy right no
because usually that's not how it works
so what we don't what we don't know at
this moment is the funding really
effective and the funding effective can
be in multiple Parts in the life cycle
of a project right so if we look
proactively and you give a grant for
somebody to get started you're expecting
them to make a promise and to deliver on
that outcome and the outcome can be
different because if we all knew the
outcome we don't wouldn't need think
anymore um but you do want to have this
accountability
mechanism what this gives you after
after the first cycle is that you have
somebody that made a promise you wanted
him and you know they delivered so this
is first step into reputation now when
we do this retroactively and we look at
what they
delivered um we can use tools like retro
retroactive public goods funding or Easy
r pgf or whatever people are doing uh
now or what op or other projects are
doing we can give them the tools um to
look back and to evaluate what does
hypers certs add to this is that we
close this feedback loop by returning a
fraction of a hypur to the people that
to the donors and to the funders what
this adds is that um the funders also
build up like reputation on what they
built and
funded to facilitate all of this
complexity we need an ecosystem that
surfaces impact for work to funders in a
transparent and verifiable
Manner and for this we use hypers certs
um hypers certs are onchain impact
certificates that declare would did what
and when sometimes even where
um and our goal is to have an open
protocol that people can use within
their own context to establish an
interconnected impact funding
Network so what are hyp how do we do
this hypers are onchain claims on impact
for work so uh hypers anybody can make
one right so I can say what I did last
week is planning x amount of plants or
trees and I did this with these
people these claims need to be evaluated
under uniqueness and truthiness because
anybody can make the same claim so I can
make the same claim as uh somebody at
that table or this table and we still
don't know what is true right so imagine
we have two identical hyps we now
introduce an evaluator that says oh this
is the real one this introduces an uh
Russian dull problem because how can you
trust the evaluators but that's a
different aspect what we need at least
is some flow that verifies these claims
and why we do this again is because the
funders are more likely to fund
positively evaluated
impact hypers reduce a friction to
funding impact for work because we
gather all the data that we have in our
Network about ownership funding flows
work that has been done who has done
this where has this happened and we
profile and also the
sales of these impactful work containers
and we provide a unified data set via
our API and graph of impact for work
contributors and
evaluations again the idea is that it
flows into our whole ecosystem and we
build like the uniform data
layer um how do we do this within hypers
or how is this facilitated by the hyur
foundation is that we can I take this
like can I
does that
work hi can you still hear me okay
awesome because this is way Chiller than
standing still um so what we have is two
things we have the hypers protocol and
we have the hypers marketplace the
protocol is basically the minting so
it's a 1155 that we modify to
work with some aspects that we need for
hypers certs which is for instance that
they're semi fungible so every hypers
cert instance is a unique nft but they
can make part of the same family or the
same collection and this is like the
tweaks that we made uh on the flip side
this also means that we have some
features that openc doesn't support so
this is also why we use our own
Marketplace and with our Marketplace we
can leverage these features like to
having fungibility which means that you
can create a hypers cert of your work
that has a certain Supply and you can
for donation purposes we'll get there
anyway you can do many cool things with
hyps next we provide the tools so the
tools that we provide are SC Cas API and
graph
um yeah and a template repository and at
the in the workshop we'll start working
with this template repository it's uh
for us also something new so what I also
need from you is a lot of feedback like
does it work what is the first thing you
want to do but we'll get there then
there's like a Tipping Point in
responsibility so the foundation takes
care of this and then what we expect to
do with AO groups is focus on the use
cases application integration right we
don't have the knowledge or the
expertise to support everybody in their
respective domains or to tell them what
they should do but what we need is the
people in their respective domains which
is probably many of you we need them to
um collaborate with us tell us what are
important metrics how do you want to
structure your data what is your life
cycle of your project and then how can
we integrate with
hypers so somewhere here we need to work
together um but I don't have the
clicker yes okay cool so how does it
work this is a big picture um I'm going
to desect this picture over the next few
slides we're going to the impact that
they create the hypers as represented
work the evaluators and the funders what
I'm going to do is I take a little
component I tell you why we do this and
I tell how we do this and then at the
end we should have the whole picture
together
again if it's if it clicks yes okay so
remember hypers onchain claims on impact
for work so we have a contract which is
the hyper m.
Soul uh this is one example
but we're op moving to fcoin or an ARP
base I'm forgetting one C and their
respective test Nets
so imp
creators rep representing by represent
represent the contributors create work
so this can be anything so the
the the beaten horse here the same
example is like rep through rep Beach
cleanup or it's planning trees but they
do something right this something is
declared in the hypers cert and that is
done by minting with our contract what
do you actually do when you Mint one you
mint the claim knows the Creator we know
the data that you're claiming we know
the supply
and the transfer restrictions we'll dive
into Supply and transfer restrictions a
little bit later what's important to
remember is that transfer restrictions
enable you to disable secondary Market
activities then we take all the data we
put it in Json and we stored it on ipfs
and then we Index this again to make it
easily available for you but basically
everything is on ipfs or on
chain the claims need to be evaluated on
uniqueness and
truthiness and for this
um we leverage EAS EAS is very
generalizable right it's a registry of
schemas and it's registry of data that
matches those
schemas which if you remember the point
about like working together that means
that we don't need to Define what your
information is the only thing that we
need you to do is to connect the
information that you can store on EAS by
referencing a hypers cert by
saying this evaluation points to this
hypur on this chain right and then we
can always we can figure it out we can
map the data we can put everything in
the front end everybody happy um so the
impact is observe by evaluators which
produce an impact evaluation which
points to the hypers
Sur and again how we do this is we
create evaluation schema that references
a hypers cert and then we create ad
station based on that schema so we
defined three fields that we need you to
provide which is the chain ID the
contract address and the token ID and um
all other fields for example this is one
of the evaluation schemas in our current
application are um defined in the rest
of the
schema the idea is that we know the
schemas that are supported with hypers
certs We Gather all the ad stations from
that and then in our same graph you can
read all the ocations are relevant for a
specific hypers
seert then the funders are more likely
to fund positive positively evaluated
and for this we built our own
Marketplace or actually we didn't build
our own we forked looks rare and then we
took out a lot of components that we
don't need and we added strategies that
we do need this uh Marketplace allows
you to buy sell bid do the do the do the
normal things that you expect from
Marketplace but then specifically with
hypers
functionality um the theory is that the
funders signal the impact evaluation by
the evaluators they see one is true or
one is more true or this is really done
by bid backers and this wasn't done by
bid backers and that helps them Define a
Uris take on what do we want to fund and
how do we do
this the marketplace like I said is just
what you expect from Marketplace you
define your strategy you define your
order parameters you say for this hypers
cert what is the price what I what I
expect when I would sell 10 50 or 100%
of
it and we do St Stables w e e and the
the basic common uh
tokens so back to the bigger picture the
creators Creator work stored in the Imp
in active it will happen at one point
and at one point there will be impact
assuming things go good there's
evaluated evaluations are produced
evaluated evaluations are shared with
the funders and the funders actually buy
these hypers certs or fraction of the
hypers certs to fund the impact for work
and in the ideal world what we see is a
flywheel where groups deliver their work
it gets positive evaluated it gets
funded and it can boost up into the next
one as as this cycle repeats these
groups build up reputation but also
funders build up reputation so you can
even think about mechanisms where
because they've been there at the
beginning when for instance gitcoin
started they funded it and now they're
like these are the big
brains um
click yeah okay so back to where our
responsib kind of ends or where we
switch is everything I just showed you
is up until the application layer right
we don't do there's no integration here
and the use cases are very generalized
and this is why we'll uh work together
how do we provide this in tooling
conceptually we have our SDK that allows
you to Mint we have our SDK with eses
allows you to create evaluations you can
basically do everything with EAS in of
itself and then we have a Marketplace
SDK
um it's now nice and modular um not sure
if we'll integrate it or that we will
leave it like this but here you at least
have a nice mapping of the tooling and
what they are responsible
for yes the hyperset app um so over the
summer we did a big refactor we um we
learned that as we were working with
different groups together that every
time when we worked together there was a
very specific need for somebody's own
custom data so if we would work with
funing the commment in in uh Taiwan they
have very specific event data if we work
with gitcoin they have their rounds data
if we work with um voice deack they have
certain data about their evaluations
anyway I think you get the pattern so um
what we actually did is we took a few
months to um refactor our infrastructure
so it's really easy to establish these
patterns with other people instead
of having a single
app you can still in the hypers cert so
that's how works that's great uh um we
updated the
designs you can now uh explore search
filter um based also on evaluations and
where they
are we allow you to evaluate your hypers
seert we provide a very basic
attestation schema for uh trusted
evaluators which is basically people
that we know and we work with at the
moment because we need to grow into this
evaluation ecosystem so this one simply
says this hypers cert I acknowledge the
name descript destion URL Creator and
owner I acknowledge the work and time
frame I acknowledge the contributors uh
and I acknowledge that for instance this
has to do with funing comment in
Bangkok the idea is to start bootst of
course then uh next you can use our
Marketplace so you can take one of these
hyps if you own a fraction create an
order for example 100 usdc for the total
Supply and then there's a time box as
well and under advance there's way more
but it it'll break your brain so this is
for most people this is enough for
now and lastly we have hyper boards so
as a very good example of what you can
do on top of our stack are these
sponsorship boards because technically
every block here is basically represent
representation of
ownership so what we created is a
collection of hypers Sears related to
funding The Commons in Berlin for all
the work that people have been doing and
depending on what you value you can
donate towards a certain aspect right so
we did the same with zalu there was for
ticketing there was for hosting Foods
media whatever and then you're like oh I
really love the ticketing experience I'm
going to fund that but you're still
funding the same big thing right so what
we allow here is that we put funders and
contributors on the same stage because
you can see all the work that's been
done and you can see who has funded it
we'll work with hypers certs during the
workshop and I hope that it's uh it will
click then oh yeah well the app so
what's happening in our ecosystem what
are a few examples of groups that we are
working
with the voice uh the was yesterday
morning on stage with NY at stage one I
think maybe you've seen it they are
building a platform to fund to
facilitate outcome based funding of
journalistic impact in India I know this
is very specific but what they actually
do is they create impact reports on
journalistic work they create they
create evaluations they assign numeric
values to these so you can Loosely
compare Apple and oranges and they Pro
and they use our Marketplace for
fundraising so this basically looks like
Kickstarter card right where this
progress bar is all the funds that they
have raised and you see there they
already
started and I think what they're doing
is great so they're using a full stack
they have a very uh specific use case
they are embedded in the journalistic in
the journalistic ecosystem in India and
they are now gradually uh growing this
collection of impact reports and
allowing people to fund them next uh
this is a this is a small hack uh we we
actually did at fun in the coms we've
been talking with gain forest for a year
about actually doing this and we were in
the same room and we just did it um so
gain forest makes biodiversity data of
the global South easily available they
aggregate the data and they provide like
a a nice front end to scroll through
time and you can inspect if somebody
says oh this is where we plant the trees
you can actually see if in that time
frame the trees has been planted right
so this is really cool and they generate
a lot of data what we can do is
containerized at work and we can put it
on the marketplace what they can do with
a data on the marketplace is actually
fund the civilians that or the citizens
that create this data for them
the integration that we did is that we
added a link or basically we added a go
Json file to our hypers meta data so
again the custom data in a c certain
context and we generate this little
iframe so this iframe is rendered based
on the metadata that we have available
it Maps a little polygon based on the
geojson data and now you can scroll
through time to see if well the work
that people have been claiming has
actually been happening
so imagine like these projects had to do
with uh mangroves or in Philippines you
can just see a report and you can add
the visual information there as
well for clarity this is not enforced
this is just part of the data set so we
allow you to use this data if it is
available uh eoser that's actually hul
maybe he wants to pick it up yeah I just
just jump in for a second because like
these are kind of the the things where
we are excited about not just building
kind of a new like funding Silo and like
one platform where like now impact can
be funded but actually really thinking
about this as a funding Network where we
have different use cases from journalism
in India to um impact um in the
ecological space so there's like a
variety of impact domains but then also
in One impact domain for example in
ecological um impact there are multiple
platforms that already exist and what we
want to provide is that you can actually
integrate hyperset into the existing um
platforms that's why it was not just
like the the one line in the stack was
not just like new applications but also
Integrations so and uh this is for
example all the work that that gain
Forest already did um they have done so
much on like the evaluation side of
ecological impact and now they can just
build on top of the hypers stack to
really build up um the the idea of uh
also connecting funding streams to the
evaluations and specifically in the
ecological impact space um we work with
myar to then extend this to the the
concept of eoser and um this is kind of
the effort to bring it to like multiple
Platforms in the ecological impact space
and um make sure that we can collaborate
Beyond a single platform and if you want
to like know more about this um so this
is kind of like the conceptual stage of
the exploration stage um if you want to
be in the loop um sign up uh for updates
on eos.com um and just to use this as as
an example this is how we think that we
can build New Impact funding networks
together um that we build these modular
systems and then if we build something
for the uh for eoser then it potentially
can also be useful in the space for
funding open source software and we can
share the tooling and Advance kind of
the the tooling and the the data
observability um that we that we need to
make efficient and good funding
decisions cool thanks um and after heerz
we are also working with fcoin Falin is
doing a r pgf round uh at the end I
think now maybe even they're doing the
votes um and hypers will be distributed
among the funders based on the work that
they funded um and that was a really fun
hack that also been done I already
alluded to the things that we did with
suzu and this is like the next iteration
on top of that so uh Shu who was part of
the residency as well he did a he did a
really cool hack where he created hypers
certs for all the pop-up cities that
have been in changai during October and
then similar to the flow with voice deck
you can basically buy a fraction of a
hypers cert to fund these pop-up cities
uh in the ideal World these popup cities
as they are becoming an archipelago they
share a fund and then they share all
these this revenue streams into a sh
shared fund and then we can do the 13 to
year um okay so looking back at the
stack that we
provide we are on many chains and we are
also open to being on more chains uh if
you want us to be there just uh let us
know and we can have a talk second we
provide the tools so we give you the API
for writing we give you the SDK for
utility methods with onchain stuff
because uploading to ipfs and minting a
and all the things is just a hassle um
and then we provide the graph which
which would make it easy for you to
basically read all the data that we have
from sales orders evaluations
attestations uh you name it and then we
have the set of applications that we
use okay so this was I think yes I think
this was the the whole speedrun of the
hyp ecosystem and what we do and how we
do this are there any
questions it's great yeah
hi you mentioned the marketplace I'm
wondering if people that care about uh
things do they actually go to a
Marketplace to find what to find to fund
or maybe they probably already know yeah
or they reach the projects that they
want that they care
about uh yeah so I would I would agree
that you probably don't want a specific
Marketplace for everybody who imagines a
protocol what we want to what we want to
do is want to enable you to use the
things that we enable with hypers certs
and which and that also means that we
want you to tap into what web enable you
to do which are permissionless trans
permissionless transactions right and
that means that if Cort doesn't support
hypers servs we need to do this um that
doesn't mean that we need to funnel
everybody into our marketplace right
because it's a protocol and we give you
the SDK and you can do whatever you
want maybe to add add to your question
question um so I think there is also the
opportunity to um because that we did
this already with the hyper boards um so
there's a widget that you can just plug
in your widget onto every website
wherever kind of the people are that um
you you surf so your own website um we
also thinking that can can you kind of
put it for example on your GitHub uh uh
repository kind of an easy link to
recognize those who did the work and to
provide the funding for your project and
the similar way um how can we also
create a simple widget to bring kind of
the hypers cert experience to wherever
your audience already is so um can we um
put this just in a faster frame can we
put this on social media where it's easy
for you to engage the audience that you
think are your funders and this will
probably be then a little bit different
for each um impact domain um where you
really think like okay this is this is
where I reach my audience to tell them
these are the cool cont contributors to
my projects and also this is how you can
become a contributor yourself so I I
agree that like this this idea of we are
just providing another platform where
like people need to like be routed to is
challenging and also like just a
challenging go to market strategy so and
that's why let's build kind of this this
network and bring the network and the
the items that we have to where the
people where your audience already is
thanks for the question
hello is this working yeah now it is um
my question is about um kind of like the
project and grantee experience which is
often they are overwhelmed by the amount
of information they have to collect and
put it in various different sources and
platforms and it is a big uh kind of
admin task right uh and so I'm curious
if you guys have explored any kind of
automations or Integrations where you're
able to sort of automatically gather
relevant data and basically
automatically mint uh these hypers certs
um for for people that's part one of my
question um and I've lost the second
part of my question but maybe we can
start there okay so St one is the about
it never really built it um so open
source sofware is a really good example
right what we're now doing with um open
source reserver and then maybe mapping
at to gr to Pi doing a bunch of bunch of
inference my personal reservation with
automation at this moment is because we
still haven't figured out what we want
want to measure we still haven't figure
out what we find valuable we still
haven't figure out what is the right
thing that we want to fund for um so I
can automate a down of things but
I'm know not sure if that will be yeah I
guess it's up for the community or the
use case to figure out oh we actually
want to bring this specific metric or
whatever it is um I I would add to that
so one is like I think that's the
direction that we want to develop into
um and so like let's see how much can we
um measure things AO medically and um
help projects um and I think this is
kind of the also kind of a shift in how
we think about public goods projects
because we should not think about public
goods projects coming to fund us and
asking for money and that let that be
charity if you think about the
ecological space or open source software
let's really acknowledge that the
projects building are actually the
heroes of the story and we should be
fighting for them to get the money that
they need to build further and not get
bugged down in like
admin task and I think you mentioned
open source Observer already can we
actually make the impact of different
projects visible without the projects
doing anything and can we then take that
data and help them to bring this this
impact data to the funders um so that we
at the same time help the funders to
distinguish between different projects
but also like reduce the burden on the
project and the same is true for
ecological data so how can we actually
engage with I mean it's like all the
dmrv stuff that is now coming up how can
we better um measure what the impact
what the Regeneration of different land
projects what the impact was and let's
put the projects at the center and
basically say how can we help you and
then how can we provide the connection
to the funders and give the funders also
the experience of actually what you are
funding has a real world impact but let
the people who do the impact actually
like work on that impact and make it as
easy as possible I think that needs to
be also like our mindset and that's why
I I appreciate the the question because
it's go goes exactly in that that
direction we shouldn't ask projects
about like more data and more impact and
more milestones and like fill out this
and fill out that we need to be
basically have the the idea of a service
provider to these to these projects
first and being a service provider for
them means also basically um Gathering
the data that funders need so that's
kind of like the the priority list here
okay perfect yeah that that clarifies it
and yeah we should
chat hello uh thank you for the
presentation everything is uh has been
great um I wanted to ask you a more like
practical question like let's say we
have an impact case something like that
and what would be the timeline to fill
in you know the whole
process so so when you have an impact
project and you want to use hypers Sears
to raise funds for that um I think the
easiest right now is if you have
completed work where you can say you can
actually show the the outcomes of that
um and then potentially also do you have
like a third- party evaluator who is
trusted in the wider audience and you
have already like some funders in mind
that you want to actually share this
with if you have all of that set up
already then I think it's like let's
let's go and like Min hypers for your
work um let's figure out what is the
right template for the evaluation
because like that probably is different
for that and then that takes a little
bit of time to implement like a
different evaluation um and then we can
either um have it through the hypers
sets.
org that Marketplace or if you
want to have like a custom experiment
experience then we can build on top of
the the template app um if we build it
on the template app probably also a
little bit of of setup time but um this
is exactly what we have been working on
that that is much easier to just like
provide your own kind of interface for
um where you can sell um kind of the the
hyperset yourself and um then I think
it's like a couple of weeks um should be
um what what we should be able to to do
now um and then depending on like how
much customization we want to do do um
that's that's I think the only only
question um otherwise like I mean just
creating a hyperset and offering it for
sale um can be done in an
hour thanks sorry uh any other questions
otherwise I'll uh would like to continue
on the workshop
part great cool thanks um so for the
workshop we decided that we want to mix
a few steps so what we what we've
learned is often when we start minting
hypers Sears with people I think like a
mint is a solve problem right we've been
doing mins for 10 years every anybody
can men a hypers cert but the problem
like with old data is if you feed the
the wrong data into the system you'll
probably also get the wrong data out
right um no swearing um so what we're
first going to do is we're going to do
an exercise and in this exercise I want
to ask you to um up with your come
forward with your project so like hey
this is a use case that we imagine for
hypers and what will of your project or
of your work and then see does
everything make sense you know are we
talking about the correct contributors
are we talking about the funders that
you are expecting to fund uh how do you
expect evaluation to happen what are
your steps to funding and um is there a
feedback mechanism in place for these
impact claims again a claim in itself is
useless we want it to be evaluated
and then when we have that done we'll do
step two which is actually determining
the hypers content so who are the
contributors what are the names what are
the addresses what is the did they give
consent um the description of the work
additional resources additional
properties and data availability none of
none of these last ones or yeah are a
given or necessary per se but if you
want to if you want to work with your
own unique context it's important to
consider this as well so this is where
we're going to start um what I would
like to know right now is who's in this
room to also participate in the workshop
that's
one one two three four five and of those
five people who has a project that they
want to work
on just the same amount that's great um
so we can do two things we can get you
as a group together and we do one
project or we maybe take uh one or two
of these projects and we map everything
out is there anybody has a preference
like I really want to talk about my use
case talk about your use Cas yeah maybe
we can like go around when we have like
five ideas to just like hear the five
ideas um like how would you use hypers
Sears in like basically two sentences um
that would be amazing also for us to see
where your brains went after this
presentation
yeah you up for that
cool microphone is
coming um cool Hello um so bit of
context I'm one of the founders of reial
and we have a network of like local node
communities that are implementing
regenerative Finance Solutions um maybe
that's even just hosting events but also
supporting ecological actions and things
like that uh we have about 30 to 40 of
these nodes across the globe and we need
to start to identify ways we can
aggregate impact data um which is
obviously quite a challenging task
across a decentralized network of local
nodes uh and so we're looking at hypers
certs as one of The Primitives uh that
could build on top of uh we're also
looking at EAS and this other thing
called the common impact data standard
which might be the underlying ontology
we use uh to categorize the different
forms of data and then maybe a hypers
CER gets minted on top for specific
claims and sharing of um attribution of
ownership of those uh impact claims um
so that's for reaal and then I'm also
one of the co-leads of C public goods
where we run various Grant programs uh
and so we may also look at how hypers
certs could could feed into those Grant
programs as well yeah okay just to
summarize it's uh one is cell public
goods program and the other is Reid da
and their impact
Network the refi da and Salo yes okay
yeah cool
thanks
yeah uh hello again um so our work is uh
where working with u fishing communities
uh around the world and we are
collecting plastic from the sea and we
turn into new products so we have now
around 5,000 fishermen mainly in the
Mediterranean Sea probably one of the
largest plastic cleanup projects in uh
in Europe um we're currently working we
are part of the next billion team of
ethereum so we are working with them uh
we are using a closed loop blockchain
system now and we are making open source
on optimism so I would like to see how
happens could help us also build on top
of that and potentially you know uh help
us scale up the impact
further yeah is it ala I think okay cool
thank
you maybe I want to turn people into
like a hypers Sher and then have people
buy the people and then they earn a
percentage of their income or something
like that so you want to rebuild
Society no okay no okay thanks
is one I mean to comment on on this uh
briefly there is something where when we
think about how we fund projects we can
also think about how do we fund somebody
where we think they will do amazing work
no matter what they project they what
the project is that they are actually
working on right now and in science um
we have like in medical research we have
block funding block funding from hhmi um
they give like researchers that they
believe in just like I think like 7even
million for five years and say like do
whatever you do um you have been you
have proven to be good um you have you
are intrinsically motivated and we trust
you that you do something great with
this and um this trust-based funding is
something that we also need to balance
with like all the impact measurement
that we want to do um because there's
like something very interesting in the
dynamic of like when you actually trust
somebody somebody but then you also
measure the impact to see where that
went so I mean it was like stated uh
kind of loosely but I think there's like
a really interesting trust-based funding
mechanisms based on how we trust people
to do amazing
work than hello I'm Julian I am part of
the small Collective we called it the
web three hackers Collective um we are
mainly focusing on uh Integrations
mentoring and education and we have
developed a um a dow frame work that we
call gov and we basically want to put it
put it in the hands of like regular
users and um and so I guess maybe the
members of these Dows will be the the
evaluators something like that so
yeah okay thanks um wait maybe to
explain a little bit more so you you
have a DA you have the members of Da
yeah so so we developed this this da da
framework so we used the governor
contract in combination with with nfts
and then we just basically use it for
our Sal we only four people in this Dow
so it's a very small Dow but um moves
fast and then we so we want to help
organizations groups of people uh to
deploy their own uh Dow using that
framework that we built that's called
gov yeah and then the onboarding so the
the work that your D will be doing is
actually onboarding of other people into
their into similar DS following your
pattern yes and I thought it would would
bring uh a lot of value to to to smartly
use
hypers uh so um yeah yeah and I think
like something interesting to observe is
that these tools are actually now really
interesting to use or useful where we
have for example many local communities
we have many fishermen um and Fisher
women do you say that like this fish yes
to and then you have like down members
and like we actually want to leverage
the information at the edges and use
that to organize funding streams right
and like this is like something where
Hypes particularly is a useful tool to
do that so like I love all the the
examples of of ideas uh that are in the
audience do we have another
one no okay cool we have four great
ideas thanks do you do you have any
preference I like all of them
yeah
um let's see so what I what I know is
I I mean maybe you go with the uh with
the plastic recycling uh Fisheries uh so
I think because like it's it's nice
because it's so tangible and then we can
we can easily understand it we can
easily understand why this is impactful
where this is
good and then um we can basically also
if if you understand that and then you
can like transport that to to the Dow to
um open source software um so I I I like
that idea as as a very concrete example
yes um what I think would help in this
case is that the people that want to uh
collaborate in this because I don't I
cannot draw as you know right and what
really helps some about this life cycle
is that we actually draw so I like to
whiteboard but we
have this bigger whiteboard oh white yes
but then I also need you to come a
little bit closer yeah well can we can
we bring a whiteboard to this table you
you can do what you want there are many
whiteboards actually on camera we should
put okay with a mic yeah
so just ga ga around
here and also like Devan was also like a
fellow at the EF so I think uh would be
nice to like continue this this
tradition of like having strong hyperset
projects in the in the fellowship so
let's let's see what can make
happen it's a video don't
worry so what I what I like this does
this help yeah okay uh generally what i'
like to do is exercise it just uh start
with like a conversation about hey what
do you do and then we just map out like
what are the players and then we'll look
at our data set and go like okay so this
is I think how they are connected in in
the system and this is how we would set
up your uh data set so what I remember
is you do plastic soup in the
Mediterranean can we talk a little bit
about how this uh how the soup flows
yeah how the project flows yes so the
project is like um actually very simple
so the fisherman they collect plastic by
accident in their
Nets they used to throw it back to the
Sea so we started training them to bring
it back to the land so the first the
first step is they bring the plastic
back to the
land okay and then it's on land H then
we connect it with recycling companies
so we we find containers and we we hire
people from the local communities to put
the plastic there and do some basic
sorting do you just give it to the
recycling companies yes because it it
depends on the country like the plastic
collected from the sea uh is very
degraded like sometimes 30 40 years in
the sea um so it has algae muscles
oysters this kind of stuff so they
really need to wash it before that um
and then the next step is uh these guys
they make pellets a percentage of that
mhm um 50% for Simplicity something like
that like these little things that you
press into something yeah yeah yeah and
then uh we find companies that can
actually uh make it the final product so
up cyclers so they make like Furniture
kayaks this kind of stuff
upcycle into
products
products okay so you collect a plastic
it's brought to land you donate to
recycle companies they create these
plastic pallets that they then sell uh
and this is something that we are
working on some pellets they sell some
others uh uh we sell to the
upcyclers sell and resell and then maybe
I'm assuming here but then the funds
from the
sale go back yeah percentage goes back
there and I'm saying actually all of
this goes back there but it's not enough
to finance the operations um so the main
Revenue stream that we are having
currently is B2B so maybe that's
something that's going to be of help in
the project and the unique value that we
are able to provide is that we are able
to create like large scale cleanups at a
very low cost actually the lowest cost
currently in Europe and the
Mediterranean to remove plastic from the
sea yeah
USB low cost low cost cleanup right
yeah uh and uh we provide also third
party
certification So currently we use like
um audits from companies like Deo and
stuff uh and we have like this
blockchain close Circle and we want to
now open it up on
optimism okay so and these audits are
done by external parties yeah yeah they
audit that you actually do what you're
yeah yeah or some of our partners they
have their own Auditors and they they
bring them as well so we're fine with
that okay and after that so you do the
Audits and then what was the last part
of the sentence sorry um is that we are
currently transitioning also to optimism
to have open source data all the time as
an additional part of our certification
process so you're rolling out to op um
yeah is is this full life cycle going on
a p or which uh more or less something
that maybe we can do additionally is a
little step before collecting plastic is
uh because um a big part of our Revenue
we give it back to the fishing
communities that collect this kind of
plastic MH um So currently we pay them
in a strong currencies like in euros and
dollars MH um but potential that could
be also with stable coins yeah so the
payout and Fiat because we are working
with countries like um like Egypt for
example where their currency is
constantly devaluated so their stable
currency is very much appreciated from
the whole Community
yeah okay okay okay cool um so we know
the life cycle we uh know that you also
offer this as a lowcost cleanup um
you've been audited so you have
evaluations you are working with OP so
you're doing unchanged stuff already at
least let's call stuff um and you you do
payments in Fiat yeah right so we know
the work that you're doing we know the
evaluation flow and we know that you
have a funding flow yeah
right so so one one thing I think there
are like multiple actions here so and uh
the question is like do we want to focus
on one of the actions so for example
creating hypers certs first for the
people who actually collect the plastic
or do we want to create hypers certs
along the full chain um to have like the
full picture of who actually contributes
to the ultimate impact um and I probably
it's like a staging problem or a
question because like in in the end it
would be great to have it have all of
that um but maybe in the beginning um
you can just like um people collect
plastic from the Mediterranean and that
is kind of the a very concrete action
that is also comparable with each other
so that that could be the start um but
curious about what you think yeah sure
that could be the start like that would
be the easier way to to to start
something uh and the main kpi for
example that we use with our
Partnerships is how many kilos or pounds
of plastic we collected from the sea so
that's our basic API but a very
important additional aspect we put in
our project and is
actually may currently our main cost is
the waste management infrastructure we
need to build to recycle that because
it's one thing to collect it from the
sea but if I just drop it in the
landfill or just drop it in the port
it's going to end up there again so we
we are investing in the infrastructure
to make sure that it doesn't go with the
SE again uh but that could be an
additional Point down theine but for us
it's important to connect that stuff
yeah and I mean there's like something
where whatever where you have your
biggest bottleneck and where this is
most impactful maybe we can start with
that or with the most like the easiest
one so it's like it's like two different
choices um to be made um but yeah for
for this Workshop um I think the the the
cleaner one is like the collection for
yeah I think so but it does sound like
um one of the most impactful places
where additional grant funding could be
raised could be to say you minted a
hypers cert for the recycling companies
to almost subsidize their development in
new technologies that can then process
and recycle more Plastics and then
you're really upgrading the system as
opposed to just like you say just um
collecting it but the system's not
getting any better at the actual
recycling that we want to do and that's
where you might be able to then attract
other Grant funders to come in and uh
and you can sell the lovely story here
but then you're actually also bringing
in more funding to upgrade the whole
system system to stop it uh it's quite
regenerative yes and I think there a
really cool story when you have like
those um 5,000 people collecting it when
you make that really visible and then
you say okay what actually happens with
this afterwards so like in that way like
these two things like play with each
other really well so I I agree that ni
live feedback of the more the recycling
companies actually do recycle they then
that that means the hypers and you you
know as a fun then you're directly
funding the recycling company who
actually done the work and then cre in
to do there's a lot less data there too
a lot less data at the recycling company
level versus at the collection level cuz
like there could be hundreds of people
collecting but maybe two recycling
companies yeah we have like eight
recycling C are you ano yeah okay nice
to meet
you yeah maybe um for the sake of time
because I think we did a good
exploration right we we have an
understand I think we have a shared
understanding about your landscape and
what you do um we'll focus on the
plastic
collection over a certain amount of
period of time in a certain part of AJ
andc um and then we need to know what
goes
in and what comes out right so we're
just going to do it on the second
whiteboard
um so for
the hypers cert we have like a
description
rtion
W
what when and in your case it's also
very clearly where which is great cool
uh then we have description then we know
that there are um evaluations
and then we know that you already
have
funders
um since we want to go for like a a
clean
solution what I generally recommend is
to make like if you first Hyer one
retroactive is way easier than proactive
right because it's already difficult to
prove things that they happen imagine if
you want to prove a promise um so it's
often easy to retroactively and then you
can also grow into this I would time box
it so let's say like everything that we
have done but let's say since your start
uh till now or maybe like per quarter
right I'm imagining that you have like a
continuous stream so you would say like
uh when you would say like you have like
Q q1
you document uh where do you have GPS
data we have GPS data currently on the
closer Block Chain app that we are
working on uh it's like 62 ports uh over
four countries so we have all the data
amazing uh what becomes a little a
little bit more complex I think uh a
little bit more um what is mainly the
plastic collected mhm um so in our case
that's like containers so like imagine a
big container you see in the boats and
stuff like that so full of plastic so
yeah plastic contain collected yeah
that's it and the the other one is who
right yeah so this is a fish or
fisherman
Association who can say Fishers in some
places they're organized some others
they are just going
YOLO are you coordinating them yeah so
you govern over no sorry you you
delegate what needs to happen what I'm
sorry so you delegate what needs to
happen you coordinate with these
fishermen and they do actually do the
work yes but uh they feish plastic by
accident so that was like the very
Simplicity of our project they go out
for fish and by accident they collect
plastic which they use to throw back in
the sea so we created all of this
infrastructure to enable them to bring
it back to the land and make sure it is
recycled so that's why we're so cost low
cost uh because it's already happening
and we're just replicating all over
where they are fishing communities can I
can I take a liberty here and say that
you know which fishermen brought you
plastic over the last CU every day yeah
every day you every boat every day yeah
yeah in every so these fishermen are the
contributors to the impact that you
creating yes so the the wo are the
fishermen and the
Creator I honestly I've seen your name
many times I don't know how to spell it
Ela I Know It's All Greek uh it's yeah e
n a yeah L wow
e e i wow that's impressive in
a how do you know how to spell that yeah
yeah in Greek means together with the
fishes together the fishes really yeah
yeah that's that's what it means in
Greek and roll of St nicely so that's
great yeah yeah and they they they enjoy
the work the world it helped build some
trust for them yeah okay so but uh this
means that you are impact creator that
means that uh in our general notion that
you make uh the hypers because you are
facilitating on behalf of this group I'm
taking again a liberty here I'm assuming
that most of your fishermen don't want
to deal with web 3 don't want don't want
to deal with web 3 they probably just
want this cycle to work and for them to
keep doing this right so that means that
you're basically taking responsibility
for the for the work that you creating
representing these fishermen yeah this
is fine um my recommendation is
always find some way that you're not the
only person in control of the funds that
you raise because if there are 50
fishermen and you're the one holding the
wallet I
mean thebat the Bates are easy debates
are easy to imagine we have uh M with
each and every one of them uh that says
how we are going to pay them and when
based on our funding and we have also
Financial audits uh from you know uh
independent Tax Consultants to check
that that's so that's amazing I think in
pars you want some things you can put in
your description and maybe uh where I
would leave the audit I wouldn't
personally know right now because audit
can be either uh an EV it can be an
evaluation an evaluation right because
it's not what you bring to the market
this is actually verifies that what
you're claiming here yeah right yeah so
this is the
audit and then you have the description
that says okay these are these are the
promises the promises that we've made
with the fisherman can they be
public yeah we can attach the
contract okay so the so this is
additional data right so this is
external uh or maybe even certain
properties that let's leave that a
little bit in the little bit in the
middle but this is like your
agreements and then this is
validation so now you you're going to me
a hypers CER that says this is what we
did in q1 this is the agreement have
made with the fishermen these are all
the fishermen these this is how we will
pay them this is how we will compensate
them this is the work that they've done
and um after you've created that hypers
cert you can actually you can self
attach this audit right I assume the
audit is signed verified or there some
PDF that's signed so it doesn't really
matter who presents it it can be you uh
yeah question for you is is it
interesting for you to change the way
you pay the
Fisher well that depends on the country
for example so in Greece that they are
not organized um we pay them one by one
uh through bank transfers so it's a lot
of complication there but it's working
uh in Spain and Italy they are organized
in groups we just uh pay the group uh or
a representative a big representative
that has like 10 groups or something
like that um and in Egypt is the same in
Egypt they didn't have a group so we
made them a group and we pay the
representative of the group and then
they they they transfer the funds do do
you think it would be like you know
would it make your transaction easier um
would it be an unlock for like doing
more if um the hypers would basically
track okay who did deliver the the
plastic and now we sold it and
automatically the flows flow then
because I mean that that is what we can
do and that that could make your
business operations easier um and I mean
the setup probably would be more complex
once but then it just like flows
automatically well if it doesn't take
more time because the challenge we have
is like uh because we're working B2B
these guys pay like every semester or
every year uh and the fishermen want to
get paid uh you know at least monthly
you know I mean they should get
like here
ideally um what we could do is they
deliver the the plastic and then if if
that is recorded that recording of that
plastic would just like automatically
release the funds to the fishermen and
the if the experience of the fisherman
is I gave plastic there and then I just
like checked in with like a simple
simple tool and I see the funds coming
into like my bank account and like yes
it's on crypto rail but it came to my
bank account um I think that is like a
great experience where they are just
like telling their friends and they join
in I I think that would be worth
investigating then the challenge we'll
have is and that's why we have some
fisherman that asks us to pay them
annually is that sometimes this is a
side activity right they go for fish so
maybe they say they get like depending
on where they fish from1 to I don't know
$200 a month so it's a nice additional
but it's not like the main thing so
sometimes they tell us to pay them once
a year so they see more money in the
bank account and they take it more
seriously they see like $2,000 there or
something so if they get like 50 cents a
day maybe maybe will have the counter
effect or something like that so this is
what I'm I'm thinking of we will check
in with some Behavior economists to give
us some point that's that's my
background actually
wonderful and potential earnings it's
hard it's hard because this is what I'm
trying to explain to them like some
people like they are just bored into
getting like the donations and stuff
every month and they're like yeah either
never or once a year uh but the majority
vast majority they get monthly they they
prefer it monthly because this is when
they get paid also with the fees and
everything J to the funders yeah it does
sound you have that this conversation
about two different layers right because
if if you if you are the creator of this
impact then you are going into the
market and saying this is everything
that we've done and um please fund right
and if you have a work stream where
you're basically taking in this plastic
and doing like a payment that's a that's
part of the work that you have done over
this period um that doesn't mean that
like this this part why what hul
proposed cannot be automated I think
it's really cool if we if we it really
cool if this can flow into this and then
you get an audit on this as well and
that would be amazing but let's keep it
simple let's start with simple thing um
so you have funders yeah right how how
is this Loop closed currently right how
is the how are the how does this
happen um so let's say the funders what
they do um let's say we work with
companies like I don't know like alian
let's say that's one of our Global
Partners uh they want to finance like
the removal of 100 tons of plastic from
the sea and to make sure that this
plastic gets
recycled so the main kpi is that and
also they have another kpi which is to
involve like I don't know a thousand
fishermen into that project so these are
the two main kpis and then they have the
option that they can buy some of the
products as well do they do this be do
they fund before beforehand or after
your ship uh deliver uh they finance uh
as per uh round so they put some money
up front so can start the project up
front and then when we provide an
interim report they provide another
round of funding and then when we finish
the project and we give the last report
they provide the last round of part so
usually our partners pay three times a
year that's actually really cool for
this case because except and it's cool
that you do this of course but it's also
really cool for this case because you
actually have prospective funding and
retroactive funding on the same
workstream yeah yeah in a way yeah yeah
so that would mean that if you um
remember that the hyp source has a
certain Supply right it has a supply of
let's say 100 million or no let's say
that's what we that's what we prefer um
you could even work with Alliance and
say like you buy the first half up front
and you buy the second half afterwards
um yeah and you already have them right
and what what is the benefit for this
for aliance is a few things right
um I know you already have this audit
Trail so it's not like they'll get like
more secure but they are this is like
very transparent and instant and
actually what they are doing is also
building up a reputation for all the
work that they've done because I um can
imagine that for them it's also really
beneficial if they can show the work
that they funded and actually also
showing that it's actually been
validated as well yeah yeah yeah and um
question additional to that is like
one one way that we are thinking about
like why people actually want to do this
and like also why some funders want to
do that is that if you create it as such
a transparent system it's also easy for
others to join in so if you're a funer
and you are you care about a project you
care about the impact and you fund it
and you fund it transparently um you
also signal to other funders like this
is important and also I believe that
this works so other funders could easily
join in and then different funders could
even like like fund the same um the same
impact because this is like why hyps are
fractionalized so that like two
different funders can fund like each 50%
of the same same impact um and then we
could potentially grow the the funders
landscape into like a a diverse set and
like all of that is then like very
transparent of like who funded what
aspect and no fun and it's it's you're
like you're not telling the same story
to everyone because everyone actually
has a unique piece of the whole impact
and knows how much exactly and this is
what we do now we have around 30 of
these kind of companies uh so each one
is financing a specific BN of impact and
the way we verify it is through the
audits
currently uh to make sure that you know
we give specific parts and in some area
some ports let's say like some
communities they like to jump in with
another partner so they make a matching
fun uh but um we do that already but
through this kind of footage cool it
would be great to have it on
chain yeah oh sorry I keep forgetting
this uh hand okay so we we know would
want to R where we know how you're going
to get it evaluated we know you're going
to um how you going to fund this Do You
Feel Like Anything Is Missing here from
your life
cycle uh on the plastic collected uh we
have like a feedback mechanism to make
sure that we know that on the spot and
don't wait the audit and this is weight
slips so I told you like we put it in
these big containers M so when the
container is full and they pick it up we
we wait it on a certified facilties so
we know that this container was like 10
tons or something so we know that that
month was like 10
tons um and to have a daily metric for
the fishermen uh we use certified
digital scales on the port to make sure
that we know what every day they bring
in so we double check then these metrics
do funders either now in the future will
care about other things because you said
they care about plastic collected and
Fisher involved but might they also care
about the location for example like that
a Greek company wants to fund stuff in
Greece and um are there other examples
like that because let's suppose you
actually scale around the globe and then
a funer actually like really cares about
the location is like you're nodding
already but like is is there also others
things like that where you actually want
to enable funders to be more specific
about what they are funding yeah um so
funders they they have usually preferred
the geography so that can be a country
can be like a
community sometimes they finance like
areas where they have strong financial
uh activities or something so we have
this coffee company in Greece that they
sell this kind of coffee in this area so
they wanted to work there uh but we also
and and that creat like a had created
challenges for us to scale up because
for example in the Mediterranean and
globally like the main p is in Egypt
because of the Nile so the Nile is
responsible for half of the plastic in
the Mediterranean Sea and 15% of the
whole plastic in the world uh in the
world ocean yeah it's it's it's huge um
but nobody wanted to work there uh
because there's not so much going on uh
so we were able to identify some compan
that they don't care about the location
and they just care about the impact so
let's say I don't know I want you to
remove 100 tons of plastic or 200 tons
of plastic and I don't care from you do
that uh and usually these guys what they
do is they they sell a product made
without plastic or maybe not like a
table or something and they say for each
table we sell we remove like 10 kilos
extra uh so this how we're able to
expand in other
geographies yeah um okay I don't think
it's relevant now it's for this exercise
but just geography yeah it's
unfortunately important yeah so started
with a simple oh we we uh get plastic
suit but like many layers uh to your
organization I want to be cautious of
time because we have seven more minutes
um and we didn't get around to doing
anything with uh code or an app or
minting or those kind of things and I
think that's fine because I think this
was a very good conversation and this
was like it's really great to see what
you're done with the project um what I
want to get to maybe is H quickly show
you the um if you want to I can quickly
show you the template application the
repository and where to get started and
um and then we can always follow up on
these conversations uh afterwards is
that fine if anybody anybody wants to
perfect great uh if I may put one more
in point like currently the model we
have is B2B and the reason we you know
transitioning out to the L2 is because
we want to open it up to a b2c world
because big companies can pay you know
audits or investigate jist but we want
to feel like every individual can
contribute either as a financer or as a
collector uh and that's something that
we could also match fans with so I don't
know if if you know this guy like Mr
Beast like uh last year he created like
this huge challenge for the C so they
gave away like $30 million something
like that and they they spread it all
over the seven C and everything so they
gave us budget for the Mediterranean so
we're their partners for the
Mediterranean based on exactly that
protocol that you mentioned over there
and we also had other B2B partners that
were able to match that and the impact
there was huge you know like because
we're able to go to Egypt and start the
project there that is the main problem
Point um so as as a point that that's
just going to yeah say
that thanks thanks for the example um so
I think it's like these are the the
things that are possible then with um
putting the hypet framework underneath
all the cool stuff that you are doing
already and hopefully like then adding
kind of the value to how easy it is for
others to join how easy it is for your
your transaction your business uh
operations and then also encourage like
others to do similar things and like
scale it up into like like adjacent
impact and um New Impact areas so I
think that's that's really the the
potential here yeah cool right let's
let's see some code if I sell the
internet I've been having wir
issues oh microphone sorry I've to than
you so
much yeah thanks mon see you later
happy belated
birthday One S okay um I thought we G to
sing a birthday song No Okay um so this
is the template application it's
basically what we did because we're open
source is we uh forked voice deack that
built on top of our stack and then we
took everything from voice act out again
and then we made it like very
generalized a little bit wide lably so
this is a this is a fork build this this
is a fork of a fork built on our stack
on a fork somewhere um it's really
simple and it's completely uh it gives a
different experience and what our app
does our app shows you the collections
minting evaluations voting these kind of
things the goal for this repository is
to keep it light and you add what you
need and I'll show you like one very
specific thing on why that is valuable
is
um we have hyperboard and Hyper boards
are collection and sometimes it doesn't
work on Local Host nah uh okay never
mind we have hyper boards which are
spons boards they are collections of
hypers certs and because you define a
collection of hypers certs that means
that we can basically Define the context
that you want the whole app to have
right because it doesn't see anything
else except for your collection which H
live
demo in this case are these two of my
hypers certs one of these hypers certs
that I uh created I was playing around
with geojson like we told you before
which means that these specific hypers
certs that are part of my specific
collection have GPS
data right and this shows you um like I
showed during presentation right there's
a geojson there's a polygon and you can
run through this over time the goal that
we do with this repository is
that we a very simple mint
form and it's rendering that's a very
simple mint form and um every segment is
basically a compon component so it makes
it really easy to add a component with
the data that you need we it's basically
using Z schema so you can add your
custom properties and we will validate
the data that you're putting in there
and that's all we know about your hypers
Sears right so you have your metadata
with your properties now when we when
this app detects your metadata with your
properties it says oh there's a geojson
and this is why I render this little
card but you can do this with gejon you
could do this with forecaster data you
could do this with um open source
reserver data you name it right and
would be really cool for us is to see
some examples of what you need or get a
request about what you need for your use
case and we can help you Manifest this
right because this temp repository is
the start for us as a as a more
generalized platform and your F feedback
is very valuable here so lastly what we
sear template is this
repository and I want to invite you all
to uh basically install it or since it's
a template or whatever you can make a
fork install it run it and start playing
around with it um it has all the things
that you need so you can create the
custom in data it can read it has a
specific Handler that's an example for a
component and if you really want to dive
into this um the component are there for
using the marketplace right but if you
want to play around with using the
marketplace please do this on
testet um that's all I have to share
right now being cautious of the time I
want to thank everybody who was here I
want to thank you for the good
conversation about um Ela Ela oh God
that I got
Ela yeah uh next time next time I'll
have it
yeah would I would like to jump in on
the on the template for a second because
why we think this is important and cool
and like enables more use cases is um if
you think for example for gain Forest to
is an evaluator for multiple projects if
they just want to have one place where
all of the hypers certs are shown and
people they can direct potential funders
to the hypers that they evaluated and
have a custom experience for that they
can easily spin that that up if you have
uh multiple pop-up cities and you want
to create just one platform where all
the pop-up cities can raise funds
retroactively for their awesome
experiences that they created this is
like a really easy way to do that and at
the same time all the hyperset that are
created here are actually also at the
same time on hypers sets.
org as well so
that's like really the widget of you
actually cannot only have that on this
dedicated platform but you also can have
um the hypers then in a widget on your
own website where you from your popup
City you raise funds on your platform
there's one platform for all popup City
stuff and then there's like yes also the
general um hypers marketplace where you
can find impact from open source
software to ecological things to popup
cities um but you we might want to start
in specific um domains with a
customizable template to do that um so
that's that are kind of the the
different ways why we have built this
and then
um if you want to go more customizable
then you have like the SDK um that you
can like use to integrate it into your
existing platforms or to build
completely a new funding platform um
that is kind of it it is automatically
interoperable with all the other hypers
stuff that happens and that is like the
exciting thing um that what we can do
with web3 technology now that we
couldn't do before is really thinking
about this distributed database where no
platform actually has like really
platform power um because like it's just
an interface to the data that is
underlying it and then anybody can build
a tool like hyperboard on top of that
that does cool cool stuff so on the on
the hyperset stack um there's also like
other evaluator tools that we didn't
build um that can be compatible with
this so it's like it's really like a
flexible text stack um that should be
customizable to whatever your needs are
or just use what what we built already
if you want to have any easy
start final words from my side yeah no
great thank you uh thanks
t
you
B
