so so oh there we go all right so we'll
kick this off
um everything seems to be going all
right all right so um show of hands here
how many people were at friends day
yesterday oh my God amazing amazing I
love it I got to tell you I just want to
give a shout out to ens all my peoples I
mean we had an amazing amazing event
yesterday we had vitalic there we
announced name chain our L2 we had Jesse
from I mean it was just such a great
great U opportunity for all of us to
about things that are kind of scary
about these Web Two based attacks on our
web 3 ecosystem this is also about
bringing us together and and very much
highlights some of the cool things that
we are doing within ens that's behind
the scenes and is protective of our
entire ecosystem and things that we're
also building upon so um since I'm new
to this ecosystem here a tiny little bit
about me this talk will make a lot more
sense if you understand that I was a
hacker before I was a lawyer so
according to my mother that means I went
from bad to worse okay um but I've also
done both sides of the fence I've been a
lawyer and I've also been a siso before
I joined ens I was the ciso of the NFL
in the United States the National
Football League and and I've you I've
done a couple of things in defense and
intelligence so that's where the the
background is here and I want to call up
to the stage one of my colleagues Malika
Gaza to talk about
herself uh hi everyone I'm Malika I'm a
legal research associate at um ens so
I'm a lawyer I'm not a hacker but I've
never i' I've never been a hacker always
been a lawyer I uh hold a legal um
master degree in intellectual property
and information law and I also uh
participated in the world intellectual
organization academy uh where I've deep
in my knowledge in blockchain excellent
fantastic and we'll hear from Malik a
little bit later on uh in the present as
well so let's jump into this and let's
talk about this from the from the start
we're going to talk about the DNS you
know it's one letter away from ens
except it's a hell of a lot more
dangerous right so the DNS has been
around the domain name system has been
around for a really long time and
there's just Decades of abuse and um and
and and it's very difficult to mitigate
that kind of abuse right people have
gotten really good at it right so one of
the things that we did within enss and
this goes back to my hacker Roots is
that um many years ago I created a
dns-based threat in system that looks
for early stage indicators of attacks on
companies originating in the domain name
system so we we refocus some of that
work but using regular expressions and
pattern recognition to find a tax on
users of ens and what we found was that
these bad guys really abounded within
the DNS so you see domains like at the
bottom airdrop d.
domains these are
things that were cropping up on a daily
basis um we found that these attacks
would launch usually from some kind of
of compromised account on Twitter they
were propelled by some kind of
compromised account link tree was was
very often used to to guide people over
and ultimately what would happen was
that somebody would fall for some kind
of fake airdrop or a claim um or to
renew a domain and it would connect them
with a malicious smart contract on the
blockchain usually some kind of wallet
drainer the other thing that was
interesting was these attacks were stood
up really really quickly this is what
the attacks generally look like
and it was one after another after
another they were really persistent the
volume and velocity of the attacks that
we were finding in the domain name
system were was really astounding so
this we realized pretty quickly was was
an issue for the entire web3 ecosystem
as well because it's an onboarding issue
if we're going to onboard the next 100
million or next billion users into web 3
and defi we need to make the space a lot
more secure and you can see here a lot
of intelligence and data within the DNS
about these attacks
we found one consistent thread and this
has to do with the who is so what we
were able to do was take that data about
Lolita LLC and pivot on it within the
domain name system and find over
not just enss but the wider web 3 and
Def defi ecosystem and these are actual
domains that belong to this persistent
thread actor here I mean it's kind of
massive what we've been able to find and
these are all domains that were
registered from and create a list of
every domain that was configured to look
uh with name server records pointing to
cloudflare and then if I found new NS
records that were pointing to cloudflare
that indicated that an attack was about
to be stood up against that company at
that point you can then usually scarf
down all of the data that's in an open
on that particular web server gain
actionable intelligence about what's
about to happen maybe even some kind of
ttps and indicators about this
particular threat actor but so looking
at the NS records here was an actual um
a great early warning system for us now
here's using using that particular uh
detection system these These are actual
attacks on the web 3 and defi ecosystem
that we found and took screenshots of
over the last several months so you can
see they all look very very similar to
the attack on ens as well um but the the
thing was amazing about this was that
there stood up so quickly sometimes the
domain would be registered and within
hours you see a live attack uh being
stood up and and and propelled so what
do we do about all this what do we do
about it I want to call up mikica for a
second and talk about some of the things
that we're doing at ens on a daily
basis so what do we actually do we um
elaborated a few um strategies so first
first of all we do takedowns so as soon
as we spot any malicious activity any um
malicious actor we report fraudulent uh
websites to hosting providers like Cloud
flare and uh to domain regist uh next we
also do Blacklist so we actually uh add
all of these uh fraudulent websites to
uh Blacklist and we block the access and
um limit the spread of uh
fishing uh we we also submit uh regular
reports to um antivirus providers to
security uh teams and platforms like an
ficient um working group and uh for
long-term uh control we also put uh
forward the uh UD uh udrp udrp is a
uniform domain named disput um uh
resolution policy so it's uh essentially
a formal complaint that we uh file and
um so this complaint L us uh transfer
the uh domain names back to in in's
ownership thank you appreciate that Lea
and and the udrp is here this is this is
a a screenshot of one of the udps that
we filed on behalf of ens where we took
out a whole bunch of these bad guy
domains um but that takes weeks it's not
fast enough to do that right so here's
where I want to end this is my modest
proposal for the ecosystem and for the
community here and and and really I
think showcases some of the cool stuff
that we're we're doing behind the scenes
at ens we we want to share this
intelligence with all of you we want to
put the 2,200 plus domains into all of
your hands so that you can begin to
block and tackle these types of domains
we want to pull our resources together
we also think there is a way that we can
reclaim all of these domains so here's
where we go on the offense the udrp
system that Malika just uh identified
and talked about right it takes a little
while it takes a couple of weeks for
this to happen but there are very few
cases where there have been multiple
plaintiffs or multiple complaint plance
going after a large number of domains at
ens we've reclaimed a whole bunch of
domains through udps but not together as
an ecosystem there is an opportunity now
especially with the world intellectual
property organization to change some of
the laws about multiple complaintants
filing these because we have common
grievances because we have a clear
registration pattern from this thread
actor that is going after digital assets
of our users and we have the same exact
rights at issues we can come together
and file one one complaint that may be
able to take out all 2200 of these
particular domains and if we do that
there's going to be a tremendous Network
effect it will send a a shot across the
bow to this particular threat actor
which is very a very sophisticated and
advanced persistent threat and what
it'll also allow us to do is maybe
something akin to what the FBI does when
they take down botn Nets put a banner up
so that anybody who goes to that
particular site knows that it was
reclaimed and it was reclaimed by us as
an organization or within our ecosystem
that sends a clear warning there but
more importantly we'll get the
registrant information from about how
they registered this particular name all
of the information that they used and
then we'll be in possession of those
domains and we can actually host them
ourselves once we have those domains we
can look at the web server logs and a
lot of you that you know go back to the
these server environment variables one
in particular httpcore refer which shows
you how somebody got to a particular
domain what links they clicked that's
intelligence that can be really
actionable to the entire community and
will allow us to push the fight back
further so that we're not reacting when
domains are registered and attacking our
users we can go after their
infrastructure one level before it hit
it hits us so that's basically uh what I
wanted to show you uh we really thank
you for listening here we're opening up
the floor to questions if we have any
more time we might have gone over but
please do be in touch with Malika and me
if you would like to share this
information come together and take out
these bad guys thank you for
[Applause]
listening thank you very much Alexander
let's hear one more time for him ladies
and gentlemen thank you we um we'll give
you one or two questions I think just
one or two questions if you don't mind
you can scan the QR code now we're not
going to be taking questions from the
floor but we will be taking questions on
our online system so if I could invite
you to just scan that QR code you can
ask a the question we've only got a
short amount of time for question I can
just take maybe one or two short quick
questions don't mind you can just send
your questions there scan the QR code
it's going to open your Devcon passport
app scroll to the bottom of the app and
look for the Q&amp;A column right Q Q&amp;A
button it's on the bottom right hand
corner and you'll click the button and
it will allow you to ask a question for
this session okay I'll just wait for
about 30 seconds to a minute you have
time to submit your questions click join
Q&amp;A and
submit I know some of you are excited to
ask in person but because there's so
many we have to do it online it's a
little bit
easier all right I'll wait another 10
seconds it's not loading oh you can try
and switch between Wi-Fi and mobile data
if you have is it loading for everybody
else I've got it have you sent it no you
want just shout it anyone else anyone
else no worries we can always come back
to the system yeah
no we got one guy with a question let's
just do one verbal question maybe this
gentleman with the gray sweatshirt yeah
you can pass him the mic we'll just do
one question live thank you yeah really
nice talk so my question is whether you
have observed similar like a malicious
domains that are like created on ens and
also for example because like uh right
now we have more data publish on ipfs
and using e.
link such as gateway to
access data so it's any kind of like
such a te or better practice for
gateways to also address this type of
issues yeah um we haven't observed this
type of activity you know within eth
right in in ens domains we have not
really seen that you know this is more
of a web two based attack surface um
that's targeting our users and I think
that's because you know that's the real
vulnerability right is that the the
facility with which a thread actor can
register a web two permutation of a
company name in a different top level
domain and then stand something up is is
much easier and thread actors are so
used to operating in the web 2 space the
web 3 space is new to them they don't
necessarily understand how to do that
but we have seen you know some bad stuff
happening you know on top of like on
subdomains on e.
link and e.
limo that
we to which we have to respond sometimes
pretty quickly um but that's much much
uh rarer than the things that we've seen
in the web two space the volume and the
velocity of these attacks and web 2 is
continuing to increase and that should
really concern all of
us all right thank you thank you very
much for the question thank you for the
answer let's give our speaker one more
big big round of applause really
appreciate it Alex thank you so much all
right fantastic welcome you back to your
seat Now ladies and gentlemen I forgot
to introduce myself my name is Ross I'm
going to be your MC just for a short
while we've got a bunch of MC's rotating
around the different stages thank you so
much again for attending look around the
room the room is full wow amazing so
we're going to get ready for our next
session we're going to have some
lightning sessions some great talks as
well um if you look at your Devcon
passport the next session is about
Merkel proofs yeah about Merkel proofs
so if you're interested to know more
please feel free to stay in the
classroom or if you want to check out
the other sessions there are as well I
give you about 10 seconds if you need to
move no worries those of you at the back
if you want to come in front there are
some places in the front here feel free
to come and take a seat in the front
yeah fantastic all right our next
speaker is already here and already
ready so ladies and gentlemen I want you
to get ready and learn a little bit more
about Merkel proofs our next speaker is
shufan Wang ladies and Gentlemen let's
give our speaker a big round of applause
as we welcome him to the stage Shuan
take it
away thank you very
[Music]
much hey guys I'm Shuan a security
engineer from CH security I'm very happy
to hear to share my insights about mer
proofs today especially I'm going to
talk about when lives will leave you
vulnerable so I believe in your life you
have seen many trees with different
shapes different structures for example
it's a very simple tree it could be
bigger and more complex and in addition
this is grow like it's not doesn't look
like a tree it could also be ear tree in
the game's Elden ring and for merco tree
it's very similar it could be a very
balanced and simple merco tree where
data is at the bottom and it's balanced
it could also be very imbalanced in this
case and be sure to distinguish merkus
tree from Mer tree tree it's very
different and in addition we all know
the merco Patricia tree which is a very
important data structure in the eum
global storage so with all these trees
there are very different mer algorithms
however I believe you can find all the
important checklist that you should use
to ensure a security proof in your uh
protocols but even though we have this
check list we cannot ensure that we can
find all the vulnerabilities in very
different merro algorithms and that is
when you when the lives can leave your
protocol vulnerable the answer is very
clear the V the answer is about the
beginning if you don't recognize a node
as a leaf you will never ensure the
property from the checklist against it
and make it secure so today I'm just
going to share you one example of this
kind of attack that is about mer man
range I'm not sure if you have all heard
about this algorithm so let me first
introduce what is merco monor range it
is a very simple data structure uh it's
just like a group of sub mer trees you
just add the data at the bottom of this
meron range and once you keep adding new
data if there are two siblings we add a
parent if there are two parents we we
add another parent you do this
recursively and eventually you will get
uh several merco trees in this merco
mountain range with different depths and
different size and we call the top node
of this subrice pics and why do we use
meron range as I tell you uh if you are
adding a new node here it's very easy to
build the tree and you don't need to
recompute the all note in this tree you
just append
only and uh now we have this uh sub
trees if we only want to store a
constant size of commitment on the
blockchain what we do is we compute a
rout the root will be a nested hash of
all the sub tree PS and this process we
call it a bagging process so once you
have the root you can do a normal
existence proof of any data within this
mer mon range how do you do that that's
also very simple we first do a proof of
any of the leaf within the sub tree and
once we have that proof we can also add
more pigs within this proof so we can
reconstruct the root at the
top and just take a minute think about
what can go wrong in this algorithm if
you want to prove any data withing any
of the leaves so we must have some
assumptions so let's assume the people
who is adding data to this merro monange
is trusted so he won't add any malicious
State he won't add a sub tree into this
leaves in addition let's assume you have
sufficient validation of the index and
the depth of the leaves when you do the
proof so that you can easily use another
intermate node as a leave here like for
example the P1 and D1 they are very
different node right the P1 has deps one
but D1 has deps two so you can't use the
intermediate node in this proof even
with this constraints can you break this
system the answer is yes if we just take
one step back and look at this meron
range again we'll find there's actually
a hidden tree when you build the route
that makes up of this pigs so we have
three paks of the sub trees here and now
we are building another merco tree with
these paks to the rout and we as you can
see we have no validation of the paks in
the previous assumptions and that means
you can easily find a vulnerability here
and here is one example of this attack
so on the left side this is the mer mon
range on the right side I do the attack
by just removing the D5 and D6 leave
node and now as you can see the P4 the
intermediate node becomes the leaf and
more surprisingly this has the same
depth as the node D5 so now if I'm going
to prove P4 in the sub tree of N1 it
will have depth one that satisfies all
the properties we have validated before
but we have never validated the pics so
this is a trick that now you can prove
something nonexisting in your Merk
tree so that's the example I want to
show you today and the summary is very
simple a nonleaf with belief could be a
leaf so please ensure that you check all
the input and validate all the
properties you desire in your protocol
otherwise it could be come vulnerable
easily and thank you very much for
listening if you want to know more about
chain security and our work please scan
the C code and get in touch with us
thank you very much fantastic let's give
Shuan a big round of
applause thank you very much let's try
the QR code one more time we got two
about 2 minutes for question so try and
scan it again I'll ask the team in the
back end to refresh it um and we'll see
whether anybody can if you can let me
know or is it still not loading is my
hair blocking the QR let me move to the
side all I know about trees is that I
look like a tree that has been struck by
lightning um but that's not really
relevant to today so if you have any
questions about trees about Merkle
proofs why don't you try and submit it
on the QR code now do bear with us I
know sometimes you know when you rely on
technology that's when it kind of fails
on you sometimes but it's okay if it
really doesn't work I'll throw the
questions to the audience has anyone
managed to use the QR if you scan the QR
you should be able to open your Devcon
passport validate with your zoo pass
scroll to the bottom and you should see
the Q&amp;A does anyone see
it the validation doesn't work what
happens when you try to validate fre it
freezes okay no worries thank you give
me the feedback so I can tell the team
as well let me give it a try
hey oh there we go it does work well it
works on mine um but that's fine no
worries since it doesn't seem to work on
the screen let me throw it to the
audience audience if you have a question
raise your hand regarding the topic
about Merkel proofs about trees about
leaves and about saving the environment
anyone we got a question on the stage on
the screen rather let me read it out are
there use cases where private keys are
used in this Shuan take it away private
keys using this it's up to the protocol
like how they are going to use this
mirle Tru you can you can use it to
store anything but just ensure that your
logic is correct and there's no way to
abuse something non-existing in your
program that's it fantastic thank you
for the answer thank you for the
question anyone else we got time for
maybe just one quick one one over there
he's raised his hand can we get him a
microphone quickly this is going to be
the last question for the session uh
please introduce your name and your
question thank you hi my name is George
um what's the Practical vulnerability of
this kind of like how would you imagine
this could be exploited in on mainnet or
in a contract something like submit two
sets of proofs for the same like mint or
claim or something like that like one is
going to be one length other is another
same like root being verified yeah thank
you for your question uh I can give you
a very simple example for example we
have a airdrop for the uh users and the
no Leaf note just storees the uh amount
of token you can claim and now if I'm
just uh give appr Pro against a
interation note we'll have a huge amount
which is a hush so basically you claim
like 1 million tokens for free that's it
thank you thank you for the question
ladies and Gentlemen let's give our
speaker another big round of applause
thank you very
much really appreciate your time
regarding the Devcon passport can I
invite all of you perhaps to just
refresh the passport I'll tell I'll
inform the backend team as well to try
and refresh the system I know some of
the questions are getting through but if
you can just refresh your phone refresh
your passport and perhaps that might
help all right ladies and gentlemen I
believe we are moving on to our next
session let me check all right fantastic
now our next topic is about running War
Games to prepare protocol teams for
incident response oh very very
interesting session now our speakers
we've got two speakers we're going to
welcome them to the stage put our hands
together and let's welcome Isaac PKA
just one for today just one ladies and
gentlemen Isaac take it away
ni hello everybody uh very nice to be
here and excited to be talking about war
games with you all I'm Isaac PKA I'm the
co-founder of a company called Shield 3
and I also lead the uh War Games
Initiative for the security Alliance um
I'll give a brief introduction to just
what the security Alliance is and what
the various initiatives are um because I
think it's actually pretty relevant also
after the first talk um about ens and
data sharing and so the top initiative
here is actually called the seal ISAC
which is not me I'm seal Isaac the this
is the information uh security something
something which basically this is like a
uh a uh shared database between many
different companies where they can share
data on uh like dprk threat actors or
fishing data or bad domains um there's
seal war games which is the initiative
that I lead where uh we prepare protocol
teams for incident response through both
tabletop simulations and then live
simulations on forked environments um
seal also operates seal 911 the
emergency hotline if your protocol is
under attack or if you have discovered a
vulnerability in a protocol and need to
get in touch with um a security expert
as fast as possible um The Safe Harbor
uh agreement um which is legal
protection if you're a white hat hacker
and you're acting benevolently in an
urgent situation to uh rescue funds from
a protocol think uh Nomad Bridge hack a
few years ago if you were trying to save
uh money but maybe you were worried
because you thought that you'd be sued
for hacking during uh because you it be
impossible to distinguish the white had
Safe Harbor agreement exists to protect
white hat hackers uh in those situations
and a legal defense Fund in case they
sue you anyway um so today what we'll
talk about primarily is war games so
what are these war games and why do we
do them um I'll have some links to
resources on how you can work with us uh
there's a lot of open source toolkits
and we also run these um as a as like a
public good uh throughout the space um
we'll be talking through some best
practices that I've learned from working
with some of the major protocols in the
ecosystem um and then just briefly show
you you what this new toolkit is that we
released so you can run these yourself
uh if you would like so what are war
games these are cyber secur exercises
for web 3 um I've heard uh traditional
cyber security folks call these
something like a purple team exercise
where we're not exactly red team blue
team but we're basically just trying to
stress test these teams and understand
how they behave under pressure and so we
want to help teams practice for these um
high pressure situations before they
actually happen um we want to be able to
like test both the technical side of
their team and their social resilience
and we're not just trying to help like
cause them to panic but we want them to
practice emergency response um a lot of
the uh a lot of the reason that we
started doing this um was a few years
ago um so the security lines was started
by Sam sun and he was pulled into so
many War rooms where it seemed uh like
in I guess in uh uh from what I've heard
uh teams just completely melting down
and not really being exactly uh prepared
for what would happen so what could we
actually do to help put them in that
situation before that inevitably happens
um so war games Place through three
phases um I do a lot of uh uh
intelligence gathering which really just
means reading every document that the
protocol's ever published understand
their contracts understand how it works
uh we do a tabletop exercise where we
talk through various scenarios with them
um and understand how they would have
detected them what they would do who's
in charge um and how would they have
fixed something and then what I think is
the most fun is we do a live simulation
so we set up a forked environment we run
all of their contracts we run all of
their uis we run all of their monitoring
um and then they actually have to
coordinate in real time to uh uh defend
and respond as if it was a real incident
and we tend to find a lot of things that
they can improve through that process
and it also just helps the team build
trust in each other so that they know
when an incident goes down for real I
can trust my team uh uh to be there so a
big reason why we do this is because
more and more hacks are due to
operational failures not smart contract
bugs that's a really I think good sign
that we're making fewer and fewer dumb
mistakes on the smart contract side
however as all of the stuff that we're
building is becoming such a critical
component of Global Financial
infrastructure the stakes are higher to
actually operationally be strong as well
and so whether that's uh whether that's
things like supply chain attacks or uh
or social engineering uh it's much
harder now than just like not uh
including dumb bugs in your smart
contracts so these are cross functional
exercises we're not just working with a
development team they're of course a
core part of it
but we're also tending to work with
their with work with their Auditors if
they're a big protocol that has a
guardian multisig that's in charge of
pausing the protocol in case of
emergency we of course work with them um
Communications team is actually
essential so that we know like what
would they be communicating out to the
public and when during an incident and
legal so that they can say okay if we
were to take this action perhap to
perhaps to protect the users of our
protocol can we do that should we do
that and what should we be saying the
conversations between Communications
legal and devs should really be things
that are figured out in advance so that
during the incident you're not thinking
like do we tweet out that we're under
attack right now or do we say something
cryptic or what do we say like these are
things that you can just have in a
Playbook so that you don't have to think
about it uh in the moment we've worked
with a number of products uh protocols
uh so far uh but the purpose of this
slide is also just to show you like why
teams are working with us it's because
like teams are growing uh these are
Global teams and like it's really hard
to like prepare for this type of uh this
type of thing um there's many ways to
engage with us if you're a protocol that
wants to work with a security Alliance
and have a drill uh performed with you
you can uh there's a form on the on the
website and there's also open source uh
uh resources for you to be able to run
these yourself so uh this is a quote
that I had a really hard time
attributing uh it the internet said it
was either like a Greek poet or the neev
seals but I think that it really like uh
stands to to show like why we do this
and it's that Under Pressure we don't
rise to the occasion We sync to our
level of training
uh yeah I think that that speaks uh to
why we do this so each one of these
builds is quite different um a lot of
protocols uh a lot of protocols have
like various sorts of like custom
infrastructure and monitoring so every
time we do this we end up having to like
build a lot of things and we've tried to
combine all of those tools and things
that we've learned on how to run these
simulations um into this uh drill
template that you can see here it's on
the security Alliance GitHub repository
but what are the things that we do to
make the environment feel realistic so
we of course have to run a network Fork
we're usually either doing that with
Anvil or with tenderly we have to run a
block Explorer so we're either running
block Scout um or using a virtual test
net um we're running monitoring so it's
essential to mirror the same monitoring
that you would have on Main net so if
you're using a product like hyper native
hexag or Forida you should be we should
be setting all of that same stuff up
against our forked environment we write
Bots to behave like users so if it's a
lending protocol we have a lot of noisy
transactions of users deposit borrowing
lending swapping um doing everything
that would exist on Main net so that the
only TR so it's not like the team only
sees like two transactions and they're
an exploit and then it's too easy we try
to make it a little bit harder um we
have an exploit which uh an exploit bot
which ramps up intensity over time and
then if there's any sort of
miscellaneous things that they need to
pull in we try to provide that um as
well so this takes us usually a couple
weeks to build for each protocol but
we're trying to get faster and faster
each time and part of that is uh uh
thanks to this uh open source template
that we're that we're working
on so what are some of the scenarios
that we've uh that we've worked on so uh
as you've seen we've worked with various
like lending protocols and decentralized
exchanges and l2s and so the things that
we're work that we like try to simulate
are not necessarily uh like bugs as in
like a smart contract bug because we're
not Auditors we're not trying to just
find like a mistake in your code um and
in fact like if we do that's like that's
like not what we're that would not be
the goal we're trying to figure out what
are the things that can happen in if the
protocol works even how you designed it
so what if some sort of external uh
dependency fails what if the way that
you're importing Oracle data is weird or
what if like some token uh some token
contract gets upgraded and starts
behaving differently so what are the
things that are outside of your
protocols control that can uh that can
change what if your upgrade goes poorly
how would you detect that um what if
there's something strange happening with
oracles and also uh one thing that I
think was actually pretty fun is in some
cases we did like a a malicious
governance proposal
CTF with some protocols where we just
like kind of flooded them with a bunch
of governance proposals that looked like
normal funding requests for events or
sponsorships or just uh parameter
updates but some of them also included
like malicious data um like how tornado
got uh hacked or I think a number of
protocols how how they got hacked just
by having like sneaky additional call
data um that uh that ended up having
wide imp uh bad
implications uh I've pulled out a few
best practices of what I've learned from
working with uh working with these teams
that I just want to go over briefly and
so one is just maintaining multiple
communication channels to reach your
teams uh one thing I like to tell teams
is like imagine uh like during a
tabletop like imagine this scenario
happens but now imagine that this
happened and telegram is down on the
same day that this happened can you
actually reach the Guardians do you have
another way to reach them can you reach
them on slack Discord can you page them
uh sometimes we find that like when we
work with a team like a a paging system
that they think is set up is just
deprecated and hasn't been working in a
while and they can't actually reach the
teams that they want to or they reach
the team uh and they don't have their
Ledger with them and so like okay cool
we got in touch with you but you can't
actually sign the pause transaction
because you're camping like these are
things that you want to test um also
risk isolation this is a we learned a
lot I think from the uh from how the
year team um prepares and isolates risk
between the different strategies and so
there's there's a a big lesson in like
minimizing the amount of contain agent
that can spread uh from like one
strategy to another and also the
diligence process before any strategy
was employed there was always an
emergency response of like with this
change these are the things that can go
wrong and these are the steps you would
take to recover funds before they become
uh unrecoverable so like Risk isolation
with urine uh similarly the like Asset
Risk isolation with a we found was very
interesting how you can see how there's
all these different configuration Flags
based on how potentially risky a
different collateral asset is they have
different properties as far as how they
can be uh how they can be used in the
protocol so I think that these are all
really interesting lessons from
different like larger dii protocols
about like how you minimize potential
contagion and and and things from uh
things from
spreading uh finally or additionally um
incident post-mortems are really
important so uh this is another call out
to like the year in GitHub repository
where you can see that every time
there's been something that has happened
you can uh see what they what the team
did how they found out and then also how
they'll be improving in the future to uh
to avoid that sort of
issue and monitoring mirroring
monitoring I think is quite important
like a lot of teams only will run like
their critical monitoring against their
main net smart contracts um and that's
handy but uh the things that are
actually going to trigger to maybe like
pause your smart contract in the event
of emergency maybe it will never happen
or maybe it will happen like once a year
and so how can you really be sure that
it's going to be there the moment of and
a lot of the these these tools are great
and I'm sure that they have some
internal simulation capabilities but if
you can also run your monitoring against
these like simulated networks so that
you can make sure um that it's all
functioning the way that you think it's
functioning um I think that's that's
pretty
key so in the final few minutes um
before I'll leave a few minutes uh we'll
have a few minutes for questions I just
wanted to show you the the open source
repository uh that I la that I released
a couple weeks ago with all the tools
that I use to run these for protocols um
so it includes like a Foundry and hard
hat set up for like validating different
like war game scenarios um on a local
Fork it contains a bunch of
configuration scripts for setting up
virtual test Nets with block explorers
to run these uh templates for the
tabletop exercise uh monitoring and Bot
Services which we forked from um an
optimism repository and also like a
stack for setting up like a Prometheus
grafana instance so like this is all
that I use when I run a when I run a war
game so this should be all uh that you
would need to potentially use if you
want to run one of these with your own
uh with your own
protocols so this is just a a brief look
at like what the tabletop script looks
like and so we'll be on a call usually
uh it's like an hour hour and a half
with like the whole with the whole
protocol team or with like if it's a
very large protocol maybe it's a subset
of the protocol uh a subset of the team
um but always cross functional and we
just talk through like in this exercise
we're going to um discuss various
scenarios that you'll need to detect and
respond to issues what we want to like
uh understand is typically like uh do
you know what the key dependency of your
protocol is and you know what would
happen if it fails is there sufficient
monitoring infra to detect and respond
to these failures um do you understand
who has admin capabilities within your
within your protocol um are there
backups in place so these are the this
is almost an additional information
gathering step for us um so that we can
design the best uh live scenario and
then the questions that we ask in each
one of these scenarios is always um like
how did you discover this issue so if
we're looking at maybe an an L2 and
somebody submits some sort of fraudulent
uh withdrawal proof how did you find out
did you wait until somebody rate like uh
reached out on Twitter or Discord and
said hey we looks like you know XLT is
under attack right now or did you have
some internal system that would have
alerted you within seconds and so first
how did you find out do you know who to
gather do like does somebody become an
Incident Commander here do you have like
an on call team or is it like whichever
engineer awake somewhere in the world is
the one that has to to deal with this
like is that uh how does that work do
you have a response plan for this if not
why not is it just too rare um and then
who took action and how and so all of
these questions are how we can
understand like how well positioned a
protocol is um to uh actually uh to
respond uh and then for the live drill
um the setup steps this is always the
part that takes me the longest but we
create the fork run the Bots brief the
team I'll send them some sort of like
dramatic message of like you know you're
now in like a very you're now in a very
realistic simulation where this really
bad thing's about to happen you have to
treat it as if like U everything was uh
as if it's all real life um but you
typically don't need to encourage that
like they'll go into stressful mode and
uh everybody wants to show that their
internal tooling really works really
well and so um uh and so yeah teams we
found always take it very uh very
seriously um I always love love to
observe kind of the especially just the
conversations between like Dev and comms
where it's like Communications prepare
is like a statement developers are like
no we can't say that at all or
developers want to say we're pausing the
protocol and Communications is like no
we can't say that like so that's always
really interesting uh to to observe how
that
works uh we have um uh this is just a
view of like a tenderly virtual test net
so I found that this is like I used to
set up like an anvil fork and a block
Scout uh drop uh and a block Scout
Explorer um but that would always take
me like two days um So lately I've been
uh using these tools but you can run
these Forks using any any tools um but
this is like what it looks like when I
set up a fork of main net um and then
this is like my grafana setup where um
I'll have like an a just a basic and
variant monitoring thing where um we're
checking for certain conditions like you
know more tokens were withdrawn from an
escro contract and we're actually locked
up for a user and why would that happen
and and how would we fix
it uh and then the uh we the team
actually has to submit the transactions
on the test net um we try not to we try
to uh do a couple things to keep safe
like change the chain ID of the test net
so that the um so that the actual like
response transactions couldn't actually
be replayed on Main net because we
wouldn't want to be able to like take a
pause transaction from our test net and
then actually pause a major protocol on
Main net and so we change the chain ID
um and then we also try not to uh make
them access like keys for safes and
stuff if they really don't need to and
so we'll kind of spoof the process of uh
of doing like a multisig transaction
just in case like there's all sorts of
security procedures around accessing
these Keys um yeah so we try to try to
keep team safe doing that uh here's a
link to a few resources the first one is
uh actually related to an event that was
two days ago that we hosted uh here in
in Bangkok but I left it there because
well I think we'll be doing more of
these like Live Events where you can
compete with each other uh to try to
white hat rescue funds from protocols uh
the second is the GitHub repository uh
we have the security Alliance website
where you can uh sign up for a drill
sponsored by the security Alliance um
and you can also sign up for drills um
on my company's website Shield 3 uh if
you're on a an accelerated timeline uh
or feel free to chat with me if you're
just like hey I want to run war games
for protocols uh I'm happy to
share so thank you all right thank you
very much
Isaac appreciate it even though we
started late you finished well within
your time I really appreciate that and
I'm happy to say that our questions are
now working so let's turn our attention
to the screen I'm going to read out the
first question with the most votes is it
possible to have a Seal Team Member be
part of a protocol Guardians multi
somehow y yeah um a lot of us are on
some of these uh multisig or on security
councils we actually talked about this
recently like if seal itself should be
like members of security councils we
came to the conclusion I mean this might
change in the future that like us
individually
can also be like on security councils
but seal itself is not but like many
many seal members are open to being like
on these uh uh on guardian multisig and
uh and stuff like that so feel yeah just
find me and we can we can help all right
thanks for the answer thanks for the
question next question that got voted to
the top do you share threat intelligence
data on chain if no how or where do you
share threat intelligence data yes so
the security Alliance website should
have a link to the seal dasis
which is the information sharing tool um
there's a there's a a large amount of
data that actually is available publicly
but then also if you're like a wallet
company or an exchange where also um
there's like even more sensitive data
that can be shared in a more private way
um so that's the best place to look for
like uh for just data being shared
across teams it can be it there's
they're even starting to gather a lot of
information just about every time like a
a North Korean developer applies to a
protocol they try to just like profile
it and understand like how they're doing
it who's getting just so that we can
like share data on like how teams are
how teams are being like trying to be
infiltrated thanks seal ISAC thanks for
the answer great all right let's go on
we've got time for more questions does
the drill occur unexpectedly I.E the
team knows it'll be happening but
doesn't know when uh I've gone back and
forth on this a few times initially it
was like we would give them an 8 Hour
window and then say like okay it's going
to happen at some point in this 8 Hour
window um but then I was just sitting
there like stressed waiting for it to
start so I always just started it right
at the beginning of the window um so I
don't know if like uh it it might be fun
to do that I think at at some point
we're talking we're thinking about like
can we do like more surprise drills um
on these longer running test Nets where
we like submit a faulty or like we
submit like a a faulty proof to like an
L2 rollup or something like that just
out of nowhere um just to surprise a
team um but yeah typically they know
that it's going to happen on a certain
date um but it I it still maintains a
pretty good amount of realism right
thank you very much surprise you've been
compromised anyway uh let's move on to
the next question I think this is an
important question it's got quite a few
votes as well what's the most common way
teams fall over I think one of the most
common things is like having your
internal tooling just not be up toate um
so it's very like maybe like one
developer got on a was very inspired a
year ago to make all of like these
really great internal tools but then
like the protocols changed a bit over
the last year and the internal tools
don't work so I think like maintaining
the internal tooling you need for these
scenarios is is very important and
dedicating engineering resources to
doing that so that like it's not like oh
I really hope this tool Works um when
you're actually in the incident
excellent answer fantastic we got a few
a little a little bit more time let's
try and do one or two more any way to
react to layer one protocol incidents uh
yes so I think that we want we're
thinking about some fun things to do on
the layer one like maybe related to um
like major protocol major like L1
protocol upgrades thinking about what
could happen if there's major chain
splits or Forks or bugs in a certain
consensus client but not another one
like what chaos could we simulate across
the whole ecosystem if upgrades perhaps
go really poorly or if there's bugs or
supply chain attacks into major like uh
validator code um of course like these
are things that shouldn't and probably
won't ever happen but it's fun to
practice uh and I think worthwhile to
practice uh the response excellent Isaac
you got one minute for the last question
do you go through the worst case
scenarios in war games for example you
got hacked money is lost what now do you
go to contact Law contact with law
enforcement uh typically I actually
that's a really good question which I
didn't touch on which is like we try not
to just make these like an instant
wrecked scenario because it's no fun if
we just say protocol was upgraded
there's a bug all the money is lost you
can't do anything like that's no fun for
anybody so we try to make it something
that's like recoverable that they could
actually respond to um but uh I think
yeah actually on the last one um uh
where we had like some money stolen they
were like okay now what we would how
would we actually try to like Chase down
this money that we got that was that was
uh was stolen and the answer is like
that's something you can go to seal 911
for uh because they have really good
like tracing people that can like say
okay now we're going to see where the
money's gone and try to recover it in
other ways um and so uh yeah if you get
hacked uh uh first fix the protocol but
then yeah we can also help you uh track
down the money excellent wow we finished
all the questions in record time let's
give Isaac a big round of applause
well done thank you so much Isaac
welcome you back to your
seat and uh thank you very much to the
audience as well the questions were
fantastic I'm glad to see that the Zupas
is working now you can actually send
your questions in advance as well
instead of just scanning the QR code on
the screen you can even right now access
your Devcon passport select the session
and ask the questions in advance right
if you scroll at the bottom of each
session you'll see a live stream video
you'll see a translation option you'll
see see a live uh collaboration notes
button as well and of course the very
important Q&amp;A button yeah so try to
submit your questions in advance the
team has refreshed the back end so the
questions should be working and it was
great to see the questions on the screen
as well okay our next session is coming
up very soon it's going to be about a
war room scenario and Black Swan events
I'm just going to give about 1 minute
for everybody to settle down if you want
to go to another room that's fine but
please do so quickly and quietly all
right and those of you at the back if
you'd like to come forward please come
forward as well we want you to have
[Laughter]
the
all
oh
come
I
up o
is
e
is all
for
a
in
and
he I
that e
you
thanks for joining guys if you guys can
move up a little bit so it's a a bit
more respectful to the speakers if you
guys can just kind of fill up the front
seats that would be appreciated
you guys want to go outside and Usher
some people in like lunch is
over get in the room
there
so the sound will give me
a thank you very much for joining us
back after the break uh we have a great
lineup of talks coming up and the first
one is by David who's going to be
discussing a little bit more about the
open challenges when it comes to mini
apps and frames and as you guys know
forecasters and Frames have been quite
the hype within the ecosystem so I think
it' be interesting to learn a little bit
more about the development issues and uh
what we can be looking forward to thank
you all right can everybody hear
me okay great um quick before I start
would love to uh have a show of hands
who here knows what a frame
is okay um okay so there's a bunch of
you that don't know so I'll make sure to
explain it and sort of have a sort of um
intro to it um so uh I'm David Furlong
um I've been working on frames JS which
is a library for making frames um and
then also open frames which is a
standard for frames that work in
multiple ecosystems
okay the clicker isn't
working uh can we get some tech support
oh okay now it's working okay so before
we start with frames uh I thought I'd
quickly explain why frames sort of make
sense to begin with I think there are
three key problems to crypto ux uh the
first is safety um so you know today you
sign transactions with your wallet um
they could be malicious and they could
take all your money
the second one is Simplicity um a lot of
transactions require things like
transaction simulation and very complex
interfaces that you know we've gotten
very used to as crypto users in
navigating but um I don't know if you've
tried sort of bridging lately but even
that is is sort of pretty terrifying um
so when we're thinking about onboarding
the masses um and especially in Social
that's something that's sort of top of
Mind Simplicity is very important
and then thirdly speed so uh a lot of
crypto apps rely on things like wallet
connect and um in my experience this has
been sort of a lot of steps that are
confusing sometimes don't work um and it
makes it very slow to do something and
when you add a lot of friction to an
action uh consumers are less likely to
do them so what is a frame um so frame
is a is a new type of embed um that when
a link is shared uh on a social network
like farcaster instead of showing a
little card image uh and just a link to
the website uh a frame allows the
developer to specify um actions so
buttons and optionally an input um that
then can sort of uh be displayed by the
app into this sort of mini app um and so
this allows developers and websites to
express u a small little uh nibble of of
their app app in this other app um and
the second part that makes frames
interesting is that uh when a user
presses on one of these buttons um the
uh the website for example the Girl
Scout cookies website um gets a sign uh
signature that the user that has that
identity actually took that action and
so that allows the website to
essentially authenticate the user uh and
do actions on behalf so for example I
can press press a button and the zor app
will let me um automatically follow
someone on the Zora app without ever
leaving warp
cast so frames originated in farer um
but now they're supported across
numerous ecosystems so xmt lens uh Bas
profiles and um we have an extension for
X as well that brings frames
there so do uh frames today solve the
three problems of crypto ux um so
because this is a lightning talk and I
have very little time I'm I'm only
concerned with the technical problems
around this so there's other problems
that are sort of less technical like
distribution of frames um but starting
off with safety so um frames um so warp
cast innovated on frames by allowing
people to Mint with a with a sort of
point system called warps and that
allowed people to trans transact with
contracts without actually signing
transactions with their wallets and so
that's sort of a safer way of doing
micro payments than than sort of
traditionally in crypto where you sign a
full transaction for every little little
payment um and so that's worked for some
types of transactions but other types of
transactions um still require uh a
wallet signature um next Simplicity this
works for some things but for example
chess doesn't work very well
speed um it works for a lot of small
things but as soon as you get into more
complex games or sort of fstep games um
a lot of the sort of experiences become
limited by the speed of frames um and
that's because of the way frames work um
everything at the top there is an image
um and image generation is kind of
slow um so where do we go from here um
so there's been some discussions and
Innovations on sort of mini apps as a as
another type of technology that are
similar to frames where frames are good
for certain things like entry points One
Step flows and transactions and maybe
mini apps can be a more expressive layer
beyond
that thank you um any questions Havey to
answer them thank you very much so we
have about four minutes either you guys
can quickly hop into the session QR code
to ask questions or we can quickly just
pass around the mic for David to answer
if anyone has any questions
two minutes don't miss the
opportunity
right what's the difference between mini
apps and Frames technically right so a
frame can only express up to four
buttons and an input and an image um
mini apps are are really like mini
websites so you can do sort of full
programming you can have full
interactivity um and so we've seen mini
apps for example in Telegram in the
world ecosystem now and uh farcast is
also exploring mini apps as well so with
frames you're using images for outputs
with mini apps is it right um which is
has different trade-offs right so um
when a user is interacting within a mini
app it's sort of like an untrusted
environment so while if I sort of
confirm a payment inside a frame the the
sort of warp cast or the parent app
knows that the on that button uh whereas
if you're inside a mini apppp then it's
sort of up to the mini apppp and and you
can't really rely on you know what the
mini apppp is is doing or the user is
pressing within the mini apppp because
the mini app could sort of be malicious
or you know say the user is confirming
the transaction but there's no way for
the sort of parent app to know
that amazing thank you anyone else have
any questions right
there hey uh is uh friend GS working on
has a SDK or API that we can work on and
test how does the mini app would look
like in frames uh yeah so frames JS has
a debugger and it has support for uh for
mini apps uh so you can debug and sort
of test the initial specs of mini apps
the minia app spec in farcaster is still
evolving and in a draft phase we already
support it but now now the specs change
so um uh yeah and then we'll also have
support for many apps in open frames um
and so um that's sort of a a new
technology that's coming that's very
exciting I think all right thank you
very much let's give it up for David for
giving us that amazing lightning talk
and giving us this time thank you very
much if you guys have any questions I'm
sure David will be more than happy to
answer them after the next session as
well um Horsea will be joining us to
talk about forecaster frames and
building embeddable ethereum Maps so
just seeing the energy of the room come
back it's quite uh apparent frames are
on top of people's mind and how to
actually start engaging with them in a
more uh userfriendly way and making the
advancements happen in this ecosystem is
quite interesting for
people so I hear you're going to do a
live demo with the internet involved
good
luck May the demo go in your
favor e
all right hey everyone uh my name is
horse and I work on farcaster I'm here
today to talk about building embeddable
ethereum apps using forecaster
frames so forecaster is a decentralized
programm social network built on top of
ethereum and this is what it looks like
right now it's basically a feed focused
short text social network uh you can
create a profile you can follow people
and topics you're interested in post
things like text images links and video
uh it looks a lot like Twitter but it's
purple and if you squint it might look a
little bit like Instagram or Facebook or
Reddit too because it's built on most of
the same social Primitives things like
your identity your social graph and text
and media content uh just curious like
how many folks here are on
forecaster okay how many are like daily
active users of
foraster cool and how many of you have
built a a frame already okay
cool uh so yeah at farcaster we're
building social networking as an open
protocol that means that your account
and identity live on chain as something
that you actually meaningfully own it
means that your data in Social graph are
stored and replicated on an open
peer-to-peer Network that can't be shut
down like a private
API uh and it means that forecaster
clients are something we design and
build with programmability in mind so
that you can build and distribute apps
permissionless so David actually already
gave us a really great intro to frames
and what they are um but I'll I'll give
you another frames are a way to build
interactive apps that are embedded
directly in the forecaster social feed
uh so here's an example uh and this is
kind of the demo we be using today which
is a little game called
yoink if you're building an ethereum app
it can be pretty difficult to get that
app in front of users they have to find
your app on the web or on social media
they have to click through to the app
open a new page connect their wallets
sign in and only then can they do
something interesting uh I think most
builders in the space have had this
experience it's like can be really hard
if you've built something just to get it
in front in front of users who have a
connected ethereum wallet so frames
helped solve this problem by helping
your opet distribution they enable you
to embed interactive calls to action and
ethereum transactions directly in the
forecaster social feed so you can reach
users where they are we have right now
around 50,000 daily active users on
forecaster and creating a frame is a
great way to reach
them we wrote the first frame spec back
in January and since then developers
have built thousands of frames for all
kinds of interesting
applications so apps like Rodeo
Zora and Moshi cam have built frames
that enable you to Mint and collect in
feed on farcaster every poly Market link
is a frame where you can make a
prediction in just a few
Taps every mirror and paragraph article
is a frame where you can subscribe in
one click or even launch a mini app to
read articles right in the app
yeah let's let that that one play for a
sec so yeah you can open uh click
through to open this mini app and
actually browse an article directly in
warcast uh there are frame apps for
organizing and managing events that take
place in the real world in events that
are online things like meetups and audio
spaces developers have built frames that
facilitate payments subscriptions and
commerce
and that's just the surface there's a
lot more things like polls media games
crowdfunding tipping swapping and much
more so if you want to explore frames
for yourself a really good place to find
some is this explore tab in warcast if
you tap this globe right in the center
of the nav bar and scroll down in
warcast you'll find sort of an
interactive uh screen here where you can
browse through uh not just frames but
app
uh and and other things that are built
on top of the forecaster
protocol so frames are cool on their own
just as like an embed that appears in
the feed but they get even more
interesting when you combine them with
other programmable surfaces in
farcaster uh so sort of throughout
farcaster we've tried to build in places
where you can uh program forecaster
right you can build through using apis
and using Open Standards the ability to
uh build your app into the farcaster
social feed so for example developers
can build mini apps that interactively
add frames from the cast composer so you
can create a poll with Ponder and insert
it into a cast on webcast you could
search for a gif to insert from a gif
keyboard or you could share media like
books songs and movies with
Nook uh you can also launch a frame by
clicking on a cast to take actions like
translating bookmarking and tipping that
exist in kind of the the context of a
cast so you can think of this almost
like a browser extension for a social
network or a programmable like button
that's built into the
app uh a final way you can use frames is
sending them in direct messages so like
this event reminder on the left was sent
through a direct message so sort of
closing this feedback loop where you can
communicate back to the user uh and send
them a frame in in a direct
message so we think about frames actions
mini apps direct messages all of things
as developer Legos that we're building
on top of foraster and into forecaster
clients uh and building Legos that
enable you to kind of snap them together
to extend clients in new and interesting
ways and embed your app throughout the
social
feed frames are not just on farcaster uh
they originated on farcaster but
ultimately they're based on a pretty
simple open spec that anyone can
Implement uh in fact David and open
frames have extended forecaster frames
to be usable in in a bunch of different
applications throughout the
ecosystem so thanks to projects like
open frames you can build frames that
now work across foraster lens
xmt uh the open web and even like he
demoed using their extension on X uh we
think there are now at least 24 apps
that display frames across the ethereum
ecosystem you can see some of them
here uh on the left here as well you can
see a frame that's embedded in lens so
uh math quiz frame that works across the
forecaster and lens
ecosystem uh okay so we're going to
build a frame in today's talk let's talk
a little bit about kind of the theory
behind frames and how they work uh
ultimately they're based on a few Old
Reliable web standards the three big
ones are open graph HTML and
HTTP uh so one thing I think is great
about frames is that if you can build a
web up you can build a
frame in particular I think they're cool
because they're permissionless meaning
anyone can build one they're simple
which also means anyone can build one
and we've seen lots of developers come
to forecaster and kind of build a frame
as as their first app right or their
introduction to to web programming or
ethereum
programming uh and in fact they're so
simple you might call them extremely
constrained but I think that encourages
creativity so if you've ever copy pasted
a link from the web and seen it unfurl
into a preview image this was probably
thanks to open graph uh and here's a
great example right if you copy a GitHub
repo URL uh and paste it into Twitter
you get an image that looks like this
it's this nice Dynamic image that shows
the repo name icon number of stars and
forks so it's possible for Twitter
clients and you know uh applications on
the web to render this because GitHub
includes special metadata tags in the
HTML head elements of this
page uh and in fact here's what they
look
like uh yeah these meta tags describe
the image
here the type of the content here this
is a
website the
title description of the
site and a
URL so when you post your tweet twitter
makes an HTTP request to fetch this page
loads the HTML looks for the the head
element parses these metadata tags out
of it and then ultimately renders this
really nice image instead of the plain
URL so open graph is actually kind of an
oldish standard at this point it was
created way back in 2010 by Facebook uh
but it's still very widely used around
web uh and in fact you might have seen
more of these d images around the web
lately if you use versel they have
really good tools like Satori which are
used for rendering HTML into a nice
Dynamic image and in fact one of our
Inspirations for frames was the fact
that we were already rendering these
share images for firecaster casts you
can like click within warcast and share
out an image and will render this uh um
share image that you can can post around
the web
um we realized kind of by building this
that there were pretty good tooling out
there for rendering jsx rendering HTML
to images and so it's kind of becoming
possible to turn open graph previews
into these simple if constrained
uis okay so the big idea behind frames
is that we're going to take the sort of
static open graph metadata and extend it
with the ability to Define interactive
actions and simple UI elements along
with static components that you're used
to from open graph like an image But
ultimately it's all same basic idea uh
forecaster client will fetch the URL it
will load the HTML Parts out the metat
tags and render an interactive embed
it's just that if it's a frame we've
happened to added we've happened to add
these uh these buttons and actions that
Define some interactive things you can
do with
it so here's what frame metadata looks
like you can see it looks a lot like
open
graph you can define an image think of
this as your UI right this is kind of
your browser canvas in which you're
going to build and render your
application you can Define simple UI
elements so buttons you have up to four
buttons and you can add a very simple
text input um that's
it and then finally you can define a web
server which is how your frame handles
interactive actions over
HTTP so it's kind of like if open graph
was created by cool Mark
Zuckerberg that did not land all
right uh cool okay so here's how a frame
interacts with the server like kind of
the whole the whole life cycle more
concretely um we've got the cast
composer up here this is where you're
typing in your your cast your post uh so
yeah when you first post a link your
forecaster client will get the
URL the frame server then returns an H
ml page right this defines those images
buttons and actions in the
markup client parses that frame metadata
and renders it in
feed so it looks like this Frame server
returns frame metadata uh the client
parses that and renders it so clients
will typically cache this initial frame
uh in fact in wecast they're like cached
quite heavily so we can build feeds and
render them quickly uh which is kind of
a common frame gotcha so be careful
about this in in that your layout and
your initial image will typically be
cached
okay so now when the user comes and
clicks a button the client makes a post
request to the server and this post
request includes some information about
which button was clicked and the user's
identity from there the server can
return HTML that defines another
frame and if there's a button to click
in that frame the client post back to
the server it can return another frame
so on and so forth sort of just back and
forth http request response
cycle so this means you can chain frames
together to create workflows that have
multiple steps uh you can Branch based
on user input you know return frame a if
this return frame B if that uh and you
can even compose frames kind of like you
might compose functions you can have one
frame make a request to
another okay action types so you can
Define this image you can Define buttons
that make particular requests that uh
represent different types of actions
what are those types of actions so there
are a few different ones uh by default
clicking a button will make a post
request to your frame server sort of
standard HTTP post um there are some
other types as well so you may want to
link out right send the user to an
external link uh you can do that using
either a post redirect button or a link
button so which is one of those is a
sort of a dynamic link where your server
will receive a post request uh you can
respond with a with a URL that will
redirect the user to so you can use that
to kind of figure out if you want to
dynamically link based on some state of
the request or or the user or whatever
uh versus a link if you just want to add
a static link which is like a pretty
pretty common typical use case you can
simply add that as a link
button uh and then the most interesting
one and the one that we're going to talk
about a lot today are transactions uh
which make a request to fetch an
ethereum transaction uh they get the
call data for that ethereum transaction
and then they forward that to the user's
connected wallet so you can use that to
basically embed direct ethereum
transactions calls to action uh directly
into a button on a
frame okay so images and buttons in HTML
metadata you can think of these as
defining your frame UI uh we have HTTP
requests made to your frame server that
Define the actions you can take the
Behavior Uh there's one more really
important frames concept to cover which
is the signed frame message
so this is the like data payload that
the client posts whenever you click a
frame button and this is a Json object
that looks like this uh it's compact but
it actually communicates a bunch of
useful information to your frame
server so up here you get the foraster
user ID of who interacted with the frame
uh in this case it was me that's my FID
interacted with and when they did
it you get in here in this cast ID
components information about the cast
The Post where the frame was
embedded and that includes who posted
that cast which is very
useful and then of course you get which
button the user pressed so you can use
this to figure out what they did and
then respond to it on your
server so in addition to all this since
farcaster data is open and public you
can further enhance this with data from
the user's social graph or onchain
history so for example you could look up
whether the user who interacted with the
frame is following you uh or you could
look up their linked ethereum addresses
and you know figure out whether they own
a token things like
that this last component of the message
is probably the most important so this
trusted data field is a hex encoded
cryptographic signature that you can use
to verify the data in the rest of the
message so so every post follow and like
on foraster is a cryptographically
signed message which is stored on
forecaster
hubs uh when you publish a cast
basically you're signing a message with
an ed25519 key uh hubs will store that
message as long as the key exists in an
onchain registry so your ethereum
account controls your identity that
account can delegate to uh an ed25519
key which signs your messages on the
protocol those go onto hubs this
peer-to-peer Network which stores stores
all the
data uh yeah this is kind of a diagram
of the uh The Hub system and how how
hubs work uh so a hub will accept a
message if the the cryptographic
signature is valid and if the key is in
the onchain
registry so frame messages use this same
format which we use for signing uh
signing posts signing reactions signing
all the other types of messaging data on
farcaster you can verify them in exactly
the same way but they're ephemeral so
they're not stored on the network but
you can still verify them in the same
way so this means it's possible to build
authenticated experiences that rely on
the user's identity uh and you can do
this permissionless without needing an
API key or asking the user to log in and
so concretely the way you can do this is
uh to interact with an HTTP API that's
Exposed on the hubs you can basically
grab that uh cryptographic that grab
that hex encoded signature out of the uh
the message data make a request to a hub
API which will verify it for you uh and
if you want to do that you know
trustless as well you could um verify
the signature yourself check the unchain
uh the onchain signature
Etc uh and that's it so frames our HTML
markup that describes an image and
buttons there are HTTP requests back and
forth to a web
server and they're assigned data payload
those are the three most important
principles okay so some design
principles for building good
frames uh I think we've seen thousands
of frames built over the past year and
after seeing lots of experiments in the
wild there are a few a few principles
that i' encourage for building good
frames uh the most important is to just
keep them simple fast and focused the
very best frames have a clear call to
action and a linear workflow with only
one or two steps so if you're trying to
build like a complex multi-step app that
has a lot of branching and error
handling and callbacks a frame might not
be the best way to build your app uh
they're really good for you know simple
calls to action linear workflows without
too much
branching uh I like to think of a frame
kind of as a Game Boy right it's this
very simple constrainted user interface
you have a couple buttons um and you
want to fit like yeah you want to fit
sort of a simple uh fun fast experience
into a very limited
UI uh or even better think of like the
Wii U if you remember this uh think of
it as the little gamepad screen that was
built into the Wii uu
basically there's a whole game your
application that's going on outside your
frame but your frame is a way that you
can highlight a specific action in
context in the feed and encourage
somebody to take con action in context
now uh you can definitely build your app
frame first if you want and you know
frames are permissionless Open Standards
so you can do whatever you want with
them but I think it's almost always best
to to keep them
simple here are a couple examples I
grabbed that I think are are good frames
uh this one is from hypers sub which is
a subscription service and what I really
like about this one is that it has a
very clear CTA just as a single button
and it has really good default settings
so you can see well yeah you can see by
default it will subscribe you to a
single a single month um so you can ask
the user for kind of complex input um
but by default it
is doing something with with a good
default uh so yeah this frame has a a
really simple straight forward single
click workflow you send the transaction
and it shows you the receipt right away
that's it uh so I think this is this is
a great way to you know bring a really
simple call Action directly into the
feed here's another one this one's from
Zora uh I like this because it has one
very clear in feed action mint and it
includes a link out to the main app if
you want to do more so you know don't
think of the frame as your entire app
kind of crammed into the social feed
into this very constrained UI that we
provide with frames think of how you can
bring the most important actions from
your app that exists outside of
farcaster into the frame and kind of put
those put those in front of people so
Zora also really makes nice use of the
image uh they're showing the number of
mints and comments dynamically this can
be kind of tricky to get right because
of the way frames are cached but we will
like respect cache headers and you can
build Dynamic frames that kind of
regularly update and show things like
the number of people who have minted the
number of people who have interacted um
yeah I describ this as kind of an
advanced technique so uh you'll practice
a bit with frames before you do this but
it it's a great technique um if you're
careful about how to do
it uh so Paradigm put together a great
uh resource called the frame interface
guidelines which has a bunch of
principles for building good frames if
you're interested in uh yeah interested
in expanding on this I would encourage
folks to go go check that out so there's
a a figma guide and a bunch of
guidelines here for how do I think about
building UI uh and how do I think about
building really good user interactions
in frames
okay a few common gas uh frames in
general are really simple I think there
are a few a few common difficulties and
gutes that we see with lots of people
who buil them and the three big ones are
performance large images and
caching so first Up Performance frames
need to respond in less than 5 seconds
or they'll time out uh and especially if
you're using like a serverless tool that
have a cold start this can be kind of
difficult to sometimes to to fit your
app within this timeout so ideally you
should cach and index as much data as
you can you should add loading frames
like interstitial States if necessary if
you're loading a transaction and um uh
waiting you know to load the hash or
looking at the the status of a
transaction on
chain uh and yeah if you're using
something like for sale a serverless
deployment uh where you might have a
cold start uh be careful to try to keep
that warm and keep that as responsive as
possible uh the second common guy is
large images so we do enforce a 10 megab
limit on image size if you're not
careful you can exceed that easily the
other sort of more subtle but common
gotcha here is uh building very complex
user interfaces using some of the main
frame uh frame Frameworks so frog and
Frames JS which are the two main frame
libraries can have trouble rendering
very complicated uh jsx that has a lot
of
components third Pretty common gcha is
caching so your initial frame frame will
always be cached by clients and the
initial image will be cached according
to whatever cach heads you send down to
the client so it's possible to build
frames with Dynamic images but it can be
tricky to get right fortunately there
are good tools for testing this out so
warcast provides a a frame validator
tool that can show you your cash
shatters we're going to look at the
frames JS debugger as well when we build
out this Frame shortly so those are good
ways to kind of experiment with and and
watch these
gachas above all though with all three
of these I think like just keep it
simple um keep your IM is simple keep
your applications simple try to think
about like what is the the one action
that you want to bring in the feed if
you're building a
frame okay so that's theory of frames uh
we're going to try and build something
here move over to doing some live
coding uh frames are simple enough that
you can use any web framework to build
them if You' like but today we're going
to use frames JS which is a library and
tool for building frames in JavaScript
and typescript that works on top of a
bunch of different web
Frameworks in this example we're going
to use typescript nextjs and react today
but uh it plugs into a bunch of a bunch
of different Frameworks and so you can
sort of VI your your tools of
choice uh we're also going to use a few
ecosystem tools so we'll use VM to read
and interact with a smart
contract we're going to use Nar which is
a forecaster API service to enhance our
app with uh forecaster social data
and we're going to use Ponder which is
an indexing tool for ethereum
contracts okay yeah and the goal today
is to build a really simple game that
interacts with the smart contract uh
it's a capture the flag game called yink
here's what it looks
like so in yink you can see who
currently has the flag uh you can yink
the flag from them and when you yink it
you will get a token in your wallet so
we'll track the number of Ys that have
happened to build a leaderboard and then
we will enhance the context of the game
with forecaster
data uh all right hopefully this goes
well I'm going to switch over to life
coding from here um but if you want to
follow along you can clone this repo
from GitHub to get up and running and
yeah let's give it maybe uh five minutes
for folks to grab this repo and get set
up if they want uh in the meantime maybe
we can take
questions for
all right we'll give it like 30 more
seconds I'm going to switch over
uh here I'll put it back up for a
sec yeah github.com horsa SL yink Devon
I can maybe uh cast it out on faras or
too if you're following
me let's do
that for
cool all right praying that the uh the
network holds up
here okay so yeah here's our yink repo
this is our frames JS repo um this has
been created with uh just like the
frames JS starter kit uh you can we'll
give a quick walk through the repo here
okay so if you pulled it you'll want to
just run yarn to install uh install
dependencies and you can run yarn Dev to
spin up the frames JS uh debuger and
test
server we'll look at this frames jsd
bugger in a sec but let's take a quick
look at how this is all laid out first
uh okay so if you've used next you'll
see like this is the structure of a
pretty typical next app we have stuff
here in app which will Define routes
within our application and we have some
components a frames folder here which
will create a slf frames route and then
we have this Global stuff like our uh
Global layout and our
homepage uh We've based this on the
frames JS starter kit which which has
this really really useful set of
examples out of the box so if you look
in this folder here examples you'll see
sort of worked examples for lots of
interesting and and different things you
might want to do with frames so here's
like the most basic frame caching
building composer actions Dynamic routes
error handling uh so if you're poking
around in this repo sort of as as we go
this is a really good resource to go
look at at how to do different different
things with frames
so basic structure of our app here we
have uh the
homepage and then nested inside this
frames directory we'll have uh our
actual frames
code and we can go look at this hom
page over http
cool so you can see here if we look in
our page markup we're serving these uh
these meta tags right that we looked at
FC frame FC frame image open graph image
and our frame buttons from this entry
point of of our
app unfortunately frames JS takes care
of like you know injecting this into our
our homepage and everything for us we
can just work on um un building the
frames using the tools that it's
uh tools that is provided here in this
frames
directory okay so let's look at y from
the top and then we'll kind of roll back
and build it uh build it out step by
step uh here in this frames.
TS file
we're kind of defining the configuration
for our uh our frames application so a
base path which is like where we're
going to mount the frames we can Define
sort of all the configuration for the
app here uh go check out the frames JS
docs for all all the details on how this
works we can Define things like middle
Wares so if we wanted this to be
compatible with other frame ecosystems
you know like lens or xmt we could add
middlewares here that uh that extend it
to be uh compatible with other
ecosystems
and then here's our entry point frame
route so frames route.
TSX uh and you can see we're kind of
mirroring that structure that we looked
at in the uh in the frame meta tags we
can define an
image and some
buttons uh and the cool thing about
frames JS is that we can Define this
image dynamically using jsx so if you're
familiar with writing react you can
build up a dynamic image here just by
using jsx
components uh we can also use tail wind
Styles in here so you can see we have
like Flex Flex column font buold text
adxl all of these Tailwind uh
identifiers you can use these to uh to
style your frames as you're developing
them so here's our simple entry point
image uh it says yink click to yink the
flag we have a
button uh and this button points to
another frame it's pointing to this path
at start
uh so you can see we're going to build
out a few different uh components here a
few different routes within the frames
you can think of sort of each of these
subd directories uh as a separate
frame so here's the start frame when you
click this button it's going to post to
the start frame and we're going to want
to define a a route Handler to handle
that here's this Frame
okay so yeah let's just step through
this in the frames
debugger so when you run yarn
Dev uh this will spin up this local
frames JS debugger uh which you can use
to browse and uh and view your
frame uh this provides a bunch of you
know really useful information about
your frame you can see some Diagnostics
around the tags you can browse your
console uh you can see the metat tags
and then you can sort of Step through
your frame step by step here so we'll
click
Start okay network connection is working
it's going to show us who currently has
the flag
we'll do a transaction
here I Yun the
flag I can click an external link here
to go view that transaction on Bas scan
and then we've got a simple leaderboard
here that shows uh who has yanked the
flag their addresses and and how many
times okay so that's the idea let's uh
let's go through and build this up step
by step
okay so we're back to the frames JS
starter here we have kind of a simple
demo app where we can increment and
decrement the counter
let's start by just building like the
start page for our
frame so we'll come in here to our entry
point
route let's just Define some simple text
here
yoink we'll remove this text input
remove these buttons
and for now I'll just put a simple
button here that um
thank you
yep okay so this just a simple button
that points to back to the initial frame
so to start this is not going to do
anything cool okay so there's our image
yoink click to Y the flag we have a
button we can click to start this is
just like posting back to our same
initial frame so it's not yet doing
anything so so if we wanted to we could
access the context from this request so
that information that's in that signed
frame message in this context
object so we could show for example
which button was pressed
or the ID of the user who pressed it so
we'll just put those here in this
initial
frame cool so you can see right there's
no value here in this initial request
because that's just the the git request
that loads the initial frame once I
press the button it receives that signed
payload including information about
who's interacting with it uh and we can
embed that information into the
frame so you could build an entire app
with like a single frame route if you
want you know doing your switching and
branching within a single route just
like posting back to uh to one route if
you want examples like the simple
examples in in frames JS do this but if
you're building an app with like you
know more than one workflow for me at
least it makes sense to kind of uh um
separate these out into individual
routes for for every single frame so
we'll kind of Define one API route or
one frame API route for each frame uh so
in this case let's create a start route
and we're going to when we push this
button we will send the request to the
start
frame all right so we'll create a
directory in here with a route.
TSX I'm just going to copy paste
our start
frame and let's just change the text on
this Frame
ah okay we need to update this one to
point to this new
route
cool that's remove this context
data cool so we've got our initial frame
right our entry point uh we're posting
and sort of you can think of it as
returning a new frame or kind of
redirecting to to the next frame that's
going to handle the next step in the
workflow uh so with yink it would be
really cool to use like a dynamic image
that shows the number of yoinks on the
first uh the first image and shows a
bunch of contextual information that's
kind of difficult to do in our demo and
difficult to do with caching so we're
going to adopt this pattern where
there's always a start button we're
going to load some data dynamically into
that that second step and uh um and
display it in that second step so if
you're building frames and want to avoid
some of these issues with caching it's
not a bad idea to sort of always start
with this start step this initial
interaction and you can start loading
dynamically data from there uh it's a
lot easier to avoid issues that you
might bump into with caching so we'll
follow that approach here
uh okay so in the second frame ideally
we'd like to uh show some onchain State
about the game uh right we're going to
want to show the current user who has
the flag like the number of yinks that
have happened in the game and to do that
we're going to need to read some of that
onchain state from the contract
we can do a super quick tour of the yink
contract this is not a solidity uh
Workshop but we can take a quick look at
it so here's how the game of yink Works
uh it is a ERC 1155 token with some
special logic in here for managing the
game uh and we're going to transfer some
different tokens to people when
different actions happen in the
game so we're tracking the total number
of Ys in the game the time it was last
yink at the uh current record for most
yinks the address of the top Yer and the
address of the person who last yank the
flag everyone has a score stored in this
mapping and then here are the rules of
yink so you can't yink the flag from
yourself if you already have
it we also will enforce a cool down
where you can only yank the flag once
every 10 minutes
when you yink the flag we will transfer
you this special flag
token also the first time you
participate we will mint you a score
token this will like show your score in
your
wallet and then if you happen to be the
top yanker at any given time we'll send
you this trophy
token so it we do some calculation on
chain to calculate how long you've held
the token or how long how long you've
held on the
flag uh we'll build a leaderboard right
so track how long you've held it how
many times you've yed it who is the
current top yoner and how many times the
flag has been
yed uh we have some you know helper
functions in here for generating onchain
svgs so these token onchain image
okay we have a lot of helper code for
generating the uh the unchain
svgs uh and then the flag and trophy are
special tokens so they're uh soulbound
they're non- transferable right so if
you you've been issued these tokens
we're going to revert if you try to
transfer them to somebody else so only
the game can transfer these tokens
you'll get the flag sent to you
basically by the the game contract when
you yink
it okay so that's the game of yink uh
this contract is deployed on chain on
base
okay we'll give up on that but yeah it's
played on on chain on base and we can
you know you could interact on ether
scan right you could go to Bas scan uh
and call the yink function to to play
game okay so let's set up to actually
read some data from this contract in our
frame
and to do this we'll use VM I'm going to
add some helpers in
here yeah here we are we're back all
right let's
no okay so we'll grab the contract ABI
let's add it here
and let's get the contract address
all right and in order to interact with
it using V we're going to create a
public client
here connect it to base and we'll use
the HTTP transport by default
okay so yeah let's start by showing how
many times the flag has been yed we'll
just create a function here get yo count
and we'll read our
contract and we'll call this function I
think it's total yoinks
I need to crib for my nuts here hold on
function name all
right cool so that should be what we
need to go read data from the contract
unchain let's go back to our frame
Handler here
and before we render the image right we
can call that function to read some some
data
okay so that's going to return total
yinks as a big int we'll want to convert
that let's do that in the
function oh yeah we need to wait it to
and return it God love like
fting so we'll just convert it to number
there and R return it
all right let's put it all
together cool ugly but there we go flag
has been yanked seven times so we're
reading that state out of uh out of the
onchain
contract so next we'd like to show Who
currently is holding the flag we can add
a similar
function
here got to go look at what this
ISS okay this is the last y by address
so this will show us who is currently
holding on to it
and we can just return this directly
because it's going to return an
address y cool
cool okay so we're showing the address
of the user who is currently yed the
flag and the number of times it's been
yed so yeah our UI kind of ends here
right we're not doing anything after
this
point um let's do two things let's add a
back
button so you can go back to the initial
state
cool so now we can kind of go back and
forth between the launch
frame and this data frame this start
frame that's pretty boring though uh
what we actually want to do is be able
to trigger a transaction here right to Y
so so far we've been using post actions
right um sort of the standard standard
action is just a post now we're going to
use a new type of action which is a
transaction action so change this here
to
TX and post actions are very simple it's
just a request response transaction
actions are a little bit more
complicated because they do two things
they need to load your transaction data
they forward that to the user's wallet
uh they get back a transaction hash and
then they PST that back to your frame so
there's sort of more of a of a back and
forth there two steps in a
transaction so we actually need two
um two routes when we build a
transaction one that Returns the
transaction call data and one that kind
of handles the next step in the
framework
flow so the target of this transaction
action is going to return the call data
and then the post URL is going to be the
uh the action that handles the the
response uh let's call this
receipt all right so two new routes
let's go create those
we'll just put a simple placeholder in
here for the receipt
okay and this TX data Handler is going
to look a little bit different because
it's returning Json about an encoded
transaction and in fact I'm going to
crib from the examples here to look up
how to do this so there's a good one in
transactions you can see it has a
similar structure TX
data so this particular example is
reading from the forecaster storage
registry it's doing some encoding of the
transaction and construction of the
transaction we crib from that
so our y contract is very simple though
we're just making one uh one simple call
to a function that has no arguments so
we can avoid doing some of this uh setup
okay and here's the basic structure of a
a transaction route Handler so you're
going to return Json that looks pretty
much like an ethereum RPC
request uh includes the chain
ID the methods so you can do signatures
through frames as well this is going to
be just a transaction but you could do a
eth type signature V4 and then
parameters that are I I think pretty
much identical to the uh the Json RPC
call
okay so in our case we're going to use
the yink
ABI so yeah we'll just pull in these
constants that we defined in there oh
got to exported
we're going to call that contract
address let's skip data for
now uh and no value with this
transaction so we're just going to need
to construct the encoded call data to
call the
contract
e e
all right cool so we can just use this
VM
helper in code function
data we can pass it the ABI of our
contract the function name that we want
to encode uh and get back the the
encoded call data to call a particular
function on that
contract oh okay and we need to change
the change ID to base
Handler uh our receipt Handler is empty
right now but I think this will just
work as it is let's give it a try Famous
Last
Words reorder these buttons
cool so yeah you can see the little
lightning bolt here indicates that this
is a a transaction button and hopefully
if we're configured right we can click
this and something will
happen sick there we go so yeah this is
prompting me in my connected wallet uh
you can connect up here in the Fram JS
debugger connect up to uh to your own
wallet here and Trigger transactions
and yeah you can see
um it simulated the transaction we're
transferring those tokens when I
interact with it let's sign
it cool okay and then we've hit that uh
that second route right that we defined
you can see we see the transaction
receipt Handler route so that's
returning the the receipt Handler frame
so we're not doing anything here yet but
this has received basically the uh the
trans hash of that transaction and we
can we can use it to either watch the
transaction and show like a loading
state or show the user some feedback on
what has
happens so let's build that
out so inside our context
t uh when we're handling a transaction
call back we can access the transaction
ID uh which is just a generic name for
like the transaction hash we sort of
designed this because we may do Salon
transactions or other types of
transactions in the future so this is
just in the evm context this is just the
transaction hash of the the transaction
that was
triggered and while we're at it why
don't we add like a base scan Link in
here as
well so we'll Define Explorer URL
so this time we'll use a new action a
link this is just a static uh static
link out to any
URL and we'll put that Explorer UR all
in here
okay ugly but there it is the
transaction hash and we can click out
here and view the transaction on Bas
scan great cool so somebody's already
playing yink on chain that's great uh
I've yed it from someone
else so that's very useful because we
have some uh we have some roles in the
game right that you can't y from
yourself and you are you have a timeout
right so
um that's good we haven't implemented
handling those yet so it might have
reverted otherwise
cool uh okay yeah so at this point we
kind of have a fully functional yink
game you can uh see who's currently ly
holding the flag you can yank it you can
trigger the
transaction um it's a little bit ugly in
that we are only
showing uh ethereum addresses right in
our frames you know transaction hash
ethereum address uh rather
than uh enhancing this with the data we
can get from forecaster right so we have
this long ugly ethereum address has the
flag we' like that to be uh if possible
Right a forecast or username or some
sort of more meaningful notion of of
user identity
uh so we can do let's do that yeah we'll
add some enhancements here to show the
user's
identity so to do this I'm going to use
Nar which is an API for accessing
forecaster data uh our example here like
is sort of focused on building directly
interacting on chains we haven't like
made great use necessarily of forecaster
social context right like we're not
really reading the users forecaster ID
uh in any of these frames here we're
sort of working in the other direction
right we're going to go look because
this game is on chain and figure out uh
what working back from their ethereum
identity to what their forecaster
identity
is so since we're running a little short
on time I'm going to grab these from the
example repo
okay so we built out a few functions
here let's just copy paste
this all right we're pulling in the Nar
API class this is going to give us uh
access to this this SDK that can give us
information about forecaster identity
and sort of interactions with a bunch of
different forecast related
apis we'll set up a
client and have built out some utility
functions here right so one of these
lets us fetch uh foraster users by their
Associated ethereum
address so we can use that basically to
say when we have an address let's
convert it to a user
let's not worry about this one for
now uh and then just a helper in here
for truncating addresses which are a
little bit uh a little bit ugly
okay I think we have a special API key
if anyone else is building here too you
can use Nar Devcon
start route here let's enhance this with
the user's actual identity rather than
their uh their blockchain
address
e for
cool okay so yeah we grabbed that
ethereum address we used the N our API
to look up uh batch lookup users who are
associated with that address and their
forecaster identity and got back uh
username here rather than showing uh
showing their unchain address uh you can
see those was pretty slow right I think
it's not just the network here right
we're making like multiple uh multiple
async requests here to go make an RPC
call to read onchain data and to go out
to the the ner API and um uh make an API
call there so we're probably like kind
of at the limit of what this Frame can
handle in terms of the the timeout um if
we want to keep it it
responsive uh one thing we can do is
um at the very least is do do that
action concurrently right so we can
use promise all or something to uh to
make that a little bit more performant
okay so yeah final thing I think we may
want to do in here is
handle error cases from the
contract uh which I think may be What's
Happening Here uh I've been timed out
right so I
recently uh called called yink with this
address uh but right now I've been rate
limited right uh I can't for another 10
minutes so we're not handling that well
right now right this is just
crashing so let's catch that custom
error from the
contract and display a nice message back
to the user
okay so to do this we're going to
simulate the transaction first we're
going to see if it reverts and if we
catch an error from that revert we're
going to display it back to the user
all right so we can use this helpful
simulate contract function from VM to uh
simulate the contract
we'll just create a helper
here import address
all right and then here in our uh
transaction call data generation Handler
we will simulate the
call uh if we catch any errors from this
this is like pretty gnarly VM code for
for catching a uh custom
error um but yeah basically we walk
these errors anything that comes back
um we'll catch the errors from convert
them from their onchain representation
right we have unauthorized which is the
error you'll get back if you already
have the
flag and slow down which is the uh
custom error that you'll get if you're
uh rate
limited and just convert these to uh
nicer more human readable
errors okay let's grab our our functions
here for
cool so yeah within a frame context you
have the ability to return an error to
the user um which will sort of show up
in a toast in most clients um so this is
sort of useful for simple error handling
cases you can do this from transaction
frames uh you can do it from other types
of frames as well which will just show a
quick human readable error uh rather
than returning a whole frame for an
error all right let's give this a try
cool all right I was able to call it
that time I think I uh my timeout has
passed let's try it again
cool there it is so yeah you can see
it's a
little difficult to catch sometimes in
the frames debugger but yeah here here
we've converted that error right from
the onchain sort of difficult to read
custom error um concise custom error
into something that a user can read you
have the flag you can't yink from
yourself
and let's try out
that rate limiting error as
well so I'll change
addresses let's change back
cool and there's our second custom error
you're yanking too fast try again in 520
seconds so we could convert that to you
know a nice human readable uh date would
be nice to do but yeah that's sort of
the principle there we're converting
those onchain uh difficult to read
onchain errors into a nice human
readable error message
here okay final step in here um I'm not
going to implement it since we're
running out of time but let's just uh
take a quick look at the
code so the last thing in here is to
build out a
leaderboard and if you want to go yeah
look at this separately the idea here is
that uh it's very difficult to build out
a leader board uh in a performant way
right we could load all the log data
like calculate how how many people have
yed and kind of do those calculations
within the context of the route that's
very difficult though right so uh it's a
good example of where you should use an
indexer or sort of caching to keep your
frames performance so there is an
example in here of a really simple
Ponder indexer which I
built so Ponder is a great uh open
source tool for building indexers for
ethereum applications you can sort of
spin it up pointed at your contracts and
you get a really nice uh simple Syntax
for writing indexers so I've set this up
um as sort of a separate API service
here that we can use to read the
leaderboard uh and read recent
activity and so if you're doing anything
that kind of needs uh time data right or
performant data it's a good idea to use
uh use something like an indexer to load
that so go check that out in the repo
you can sort of see how to interact with
that API load the from that API and
build out a leaderboard
route okay last step here let's uh let's
look at the actual Live app so if you go
to the repo and look at the code this is
the one that's
deployed and we'll put it all together
and post this game
cool so this is the webcast youb this is
kind of the final uh yep
all right here we go new yank just
dropped cool and there's the final game
so go find that on webcast uh check it
out uh yeah happy yanking everyone thank
thank you so much uh Horsea for the
wonderful session on farcaster frames so
we have a few questions here
uh so can I integrate frames to my
existing site as a component or is it uh
or it must be inside
farcaster yeah so I would look within
frames JS uh is a good example of this
there are a couple tools for like
embedding frames on the web in fact
frame JS you have a rer right David yeah
so Fram JS has a renderer tool like a
library that you can use to render
frames outside of forecaster context in
like a general web context or other
contacts so the answer is probably yes
you can embed them in other
applications thank thank you yep so uh
let's thank the speaker again and let's
prepare for the next session
so the next session is uh starting in 5
minutes uh please don't go away uh we
have a nice session by Augustine Gro Dom
Cy and ran so uh the session is on
redefined interactions transforming user
experience with intents
he
o
back e
see
so guys please settle down uh we are
going to start the next session now
everyone please be
seated so the next session is a panel
discussion by Austine Gro Dominic hell
Huli CTI and Sean Odon and uh this panel
discussion will be on uh re redefined
interactions transforming user
experience with intents so I would like
to uh welcome the speakers on stage
please
and please uh give them a warm
introduction can turn on by
helloo hello everyone uh well thank you
for joining us um we are here to discuss
um about how Intense or or intense are
reshaping the user experience uh in Defi
and from simplifying complex operations
or complex transactions in in blockchain
uh to increasing
security and oh thank you and improving
decentralization so I'm very happy to be
here and I'm very happy to be joined by
this group of experts who are uh
collaborating with leading protocols on
this matter so if it's okay for you we
can start with uh with introductions
brief introductions from from uh all of
us I will let you uh start probably uh
Sean do you want to
yeah hey okay cool um hey guys I'm Sean
I work at orbs I've been um in the space
since uh 2018 uh doing a bunch of stuff
I have no web two experience so I've
been doing it live since um since then
and just kind of learning as I as I go
along it's been um a lot of fun um at
orbs what we're building um is is kind
of we kind of call ourselves a L3 for
onchain trading um what that actually
means in practice is we uh build
protocols for def Pro for for defi um so
we have advanced order types um for
dex's uh so twop and limit orders um we
have another protocol called liquidity
Hub that uses um that's intent in nature
in terms of it Aggregates all the
liquidity on chain we use par swap as a
good friend of ours for that and um and
then we're we're doing some stuff now
with um with perss as well that's also
intent based so yeah really excited glad
to be up here guys um thanks for
inviting me thank you uh jully do you
want to introduce yourself yep okay uh
hi everyone nice to be here too thanks
for the invitation I um jully I work at
mimik and I'm in the whole Partnerships
Communications we are part of the
protocol so at mimic we're a defi
automation protocol and what we do is we
simplify day-to-day operations by
automating and and what we're doing
right now is we're launching our newest
version which is launching our protocol
and we would like to everyone to start
trying and see the full experience of
house like to automate on Defi and make
it easier for people to interact more
and get more access to it and instead of
being like this complex idea that we
have and make it more like uh dayto day
and basically make it easier yeah Co
thank you thank you for joining Dom uh
hey everyone I'm Dominic um I'm the head
of ecosystem at lifi um we are a bridge
and deex aggregator so generally a
liquidity aggregation protocol um our
main usage
is having any to any swaps um across all
the major chains and ecosystems we
support evm Solana and Bitcoin right now
um expanding further into other
ecosystems um we do have Lei B product
mostly integrated um with big wallets
and applications and then it also Powers
jumper.
exchange which is our own front
end interface um which is catered to end
users great thank you uh thank you for
for your introductions for joining us uh
myself I'm uh I'm a I'm leading the
operations and the partnership teams at
Paras swap Paras swap it's a defi
aggregator and we not so recently but
it's a kind of new released our intense
trading uh solution uh that it's built
uh on top of porticus which is uh
providing the intense infrastructure for
this and why is this important uh for
Paras swap Paras swap is leveraging
Paras swap Delta the trading the intense
trading solution and this enables our
users to uh trade gasless and trade with
Meb protection with it would it wouldn't
be possible without
intents um so and and it's not a
coincidence that we are all sitting here
because we are partnering with between
all of all of our protocols uh to
leverage intents and to bring uh better
user experience uh in different use
cases so having done this uh these
introductions what uh where where
probably we can start is we know intents
uh will be uh or are tackling the most
important important or one of the most
important challenges uh in defi which is
user experience
so besides tackling this issue and when
we simplify with intense complex
transactions or complex operations we
are lowering the entry barriers for new
users and we are also lowering the
existing barriers for existing users so
what I wanted to discuss with you is uh
how are you seeing intents improving the
user experience in your protocols and
from your perspective which kind of
barriers are we lowering for new
users yeah so um I think the first step
is starting with like breaking down kind
of like what are the parts of this like
intent based user flow right you already
said it um for the most part um
important parts of it is a gasless
transaction um it is um a signature
based transaction scheme um and then on
the other hand um what is almost like
equally used with the word intense is um
the term solver which basically is some
type of entity call it a market maker
routing mechanism or whatever that then
is able to actually fulfill these
complex order types or sess liquidity um
that we're talking about right um um at
leafi where we're mostly interacting um
in a cross-chain environment um for us
the most important Point probably is um
that gas abstraction um we actually
going to launch um our own version of
gas abstraction in the next two weeks
probably um and also we are integrating
a gas zip into our routing um and and
use that for gas refueling on on other
chains um which if you're interacting in
a cross chain environment is very
important because you might want to
trade on a chain um that you've never
been on so you don't have any gas in
your account there um so this this is a
very complex and difficult problem or it
used to be a very complex and difficult
problem as many of you probably know um
so for me those are kind of the most
important issues that we can um solve
with intense um and then there's
probably more complex use cases um on
top of that that these two teams are
tackling which yeah they can talk
about yeah well I can continue because I
can take your point in reaching more use
cases which is basically what we're
aiming by using the well the mimic infra
and by partnering with you guys is the
possibility to scale on that and the
whole that decentralization but it's
really like important for the user to
know what it what it needs to be done so
if you know what action you want to take
what intent then all the rest can be
taken careed of and that's what defi is
about and that's what we're aiming with
this not only for users that know how
dii works but for those also that don't
know about it but want to get into so if
you know what slipage you want to set
what first goal you want to set and that
makes it much easier in the whole
interaction yeah so um for us at orbs we
have um I mentioned at the beginning
that we have an onchain sort of
aggregator it's for spot markets um and
we actually integrate that directly with
Dex uis um so it's called liquidity Hub
it's on um quick swap uh uh spooky swap
on Phantom if you guys remember that
there's a phantom chain and it's not
just a wallet um I got as that earlier
that's why I'm chuckling about it um as
well as um Thea on BMB um and so when
users come to swap on these dexes um we
do an RFQ on the back end on on orbs
layer 3 rather we call I don't know we
call it a back end um and that uh kind
of abstracts the complexity of having
users need to go to an aggregator um and
and search for the best price themselves
um in addition to this um we also have
gasless transactions as I think everyone
else up up here has mentioned um and I
think these two things are are really um
kind of the core the the underscoring of
of what we're
doing great so uh
it's a it's not a coincidence that the
three of you mentioned uh abstracting
complexity from users uh from different
different different in different ways uh
in order to make their lives easier uh
and maybe not have them deciding on
things that they don't care that much or
most users don't care that much and
myself personally I have found myself in
uh not having gas on the destination
chain when bridging and that blocking me
from doing whatever I was trying to do
having to set up lots of uh uh
configurations that probably I don't
care or I prefer that someone else
decides for me um and when using
different dexes uh not having to maybe
go to a meta agregator but rather uh
going through something like a liquidity
H so I can I can get a better a better
quote and so I think we are on the path
with intents on different protocols in
different ways uh to simplify this uh
experience what um what I see from from
my personal view is I see lots of
protocols that are uh adopting intents
uh and this is kind of uh it has come a
rise it has become a race of uh speed of
innovation versus scalability so
deploying intents or implementing in
sense uh it's not easy it's not
something that can be done from one day
to the other so what I wanted to to ask
you is about your point of view
regarding the speed of deployment the
speed of innovation versus the um
scalability and how to design scalable
solutions that can leverage intents in
the future uh have you have you found um
how you find trouble implementing this
have you find trouble in finding Scala
Solutions and how did you sol
those yeah um I can start um I think the
the way that we look at that um is
probably the one where there's the most
problems with this as our like frame of
reference is kind of a multi-chain
environment and um I mean it starts with
just like it starts with finding
something that can work on um all the
chains that you want to be on right and
let let's maybe start out just talking
one execution environment let's say we
we just stay within the evm even then
that means if if something like Lei is
you know expanding to new chains and we
use something like Gip for example to um
have this kind of like refuel feature
that means that
um Gip needs to scale with our own
expansion right so we are mostly an
aggregation protocol so we don't build
things ourselves necessarily but more
and more so we found ourselves in kind
of that tough spot where you have to
start building things yourself or you
have to build something that's more
similar to a Marketplace which is kind
of like what Paras is building um to
attract solvers to attract agents that
can execute these transactions across
many many chains so when we start from
um obviously we have S Pathways that are
very crowded right like every solver
wants to solve on bass every solver
wants to solve on arbitrum every solver
you know eventually wants to solve on
like bar chain or Monet whenever these
chains are launching um for the more
long taale of
chains um that's probably more difficult
um there might have to be different
solutions of how to do that and then the
other issue of scalability that comes to
be is
like how do you do that cross different
virtual machines um and how do these
agents and the protocols that have the
marketplaces start talking to each other
across these environments and then we
have to go into something like message
passing um we have to go into something
like building multiple versions of these
protocols so um I think when it comes to
this end of the scalability we're still
pretty early um and nobody has like
really figured that out yet but um if
you think about it we just talked about
how these intent types basically make
the ecosystem much more much easier to
use where ecosystems where you don't
have all these things yet you kind of
it's It's kind of the similar the
difference between a transaction and
intend right is like you have to find
the pathway yourself still which makes
it like much harder to navigate these um
so yeah I think it's it's in some ways
if somebody can build something that
abstracts all of that away across all
these different environments that's
probably like the Holy Grail of that
entire Market of like liquidity routing
but it's a really really tough problem
solve okay so you are focusing on the
composability of that uh of that
ecosystem besides improving the external
experience for user you are also
focusing on improving this composability
for the protocols that need to connect
to to to yeah like just think about
something as I said earlier we support
Solana evm and Bitcoin but that also
means that currently the user has to um
use three different wallet types because
you need a phantom wallet whatever on
Solana and then you need a Bitcoin
wallet need whatever you're using on the
evm um the end game of this is to have
some kind of signature abstraction game
that allows you to basically compose
signatures across multiple chains
probably with something like ZK proofs
or MPC or whatever you um prefer
cryptographically um and that's kind of
like the next level of intense in a way
because that's kind of what you guys are
doing right you abstracted it on DVM but
the next level is how do you make it
even more composable across these
different ecosystems that's
correct okay so the way we see it is
more about if you want to like lower
that barrier entrance maybe you need to
think it as for example if you're in a
room you want to communicate to another
room if you feel like like two isolated
things right if you find the way how to
communicate with those like
then you can communicate to others too
right and you can get to more and more
and more places so it's about looking at
that connector and it may happens all
the time with all of our times we have
and all the people that want to say hey
I want to automate I want to do this and
that we act as interm medaries to the
solutions so intents for us are that
that looking for that path that
execution plan that you want to have and
seek the best way to get all those
connections and get to more and more use
cases scalability calization all so kind
of uh standardizing those connections so
using the same connection that you have
from one room going going to the example
from one room to the other but also to
connect other other partners for you for
example yeah it's kind of like like Kno
how we have in like it happens with some
protocols and then we can like have the
experience that we have with one and
then standardize it in order like to
reach more and access like more
information on
that great
yeah so for sorry so for us um I think
the biggest thing was um for for
liquidity Hub um we'd have um dexes that
really really want to integrate um the
the the protocol on on their UI but then
you know when we look at the actual
chain itself there's maybe only one or
two um solvers there that are that are
facilitating orders on on the on the
Chain so for you know for something like
polygon where um you know we have
everyone added um odos open uh oos open
oer par swap obviously um and offchain
liquidity as well it's like very easy um
but like what D is saying when you go to
these like further and further out
chains where there's just not as much of
an ecosystem buil built up there um you
know there there's there's only so much
uh there's only so many pools that you
can that you can reach um and you know
and then taking that one step further um
you know to bring offchain liquidity
into the these pool into this
Marketplace is even like another crazy
step um and and requires a lot of uh
development effort and and and OB
obviously Capital um so from our
perspective um that that's been the
biggest the biggest and and most
challenging hurdle but it actually I
think it actually makes sense that you
start with the let's call it the lwh
hanging fruit where that you can
integrate easily and and fast and then
you move into the more complex but
probably the ones that will that you
select or you priority the ones that
will be adding more value uh to your to
your ecosystem and you focus on on
implementing uh those um thank you uh if
if I may add here something that I think
it's important for scalability and it's
a concept that that we didn't mention uh
it's the concept of modularity so I
think modularity is going to play an
important role in in the intense uh
scaling um for example the the
infrastructure that Paras swap is
leveraging to enable intents uh it's a
modular infrastructure what does this
means it's uh it means for example that
the swap module that Paras swap it's
module that was built exactly with this
use case exactly for this use case uh if
we want to enable other uh modules then
we need to develop that module and it's
probably easier to escalate things by
module rather than just escalating all
the use cases uh at once uh so I think
uh modularity will play an important
role because you can think about
modularity then you can start connecting
the different modules and I go to the to
the connecting rooms that you were
saying um if you start connecting
modules and each module enables a use
case let's say uh swap module Bridge
module cross chain module uh you can
start mixing the usage of this module to
enable different features uh on the
different protocols UI so I think that
would be an important concept that at
some point it's going to be uh more
spreaded around the intense
ecosystem um now now I want you I I want
to take you out of your protocols uh
and make a question that it's more
related to more related to the general
experience through intents so when we
when we talk about simplifying user
experience uh taking the specifics out
of the hands of the users and leaving
that to a third party I kind of feel
related to a web two experience uh where
we have centralized entities centralized
actors that decide for the user that
take complexity out of users but decide
for users so at some points I found
myself talking about intents and remind
me of the experience we have in web to
so how how do you think we should find
the balance or the switch spot of making
users experience better easier but not
losing or not uh yeah not losing the
decentralization that Defi and ethereum
have already uh established as a kind of
standard yeah I mean I mean first of all
if we go from like the solver-based
system um generally it takes a lot of
risk out of um or away from the user
because
um the way that these um systems usually
work is a solver basically more or less
instantly fills prefills um the
transaction that the user requests um in
kind of like an RFQ system as you said
and then um on the same chain obviously
they're usually more or less Atomic so
there isn't too much risk there um once
you go across multiple chains um there
might obviously be some kind of finality
problems and now the solver takes on
these finality risks that the user um
had before and um the solver as a more
professional Market making entity should
be better equipped to
basically calculate um this finality
risk um and then settles through some
type of you know intense settlement
layer mechanism um so I think from that
perspective there there isn't too much
risk for the user um I think where the
risk
becomes more prevalent is when we start
thinking about competition as you said
earlier um on a chain um that is smaller
um there might only be like one or two
solvers okay one solver I think
everybody here can see the problem with
that it's basically a monopoly so the
solver can just quote you and obviously
he has an information advantage over you
unless you're very sophisticated you
don't really know if that price you're
getting quoted right now is a good price
for you or not unless you go back to
basically doing all the research that
you would have to do yourself in a
transaction um based um system but even
let's say if there are two or three
solvers um
the the problem of collusion could still
be pretty prevalent where the solvers
just basically talk to each other and
they're like hey look let's all just
like quote a little bit higher price and
we skim some money of the user and then
we share that in the end so for solver
systems to actually um sufficiently work
we need a competitive market and
creating a competitive market is um a
question of
you know demand at the end of the day if
there's enough demand then enough
solvers will show up um but also on
their end it becomes about like
scalability of infrastructure again
where you know demand might pop up
anywhere at any point in time and a lot
of that is like uninformed flow in a
sense so I think Dux can look good but
it's kind of like getting scammed in a
taxi you know you really have to know
the environment like if you guys grab a
taxi here in Thailand you're not a local
you don't know the prices how would you
know if you're getting scammed right now
or
not so uh you would put the focus in
decentralizing the the whole
infrastructure I would say or increasing
the the competitiveness of the
competition increasing I think yeah
competition is more important than
decentralization from a perspective of
you know like competition could also be
great between tree solver if the system
is designed well enough that they cannot
collude with each other so yeah
designing the system in a way that keeps
everybody competitive of each other is
very
important makes sense thank
you um the way I think about it and
short experience I have like um well
recent experience in web 2 and and not
web free is that user experience is
really important in web to but for web
free it's getting there it's improving a
lot but if you need to risk something
will be that and the main focus should
stay on
transparency and that's thing with and
everything but it's really important to
be transparent and if there's
competition and everything and
everything like keeps going forward and
we improve and we get better in models
and everything I think that that's like
the most important thing that we should
focus and especially when we're doing
this kind of things right and it's like
money from others and you could put the
Uber taxi example and the taxi we know
it really well the Uber not so much so
it's like def defi we don't know it so
well so if it keep transparent and it's
better and it will get you more users
eventually one one maybe one more point
that I just realized um adding on to
this is the advantage that blockchains
don't have is once the transaction is
settled and inscribed in the BL chain
it's there so that data will be
available forever so unlike web 2 where
maybe we have that kind of obscured and
we don't really know somebody could
actually go in and kind of prove to you
later on that you were getting scammed
and this is a huge Advantage obviously
that blockchains have over like as an
open system over maybe the more closed
systems in web
to if if I may if I may complement uh
what what you are saying um it feels it
feels a bit like uh we are simplifying
and taking complexity out of users but
at the same time we need to be
transparent about how we are building
the protocols which can be which can end
up being more complex for the user to
understand I think
the the the point here is that we need
to make sure that the infrastructure or
the uh or the ecosystem is decentralized
or it has enough
competitors so they cannot collude or
they cannot screw the users but uh it's
more for making sure that the user
experience is going to be good rather
than to explaining that to everyone or
to the users because uh I don't know how
how how we would explain how a complex
system like an intent system worked to a
retail user for example I I don't I
don't know how we would find the way
I think um I think ux is super important
and like I don't I don't think anything
that I I don't think necessarily that
you know you you never want to at least
with intense you don't want to ever
compromise that ux that users have now
at least um you know you have a better
price so you want to keep the better
price and you have this better user
experience it's better than having to to
search for it yourself it's it's much
easier for for for everyone I would say
just to add on to what everyone else has
already kind of echoed but um just just
just the way that these Protocols are
designed to make sure that they they're
open um that there's clear documentation
so that there's not it's not like an
airline industry where the barrier to
entry is like you know it's not possible
um so you know if someone wants to be a
solver if someone wants them um route
liquidity if someone wants to if a
market maker wants to earn uh money this
way that that that there's clear
documentation um and that Protocols are
set up to U be open you know and and
have these these ethos that we're that
we're kind of discussing and
decentralizing ation um so that they can
easily easily do so but I think like a
pattern that emerges here is like you
just said we're taking complexity away
from the user we're giving the
complexity to the system so you know
there's no um in you know in alchemy
there's like the the concept of an
equivalent exchange you know you can't
you can't just like gain something
without losing something else so you
can't just make you act like super good
without with without increasing the
complexity somewhere else right but what
we're basically doing here is we're
taking that complexity into the back end
and as you said for for example like you
want to keep that system open okay that
sounds great like right we all want open
systems but now let's what happens for
example if you keep the system open a
solver says I'm going to fill this order
and then doesn't fill it right so like
that means now now if you keep the
system open that means you need to
implement something like slashing and
then it becomes kind of a a game of
consensus where you're almost
basically you're kind of building a
blockchain at the end of the day you
build you rebuilding consensus into that
in some way because you have agents that
are kind of like validators in a sense
and they do certain tasks and you have
to make sure um that they can be like
properly incentivized and then also
properly um you know slashed or whatever
if they misbehave which I mean in in
some ways it's great because you it
means you can add a token onto the stuff
at some point you know but but you went
from from infrastructure to uh kind of
Economics of the of the of the protocol
yeah that's that's what I do
sometimes um okay uh we have uh we have
few minutes left and I want to leave uh
some time for for questions so my last
question would
be I believe that the intense ecosystem
it's uh just starting so we're probably
going to see a lot of innovation in the
future so uh where do you see this
Innovation happening in the short to
midterm uh and also how do you balance
this uh with security risks that may
come uh with new features new products
um or new uh improvements that intents
can
bring uh sorry so I think I think um so
looking ahead I think um we're now kind
of building at orbs anyways we're we're
we're we think that the next thing is
onchain perpetuals um so like if you
look at like spot spot Market to sex
volumes it's like I think about like I
don't remember off the top my head but
it's it's significantly more than it's
huge yeah it's huge it's huge on dexes
it's it's much larger than the than the
percentage of um Perpetual trading
happening on dex's um which is about
like 1% and the other 99.9% is on is on
is on centralized exchanges um so we
think that there's like one there's a
huge Market opportunity here uh people
want to trade um uh per on chain because
you know there's a lot of counterparty
risks that you have with Sexes as yeah I
don't I don't think we need to go down
memory lane um so we can skip over that
for now but yeah yeah so I think that
for us this is kind of where we're
headed in in this
direction um and yeah in terms of uh
security risks it really just depends on
the protocol at the end of the day so
yeah is that uh kind of an alpha that
you're giving I mean you could take it
as that it depends on on how you want to
look at it um yeah I saw something on
Twitter that was like I think it was
like the GMX model is like um like like
some of the pools are getting like
locked or something as we're in like an
up only Market um so you know intents
are potentially potentially the way the
way that that that it's going to be yeah
I mean there's a lot of Builders around
it still so so yeah thank
you okay I'm going to bring a concept
that eventually was going to be in our
conversation it's going to be
Ai and with nimic right now we're
building a free layer protocol with
intents in Ai and the idea is to create
the best execution plan in order for the
user to later have the control and like
delegate what you want to do and
everything but then you have the control
to sign and then execute it so that's
the main role in security that we have
and super important because we want to
give the user that control but we also
have all the track record from before
we've been in the market for three years
we know how stuff is done and we know
how's the best way to with the mimic
safeguards to have it all like backed up
and making sure the user doesn't need to
worry about that because of course it's
like it's a concern everything but it's
like you want to have someone that
that's got your back so that's like the
the main thing for us and that's what
we're building right now and we're
launching the protocol because we're a
business to business model and we've
been with that and we're going to
continue with it but we want to give the
opportunity to more users to build on
top of the protocol and connect and be
able to to bu this stuff yeah do we have
a date for the launch of the protocol
it's going to be next year okay you can
like check our socials and we're going
to be sharing more information sorry I'm
from com so of course I'm going to say
that but okay thank you but yeah it's
coming soon and it's going to be good
cool you you the last one to give us
some Alpha okay um yeah I mean I think
the alpha for any type of protocol that
is within the interoperability space um
is pretty much the same um I feel like
every protocol is working on like some
level of First Chain abstraction um I
mean that's something that we're looking
into I I do not really like the term
chain abstraction itself I think it's
more like chain agnosticism um because
like chain abstraction means that the
end user doesn't care about the chain at
all but like with the current state of
crypto that's not really true users do
usually still care what chain they're on
tribal reasons for reasons of like
wanting to farm something uh for
security reasons um so um I think we
want to at least give um users and that
also means companies that work with us
the ability to be opinionated about like
completely abstracting this away or just
partially abstracting this away and then
the other thing that I talked about
earlier a little bit was like going into
virtual machine abstraction like and
that's to me is like the end game
actually um having a unified experience
of accessing all of like the crypto
World um and yeah as stated probably
some kind of proving schemes um
hopefully ZK proofs becoming cheaper is
going to play a huge role in this and I
think in like the
next let's say 18 months we're going to
see like the first truly unified
accounts like you know people use the
word unified account right now but it's
really just an evm balance um but like
unified account across all um virtual
machine
environments great thank you I think I'm
I'm the only one missing to give some
Alpha uh but as is also related to AI so
uh AI agents are plan of are part of our
of our road map uh think of an AI agent
as an entity that can execute complex uh
strategies uh in in favor of the user so
imagine uh DCA on on a on a certain
token so be able to buy in at certain
points of time and doing this leveraging
the security and the decentralization of
intents um so we are also going into a
AI through through
intents so I think we have a little gift
for you uh we prepared a Boop for the
talk uh I hope there are some po lovers
so uh you should you if you have the
poop app I think you can scan this QR uh
to get a memory of uh this panel that
you just attended so uh besides thanking
you for attending this uh panel I want
to also thank you uh the three of you
because it was a a very very good talk
uh and now maybe we can have some
questions if there are some
hello yeah uh my name is Jason and uh
and the topic about the intend tread is
interesting uh so uh I'm I'm very new
here and I just have one question is
that uh uh why you uh when you do kind
of uh intend trading uh does it mean
that you shift the uh you know um on the
uh on the kind of uh risk of uh uh
centralization to the backend system and
uh and as as I know uh using backend is
quite uh you know very um uh using back
back end in the system would bring the
best uh user experience uh in trading
but it will bring some downside and I
just want to hear more about it because
uh it's very important to us to improve
our user
experience you do you get my question
it's about you're asking if we are uh
leaving the centralization for the back
end better than all the other ones and
obviously if you're talking from a
solver perspective some of these systems
are going to have more Network effects
than others um then yes there is
definitely like some kind of
centralization risk that like a winner
might take this entire Market but the
thing is like as we said this back end
will probably be some type of chain with
some type of consensus mechanism um so
if you look at it from that perspective
um it's more of an uh it's more of it's
more of a a competitive um get quotes
from the
system uh if I may add there I think
uh there will be improvements on the
decentralization of the intense existing
systems
uh I think that today uh it's difficult
to fully decentralize uh an intense
system mainly because of the risk that
we describ here that uh you cannot
ensure that suddenly from one day to the
other you have a thousand solvers doing
whatever they want on the on the system
um but I think it's going to be
Progressive so today we are here on the
decentralization uh the the intent
system are going to slowly start uh to
decentralize the different parts of the
of the back end until we have until we
find a solution that it's completely or
almost completely decentralized I highly
doubt that at some point you won't have
any API to access that it's not
centralized but I don't know maybe maybe
I'm wrong thank you for the question so
we have two more questions here so the
next question is are intents the future
of all of defi or are there use cases
where smart contracts are still
useful any of you can take it
uh I think I think both can coexist uh
both use cases might be uh able to
coexist um there are today some use
cases um I don't know flash loans for
example that might not be might not be a
good fit for intents or how the intents
uh systems are working today but I think
it's uh at some point there it's going
to be interest or prioritization of
these kind of different use cases uh but
it's going to be one by one um so I
think they might they might coexist uh
in a world where um where both use cases
can can still uh have I actually think
they have to exist right like because
liquidity it is still going to be in
like Unis swap unless it's like an
offchain unless everything becomes an
offchain ofq system which might happen
but like even then let's say you want to
borrow some money then you have to go to
AA you want to do some kind of Y type of
Vault stuff that you like basically
intense and smart contracts are just
they're not really connected in that
sense right smart contracts are
protocols or nowadays also accounts if
we talk about account abstraction and
something like that the intent really is
just the way how you express your
preferences that that is what an intent
is but that that isn't necessarily
connected to Smart contracts in anyway
smart contracts are how we build
um expression of something on chain it's
just like a programming language thing
at the end of the day which the other
thing is like what do I want is a
preference um
expression okay so we have one more
question are Merkel trees the answer for
cross chain
intentions again anybody can take I
honestly I I don't have an opinion about
the how to solve the cross chain
intentions uh I mean merries are
probably going to be part of it um in
expressing certain things as I said
earlier I think the answer for cross
Shain intentions are probably ZK
proofs okay yeah that makes sense uh so
we have a question from there yeah just
just a question like do you see intense
in anything beyond D other than D have
you seen anything any intents being used
Beyond D5
I have heard about some use
cases but all theorical I mean I I never
saw them uh really implemented but I
heard uh and I've been pitched about
some uh like real world use cases where
you can I don't know rent for example an
apartment with u uh with through intents
um but I think we're are not there yet
uh I think
I'm sure that we are not there yet
because we are not seeing them being uh
implemented in that way but I think it
can it can be uh work it can work for
other stuff besides defi besides uh I
don't know lending borrowing besides
those use cases I think they might work
at some point I think the technology has
to uh has to evolve in order to take it
to other to other places I mean if you
think about it like Skyscanner is an
intent-based application you go in there
you put a flight in and it says you it
gives you I mean the difference between
intent in in some ways would be the way
we see intents is like the solver just
fills you the best one and like in Skys
scanner you get a couple of options of
flights but in similar ways how lei for
example works today is you go in and you
say I want to go from asset a on chain a
to asset chain B on chain B and we still
give you options we just don't pick like
basically we we're not an opinionated
solver as to we don't give you one
option we give you multiple options that
you can pick from but that's still you
still give us an intent and we process
that intent and like every type of
aggregation protocol in web 2 more or
less works in the same way like I want
to buy an insurance and then an
insurance aggregator gives you you know
a couple of options so like intents are
not in any way web tree specific they're
just like a way of solving um user
experience I think uh that will down on
your example of Skys scanner something
that intents my soul for example is I
want to travel to this destination for
this amount of time and I want to stay
in these places and have the whole
solution built for you like book your
book your airplane tickets book your
hotel uh book the stuff that you want to
do and reserve your uh your dinners or
lunch in restaurants that would be like
the uh the the ideal world of an IND
intense um I think it might it might
happen at some point but I don't know
when or
how yeah maybe you can say something
because that's kind of the AI use case
at the end of the day The Skys scanner
thing
was I used to use it like all the time
but yeah I mean intend is and intention
I mean it depends on what context it is
but defi the Brad and other like cases
yeah we're not there yet I think we'll
see but
you want to say something I think we're
yeah I think we're good we agree we
agree say goodbye yeah so any more
questions we have one more minute
here if not we can thank the speakers
again thank you so much for the
wonderful talk and thank you
there is another panel or this is the
