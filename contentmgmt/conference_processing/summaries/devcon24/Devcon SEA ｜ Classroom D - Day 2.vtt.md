[Music]
for
[Laughter]
a
w
[Applause]
oh
n
o
back
black
e
ch
sh
okay cool oh
Showtime
cool good morning everyone thanks for
hanging around for a few extra
minutes when you're ready switch over to
slides please thanks very
much um welcome everyone to prize worthy
an ethereum python hackathon
guide briefly some introductions I'm
Mark or WM
online uh joined the EF in
colleagues Carrie Stu Felipe and Paul
and with our powers combined we form the
EF python tooling
team so what that means is uh we
maintain web 3pie and a collection of 20
odd other open source free and open
source libraries
all in the python sphere and our team is
focused on uh three Northstar goals for
the next um foreseeable future at least
early next year um relevant to us here I
hope that something we do here today is
in service of this educate and Inspire
Builders uh goal here my hypothesis uh
relevant to this week is that a
hackathon is still the best way to
launch a career a product a company in
this industry so my goal for you within
this context is to give you bit of a a
game plan a road map for how to make the
most of python tools within a hackathon
environment um and have you feeling a
bit excited about trying out some new
tools in the python
sphere
um let's see if we can get anybody here
a little bit of value right out of the
gate um is anybody like hands up if you
are attend in E Bangkok this
weekend a smattering Cool Hand raised if
you are potentially looking for a team
or if you have a team and potentially
may be looking to draft some more
members to your
team couple few okay this is who you
need to meet at the conclusion of this
Workshop job done okay why hackathons
why is this still such a good use of
your time um the obvious one is prizes
uh but also very importantly uh
mentorship is awesome at these
hackathons you'll have staff level
Engineers like waiting for you to uh
walk up and ask them some questions
similar vein you're likely to meet your
next employer or investor at U one of
these types of events um peer networking
is actually fun and meaningful in this
context if you share what you're doing
you can build your own reputation as a
builder uh learn new skills at the
bleeding edge um
undervalued uh skill in every industry
is learning how to better present your
ideas and if you're the entrepreneurial
type you'll find out if anybody cares
about what you're building all within a
week in a lowrisk
environment uh so so this pitch is kind
of aimed at the a
more newcomer audience but for those
who've been around a while the same
points apply I encourage you to get back
out jump into a
hackathon um have some fun get out of
your comfort zone uh once in a while and
then oh yeah did I mention there's a lot
of money on the table so game plan um
what's in store today is uh we're
actually going to air quotes build a
priz worthy hackathon project here today
or at least we're going to talk through
it um I'm going to interject some
personal protips as well some that have
crowd sourced around here as dadan says
they call it a hackathon because you're
literally hacking your way around a dark
Forest of deprecated code unreleased
features and out ofate docs and honestly
I wouldn't have it any other way you are
kind of doing the industry of service
here by battle testing the bleeding edge
here and that's a good
thing um and in this talk we're going to
use a hackathon project that um a couple
of my colleagues and I built at a recent
hackathon um that went on to get
recognized for at least a third price
third place prize in one of the optimism
categories so prize worthy credibility
established every hackathon begins with
an
idea or does
it I encourage you actually just to sign
up before you get to that point because
it's a normal pattern everybody does it
the tldrs you're going to figure it out
or join somebody who
has now that we've gotten that out of
the way where the good ideas come from
might be helpful to think about them in
the context of different buckets these
are most of the prizewinning projects
I've seen come from either Dev tools
consumer apps or this kind of catch all
category data projects which could be
described as um visualizing blockchain
data in a way that's actionable or
meaningful or sheds light in a new
way um best case scenario though is you
scratch your own itch so as you're doing
your day-to-day keep an eye out and log
like apps and tools you wish existed
pain points that you come across and
then you can watch out for other people
doing the same thing on social media
here and then reference that log as you
approach your next hackathon um e Global
has a project showcase
page um some events include idea
brainstorming and team formation events
and then uh sponsors will tell you more
or less exactly what they're looking
um participation opportunity here does
anybody else like to find Opportunities
or ideas somewhere else any ideas come
to mind and I have a bribe I got some of
these um snaky mix snake face pins they
are NFC tags so if you scan with your
phone it'll bring you to the web 3 docs
web 3 Pi docs but you can reprogram them
to your own
thing going
once nailed it somebody to give him a
pin any
others good
enough uh so you've got the kernel of an
idea uh um how do you know it's the
right
one just some first principles thinking
here um who's it
for start with the who always what's
their goal what do they want to do um
how do they get there today and how do
they fall how do those options fall
short and then now the big reveal is
options that you could provide to
improve the situation so if you apply
this small framework and are honest with
yourself about what you're building
asking yourself some uh to the point
questions you should have a good idea
here does the user actually exist Does
the problem actually exist uh does does
your
solution reduce some barrier to entry
there and uh if you answer yes to those
questions then I think you're you're
good to
roll um So Pro tip I think it's natural
for people when they come across an idea
that they're excited about uh to to
guard it and potentially
not share it in the fear that somebody
might take it and run with it or
something to that effect um but I'm here
to tell you that the same types of ideas
are built at every hackathon that's okay
execution is everything it's likely that
you're going to Pivot once you get out
there anyway so get like let's make that
happen earlier in the process and then
if you share your idea out there you're
likely to um number one potentially
rally some teammates around you um but
it's also an awesome idea to get on the
judge's radar even before you get cook
in here so I love this Pro tip from
Manny ideate and validate right away get
the idea in front of the judge and gauge
the reaction if they're not loving it
there's no amount of love you can give
to this project to win get the judges on
board so they're excited to see your
project and you can do this before the
hackathon even starts or right as the
hackathon starts kind of
thing um so that's the good
stuff um if anyone's brave enough I was
going to invite you to do it here if
anybody's got an idea this thinking
about for this this
weekend um or maybe a hackathon
next this is a real on the spot thing is
anybody feeling
brave I don't blame
you okay let's talk through it from
popup faucet the uh the prize winner
that my colleagues and I worked on so
POA faucet um this is a scratching my
own itch sort of situation as a Workshop
host I'm looking to make sure any
attendees uh can get test net ether in
order to participate in some event I'm
trying to um help them through um so my
goal is to efficiently get that test net
ether into their
hands and um as a as a host of a
workshop I got a million other things
I'm planning I need this to be simple
easy
reliable what are my current options
um there's a variety of them out there
I've seen people preed accounts like cut
out physical QR codes to hand out to
people um when I say faucet what's the
first word or emotion that comes to
mind pain pain is pain is the right
answer yeah a test net faucet there's so
much pain associated with
that um so there there third like
they're they're they're external points
of failure right so some of them have
daily limits you might exhaust um some
of them might try to get you into like a
marketing funnel where you have to
create an account all this kind of stuff
um a lot of them just suck um and then
you got other options here um but for
the rest of this Workshop we're going to
try and talk talk through um the
solution that we came up with and um how
python tooling makes it happen
sound
good this is my caffeine
break all right the first
obligatory uh image here for those of
youve been in tech for long enough you
might hate this image this is from like
the The Lean Startup movement and the
whole motivation behind it is um to to
discourage waterfall development so
building a bunch of pieces in isolation
putting together at the end and hoping
it works this is an especially bad
strategy for a
hackathon um the encouragement here is
get to a get to a happy path as soon as
you can working software needs to be in
front of
judges um when it comes to like a we
weekend long hackathon like you got to
basically focus on proof of concept here
so you're delivering like the skateboard
or the uh the scooter version of things
in all
likelihood um as Steph puts it um follow
the keep it simple uh Stupid the kiss
rule get a solid MVP or happy path for
your app before you start to hook in
random bounties or get yourself in
trouble
elsewise um that that established let's
chat through the the popup faucet um
kind of mapping of the the diagram of of
what we're going to be building here so
starting from the UI um the question I
ask myself is what's the least possible
friction here as a workshop host what
can I what can I get away with
essentially
and I would love to be able to just tell
a system I I'm hosting this event give
it like a unique event code and then
send some um test net ether to an
address and be done with the thing an
attendee then can come along and use
that event code as like a password of
sorts and specify the address they want
this test net ether sent to and that'd
be the end of that
story um knowing my users are are python
developers I feel comfortable um meeting
them in the command line via like a CLI
app and distributing that um getting it
into their hands via python
package and you know as important as
what we're building is what we're not
importing or not
building um contract I want this to be
accessible to um not just myself but
anybody to come and spin up a faucet for
so I'm looking to build one smart
contract that can handle an arbitrary
number of faucets it needs to at least
have a couple of pieces of basic
functionality creating faucets and
attendees need to be able to drip from
them and then that contract needs to
keep track of essentially which faucets
exist and how much funding is available
for each of them to DP
from and again we don't care about
security or gas efficiency for um
hackathons and doubly so because this is
a test net product
um there's a missing piece here if I
want to accomplish that level of user
experience the contract interactions if
I'm not going to have the workshop host
or attendee do them themselves and I
need to make that happen elsewhere so
we're going to introduce this third
server component a server can also
handle some Secrets like um the admin
private key if we're going to sponsor in
effect those test net um
drips and then for connecting to an RPC
URL we can stash that away
too um this an important takeaway for
this exercise is that um a common
misconception is that you know in order
to build adapt every bit of the
functionality needs to live within a
smart contract um decentralization is a
spectrum um This Server does not
preclude anybody else from using the
contract um I'm just introducing the
server to give like to provide a nicer
user experience should you choose to use
it so for the visual Learners um
starting with like the the user
experience here it's as simple as a host
uh entering into a command line app I
want to create an event uh with a given
name event one two three the server
responds back great send that test net
ether to this particular address and
then give you a success response once
you've done so then attendee will
complete the loop basically by saying I
want to drip from this particular faucet
and here's the address I want that sent
to
and have it happen so as far as the
users are concerned they don't have to
care the rest can be
magic um but for our sake here this is
what the full
inpl um Can will end up looking
like um so our server um
the the takeaway here is that the the
CLI can be um completely naive it
doesn't have to know that a blockchain
exists doesn't have to have an import of
web 3 Pi or um much else for that matter
it just needs to know where the server
lives and what endpoints live the server
then can have um will be blockchain
aware basically it's got a web 3 Pi
instance it knows where the contracts
live are deployed and um it it does that
interaction between um the contract and
the
user so we'll get into some of the
specifics here um as we go
along
um I think that's a sufficient starting
point contract so we're going to start
um by building the contract
first um getting to some of the fun
stuff here the next few um let's say
three is Chap are going to be more code
heavy we'll look at some examples um
look at some some fun little bit of
experimental tooling as
well um but just a little bit of context
here um this is liable to ruffle some
feathers but in the context of a
hackathon um a lot of cases like your
stack choices aren't that
important I'm going to skip to the the
punch line which is just to be clear
about your goals so if you come into a
hackathon with a goal of learning a new
technology say viper um do that if your
goal is to ship a consumer product and
try to win as many bounties as possible
then in all likelihood the judges are uh
not going to care anywhere to the
nearest like to the same extent about uh
what underpins that they're looking for
the the user experience whether or not
you delivered on on those promises that
you set out to
tackle um as
Billy puts here um very few judges are
actually checking the technical backend
workings and take the project to face
value Maybe dirty little secret but this
is like just a practical consideration
right every judge isn't going to go
around and audit your smart contract
because it's it's
impossible U so focus on what matters
presentation plays an important role
here and we'll get into that a bit more
as well another Pro tip is to take
shortcuts there's some awesome building
blocks out there um in each language um
this list of resources um there there is
a companion blog post to this Workshop
so um you can safely ignore this list
and uh I will give you access um to all
the resources in this this Workshop um
there'll be a QR code at the end here
but the point here is that it's not like
plagiarizing to use these building
blocks that's what they're there for um
make sure you give them any appropriate
shout outs and respect whatever license
they've got but um that's their
intention to be used as building
blocks um so we're going to do a little
demo um May the live demo Gods be in our
favor so we're going to talk about a
couple tools first is um snco this is a
tool um I've been hacking on a lot
recently um it's it's we're going to use
it to get off the ground basically it's
a moving quickly tool
and then we're going to graduate um so
to speak into an
ape um so let's let's see what
happens um we are going to be using uh
snco so this is a hackathon worthy
project in its own right um You can
download it yourself now it's available
as a python
package uh via pip install sneo s n KO
once it's on your Mach your machine uh
you can either give it
a uh path to open up some smart
contracts within or just take the demo
contracts that come out of uh as
default um so this little app
is uh made possible by this wild python
package called textual it's a uh a Tui a
terminal based interface
or a text base uh like a text user
interface so you can see that we're
we're in a terminal here uh but we've
got some like hover States and clickable
buttons
and basically a graphical user
interface um and what it accomplishes is
basically uh lets you poke around at and
hopefully understand contracts you're
you're using you're
referencing
um enough to give you confidence in um
kind of taking the next step and we'll
talk about what next step means here um
so we've got support for Viper and
solidity in
here uh there
is code high so what we're going to do
is briefly walk through the popet faucet
contract and solidity here and then talk
through the uh the features of
snco um so real quick the the pop-up
faucet contract is 63 lines in length
and half of that is is
uh the the functionality essentially
that you need to care
about so this contract popup faucet it's
keeping track of a couple pieces of
State um as we've mentioned in the
previous slide or as I've I'm the only
one up here turns out um we're keeping
track of each of the event codes and how
much funding are available in them and
uh whether or not an event code is
reserved um this contract will emit
three events when things we care about
happen a just sets an initial owner for
the contract and then um there is a
piece here we haven't discussed yet
which is uh the answer to the question
like what prevents a bad actor out there
from draining all of the available test
net ether out there and the answer is
that we are just referencing the hash of
the event code whenever code so what
that means is um this is just a helper
function here um to take in an event
code and give you the a 32 by hash of
that event code so it's a unique
identifier so to speak and these these
hash function first engineered right so
um we take the hash of the event code
and that's what we're going to reference
whenever we are um
creating or dripping from a faucet and
hopefully if that's unclear it will
become more clear uh
next uh the create function this there
we go um so when when a workshop host
wants to create a faucet uh we are going
to do a couple sense checks here we're
going to make sure that they've provided
ether to fund that faucet and then we're
going to take the hash of the event code
and make sure it uh is not already
reserved uh we are oh sorry I'm going to
leave that there and then just two
pieces of functionality here to to to
make it all
happen
um we are going to increment by whatever
amount the whatever amount of ether the
host sent in we're going to increment
the available funds of that hashed event
code and we will Reserve that that event
code or the hash of that event
code U emitting an event just makes it
observable now the other side of the
funnel
here uh when we come along the drip this
is in hackathon fashion uh we've got a
hardcoded drip amount
here we do two sense checks to make sure
that there are available funds to
distribute and then we um we do the
reverse of the create R we decrement the
the amount of funds that are available
here uh in the hash event
code and then uh in also hackathon
fashion call is the more efficient way
to send or more safe way to send ether
around but um we then distribute the
funds to uh whichever recipient whatever
address was specified
here so this is that's the the bones
like the the meat of um
the contract right that that
accomplishes effectively the the whole
dance here we've got a topup function
and a couple of uh convenience functions
at the bottom here to look up whether or
not a code an event code has been
reserved or not and how much funding is
available um so that's the contract I am
going to collapse it now and show you
the rest of the functionality here
um when like if you want to interact
with a contract or if you want to deploy
a contract start first uh you're going
to need some metadata um importantly the
ABI and the bike code so snco gives you
this compilation functionality built in
here um but to go a step further
um snco can help you understand what a
contract is capable of using this little
playground tab in the editor um so this
is remix inspired
um what you see Happening Here is
there's a a a web 3 Pi based um test
environment so we're using what's called
eth tester in the background meaning
we've got um 10 of these preceded
accounts and we can use them to for
example deploy this contract in our
local environment and uh you'll see the
remix inspiration here um blue buttons
are read functionality and orange
buttons are right so you can play with
the cont
help you understand what's happening
here this is uh especially useful I
think when you're inheriting a lot of
functionality so if you've working with
a token contract and you're inheriting
tons of
modules um you might like only for
example have a init method in your
contract itself um but this will reveal
exactly how much functionality lies
underneath so we can understand for
example that if um like we create a
Devcon or we're looking to create a
Devcon
event uh code here that it is available
reserve if we do so spelled
correctly um we'll get an error saying
that well basically we need to include
some funding along the
way um but you can see if we create this
event our contract balance increments
the the code is reserved now the funds
available and you can complete the cycle
with the the drip
and um switch around to counts you can
see that our balance here is decremented
because we've used some gas to deploy
the simulated
contract um so that's that's what snco
has to offer um the last piece of
functionality here is is to kind of
Kickstart the next leg of your journey
by generating a a sample
script um and or more robustly an ape
project um so you click that button uh
what is going to happen happen here is
we generate a new
directory
and let's dig in to what happened
there um so you'll get a little Remy to
to explain basically how to get off the
ground here um we're going to do a we're
going to do like the the two-minute
speedrun of of ape here and um my ape
friends over here can tell me later
about what I left
out
um so what you get uh when you click
that generate AP project is a we ped
over the contract so here's pop-up
faucet
contract um you get a scripts directory
and a test directory and a config file
so ape is a plug-in based smart contract
development
framework um it is extensible via these
plugins which we specify here
uh testing very good idea even if you're
in hackathon mode just to build some
confidence
um make sure that if you introduce some
new features you didn't uh include some
egregious regression along the way um
but testing in ape is all done via
python you have the ability to specify
fixtures that you want to use in any of
the test files in this conf contest file
the contract
um so for example we have this deployed
um instance of pop-up faucet that we can
then reference as contract faucet in
this test file here so in the event that
you're testing the the faucet creation
uh we can reference as an as an argument
contract faucet and then jump right into
using the create
function um so these are this is a nice
interface that ape provides to you um a
little uh it strips out some of the the
characters from what you might be doing
directly within web 3 Pi anyway so
contract faucet create we give it a a
name and a an an amount we that we're
seeding the faucet with and then assert
that the available of funds is what we
expect uh similar idea with
drip uh and then finally a deploy script
uh this is a simp will get off the
ground version
this will need an address to set as the
owner of the
contract uh but we'll see this in action
basically this there's a lot of fancy
decorator stuff going on here um the
things you need to care about is this
select account function is is an awesome
handy way to um bounce between accounts
that you want to do any deploying or
scripting with um the deploy function
here will then um do as you expect and
you'll get some confirmation that this
happens so you can get more
sophisticated than this but this is I
would say uh a perfectly great starting
point for hackathon in particular I am
going to hopefully get to a
more sane operating place
here um but if we jump into here just
to give you the the basic idea of what's
what it's like to operate within an AP
project um let's see if the internet
cooperates here
so ape gives you this command line
interface um
we right so
um making your way through ape you have
uh you have the ape keyword that you can
use to uh do the basic set of
functionality which can be summarized is
compiling uh testing and running scripts
which includes deploying so you can
ignore These Warnings here
potentially um but eventually we get to
a place where we where we compile there
you go um then ape test in your terminal
we'll run through those three examples
there we had a smoke test a test of the
creation of the faucet and the dripping
of the of the the faucet and then any
scripts can be uh executed with ap run
so deploy is the name of that file in
there
and then we can
specify uh in network but for these
purposes I'm just going to deploy to a
local e tester
instance and it didn't respect that I
updated
this
boom okay so at this point you have a a
deployed contract um we've simulated it
but it
looks uh
identical give or take to deploying it
to a test net right and so if we want
this contract deployed on um if we
wanted to support multiple networks then
of course you need to run this this
exercise this this deploy script uh as
many times as the networks you want it
to live on um but we've accomplished the
goal of getting our pop-up popup faucet
contract deployed and ready for
use uh from here we're going to look to
do something with that contract right so
we've got um as a result of compiling a
contract we've got an ABI and uh that
bite code um after deploying a contract
we've still got the AP ABI but we've
also got a deployed contract address uh
so what happens next right
um here we're going to detour a little
bit we're going to do a speedrun of web
going to go a little bit beyond the
basics there for part two and then for
part three we'll jump back into the
pop-up faucet server to put it into
action um so we will communicate with
the contract at that
point uh speedrun I want to emphasize
that this is uh the goal here is not to
have you feeling like you understood
every line of code in here the goal is
to make you aware of the scope of of the
tool
here
um you'll yeah if I do this right you
will know like effectively where to look
up in the docs where what you need from
here so if you know three basic concepts
here within web 3 Pi uh you're 90 some
odd percent of the way there uh provider
configuration important part of part of
this and then we're going to do some
reading and writing to a blockchain
so provider
config uh the starting point for most
people is to import the HTTP provider um
give it an address where you're pointing
at to uh a an ethereum node or evm
compatible node and you're often running
so uh you can think of the the Prov
provider as needing um two things right
one is the um the networking protocol so
either HTTP IPC or websockets and then
you got to tell web 3 Pi where the node
lives either on your local machine or
hosted
elsewhere um if you're doing a lot of
data
lookups this is your nudge to to use one
of the asynchronous uh providers because
you're going to save a a ton of time
here another important takeaway here is
that um you use the same web 3 interface
to connect to main ethereum a test net
of ethereum uh an L2 or an L2 test net
um effectively any node that implements
the the ethereum Json RPC
spec um as you saw in snco uh we made
use of this eth tester provider so this
is what's giving you in the background
um some preceded accounts and some other
uh
bits that make um that abstract away
some of the message signing and signing
and sending that kind of
stuff and then finally I'd like to give
a nudge to
the the the web socket provider which
has received a a ton of investment in
the last year this is uh you're only
going to get some subsets of the
functionality within web3 Pi via a these
persistent um socket providers so for
example you can use e subscribe within
this provider and react to real-time
events as they occur so in this example
we see um that occurring as new blocks
are added to the chain you can listen
for them and handle them as you see
fit all right that's provider um read
operations these are things that don't
require a transaction gas whatever uh
you're just querying your node at at no
expense effectively
so you can do things like look up
balances get block and transaction
data uh interact with contracts in a way
that doesn't uh manipulate state of the
blockchain and parse event logs these
are
um in the pop-up faucet contract you saw
that we emitted some events so get logs
is the way that you can reference uh
historical events on
chain um again a plug for the web so
provider if you want to respond to these
in real time uh you can build
arbitrarily complex uh filters for that
you can subscribe to events that match
that
functionality and then handle those uh
events as they
occur if you want to change the state of
the world in a blockchain you need to
send a transaction the simplest version
of that as sending ether from one
account to
another uh you can write to a contract
you just transact as used instead of a
call and you can deploy contracts so
under the hood um this is what ape is
saving you from doing but um yeah still
a a framework like ape is preferable to
to doing this just because you can build
confidence using like an accompanying
test Suite or any other scripting that
you want to
do um all right those are the basics
the I've picked out a few other um
components here that might be useful to
you especially as a hackathon
participant the first thing and I'm not
going to include any code here is um
that if you need web 3 pi to do
something more than it natively does you
have a lot of options um primarily
middleware or a custom method module or
provider you can kind of reinvent any of
these wheels
here um good idea is to make your app
more human readable so Leverage The ens
module to for example resolve addresses
to names in your app or you can also um
like there is a bunch of other metadata
that you can store along with an ens
record so if you're building some kind
of user profile you can grab any of that
as
well there's another kind of wacky um
feature in here which is called ccip
read where you can resolve addresses
offchain if that's interesting to your
use case then we've got a a blog post
that eth account so we're going to see
this um we actually going to use this
within the the CLI but um you can access
eth account from within web3 Pi or
individually it can be used to create
accounts on the fly or load up um one
that you've already got and then sign
transactions or
messages eth udal this is a
huge library of helper methods basically
so I'm just going to highlight a couple
ones here um the ABI utilities and the
the humanize
utilities um so another big investment
this year went into ABI utils here if
you need to kind of dice up your ABI in
any any uh any variety of ways and it's
um this is this comes up pretty
frequently in various use cases there's
a whole library for that um shout out to
Stu over here for that investment this
year and then uh the
humanize um module here is just a way to
get more human readable versions of
whatever data you're working with so
convenient way to for example
display uh whey amounts which are
typically uh huge integer
values all right let's put some of this
into action within the server um this is
our
uh our part in the diagram in the middle
there that connects the CLI and the
contract um so our server is going to be
uh a simple flas app or relatively
simple I should say so just a few routes
in here um at a minimum we need to be
able to create and dri drip but there's
some other uh convenience stuff in here
um So within that flask app we can
handle some um
Secrets uh if as a result of compiling a
contract um you you can get this uh
artifacts or um I forget ape calls it
the local Json file um so at any rate
the result of your compilation of your
contracts can produce the Json file with
with the metadata you need um and
effectively we can um set up our web
three instance and contract that we care
about here
now this app handles multi- Network
support so the main takeaway here
there's a lot of code on the screen the
main takeaway is just that your web 3 or
you need to create a separate web 3
instance for each chain you're
interacting
with um the rest of this file is
basically setting up like a a helper
function to you get this this dictionary
of each uh Network then a helper
function to parse out the network that
you care about here so you can just call
get
W3 and contract subio and then get those
that you're interested
in and we'll go over two more code
examples here one contract read and one
contract
write if we've got a in the server a an
availability checking
function um we can parse out uh the user
will tell you right I want I want to
operate
on uh um op sapoia and I want to a host
will try and register an event code so
Devcon on Opia we'll parse out the right
the appropriate web three instance and
contract and then call the code
available function on that
contract and then return the value to
user so pretty straightforward it gets a
little Harrier on when you want to write
to the
contract um so I I omitted from the the
speedrun here that if you want to do
this uh if you want to write to the
contract there's there's three steps um
building a transaction signing a
transaction and sending the transaction
so you can see
um same same idea just a couple more
steps
um I'll save this for for docs there's a
nice page on on what it takes to send a
transaction
here um
um other takeaway here is that the life
cycle of a transaction is such that you
um you will send it and at the point it
gets sent it becomes a pending
transaction so you need to wait for it
to be included into a block before you
can um for example tell the user that
your faucet creation was a
success okay getting into the home
stretch here uh we've got our contract
we've got our
server and now the
UI um just an encouragement to get a
little creative here in the python side
of things I think there's maybe a
misconception that you don't have that
many options for user
interfaces um you can get weird and I
encourage you to so the CLI tooling
we're about to look at for um for the UI
Tui is um textual for example you saw
that used in snco um but Discord and
telegram Bots and so on and so forth you
might also consider um like a hackathon
viable project could be a module that
you build um as a developer tool within
web 3 Pi um so if you want
to um I don't have an example here if
you want to do something weird and make
it available to the world that could be
a a way to to to go about
it and then consider how you're going to
get that thing into hands of your users
right so for for our
example uh we're going to make popup
faucet available as a python package so
you can pip install
it one more Pro tip and this is
basically an unpaid plug for excal draw
um I found it helpful to to think
through what I was going to build in
this this sort of diagram format the
shapes are meaningless here but um we're
going to build
essentially um couple pieces of
functionality uh create and drip can
fail in certain ways and um it's helpful
to think through that
visually um okay so I've got a backup
plan here but again if the demo Gods
cooperate um let's take
a look at um what pop-up faucet looks
like um again available via pip
install and once it's on your machine
hopefully it is
cool uh you can do a few commands which
are available here in the the help
screen so starting with the the
admin the the the workshop host
experience I want to tell that I want to
create a network or a faucet excuse me I
can specify an event
code and
it's off to the server to confirm that
this doesn't already ex this is not
already reserved in the contract and
come back and
say uh great it's available send your
test net ether to this address and uh we
will take care of the rest now I'm not
in the process of sending any ether so
we're just going to spin here and say no
go but that is the uh create side of the
experience then on the other end you can
drip
so I would have attendees pip installed
pop-up faucet they can come along and
say uh I would like
to uh get a drip on Bas ofoia and I'll
specify some given event code
uh I'm just going to zero out this I'm
going to basically burn a little bit of
test net ether here but they'll come
along give the event code and the
address they want to receive ether at
and that's that's the whole of the
story uh a couple more pieces of
functionality here but I think that
serves our
purposes um so let's talk about uh just
a couple more code samples to explain
what's Happening Here fortunately I
don't have to show my backup
plan uh okay so in this example we're
going to use the concept of ephemeral
accounts so we're going to uh import eth
account on its own without web3 Pi we're
in the the CLI app now this is separate
from the server separate from the
contract and um this is using click a a
command line interface
Library
um again again this is another slide
with a lot of code on it I'm going to
just drill down to the heart of it so
we're uh we're asking the user for that
Network and um uh this is the create
function we're asking the user for that
that Network and event code they want to
create we're going to um send it off to
the server to ask is this available is
this registered in the the contract and
then if it's available then we say great
let's generate an account on the Fly and
I want you to I Want You Workshop host
to send some ether to it so this account
lives nowhere but within popup faucet
the application the command line
application
um and then this this input at the very
bottom here is just going to just going
to hang going to wait for the the user
to indicate they have
sent um yeah last code
sample um once I have indicated that
I've sent The Ether to that address
um we're going
to verify that's true first of all and
when it is we'll break out of that Loop
and say um great we're now going to send
the private key of that account we just
created uh over to the server and the
server will build sign and send uh that
transaction to actually do the to you
know to interact with the popup faucet
contract and actually do the creation of
the the
faucet um so this this account exists
only for uh well it exists in perpetude
but as far as the the user is concerned
it exists only for the lifetime of this
creation of of a a
um I
suspect um depending on how much I
stumbled over my words this is this is
an area where I I I could have lost some
people um I'll pause now is is there any
um question on um what the ephemeral
account is or is doing or um could zoom
out a little bit to and ask like why the
server is necessary or what the
separation of concerns are for the the
CLI app and the
server and if you don't feel comfortable
asking now then come come poke me after
okay I'll assume I'm just doing an
awesome
job okay a couple last tips um we're
going to run through these real quick
and then um wrap this thing
up uh some presentation bits here so eth
go asks for a two to four minute
recorded video of your your
functionality um the very good news here
is that you've got the template of how
to do this already if you went through
the exercise at the beginning um so who
what how and now basically what we did
um as like for this demo is to to
explain like um we're solving a problem
uh for Workshop hosts that want to get
test net ether into the hands of
attendees in a reliable and non-spammy
way and the options today look like X Y
and Z uh what we can offer is this uh
simplified
experience um that is pop-up faucet
uh and then demo the thing and
um it's hard to understate how like the
importance of the presentation component
in hackathons so start earlier than you
think you need to at least 75% of the
way or at Max 75% of the way through
your like your time budget um it should
be it it should be pretty polished right
because this is all that the judges have
to go on
um Tony takes this to another extreme I
would say and says like do the video and
presentation first um even by using a
mockup so before you even build the
actual thing um build the mockup in I
don't know figma or whatever Tool uh you
know how to use
and
then um spend the time like living up to
that promise or pivoting if you can't
get there I guess
um final note is um just emphasizing
that mvp process get to the Happy path
as soon as you can but then you can
balance the rest of your time with uh
doing some iterative Loops either on the
product or the presentation um chasing
bounties adding Graphics uh making stuff
pretty so in the popup faucet example
some of the
like uh subsequent Loops we made of
Polish were um like loading animations
colors bolds fonts in the CLI just
reaching into like rich is a the library
we use for most of that on the uh the
python
side and yeah doing doing some loops on
that um that
presentation uh that's that's the whole
of it I think um for those of you
hacking good luck this weekend um
and we have
uh bit of time here so I'm going to
leave the floor open for for any
question but also if anybody out there
um wants a snaky MC snake face NFC tag
pin if you want to chime in and share
either any um pakon Pro tips you have or
maybe war war stories or horror stories
from hackathons you've been in um if
anybody wants to pitch an idea go
through yeah please you said you would
to share that yeah let me um um let me
put that up first so this is the last
slide here um there's a blog post on our
snake Charmers do uh ethereum.org
U blog and you'll find like the tldr of
this workshop and I think most of the
the resources that we've chatted
about so I'll leave that up for a minute
and then um leave the floor open
at any rate
please walking
the a lot of Bo here a lot of people
exhibiting and you just talk to you get
all kinds of ideas and you can
just yeah sorry I'm rarely accused of
not being able to be heard
um you just just talk to people
yesterday I had a great chat with the
cursive folks downstairs
and that just kicked off a whole series
of ideas and there were about six of us
just you know pinging off each other uh
you can do that at lunch you can do that
in the booth it's just it's fun and most
of it may go nowhere but it's phenomenal
hackathon
material amen yeah I think this uh
conferences in general Devcon maybe
especially is especially right before a
big um hackathon is is is prime time for
just just bouncing ideas getting weird
um kind of wondering out loud with
people what's possible spitballing uh
hearing people's like kind of wish lists
for what they they wished exists or
vague directions they're heading in but
don't have all the answers to yet and
yeah sometimes U there's gold in there
helping them figure out how to get to
that that
place please
cheers thanks for using
it
coding you're uh incentivizing doing the
presentation before the coding um and
you know it's kind of interesting
because sometimes it feels like there's
teams that develop something that's
truly amazing but they never like
surface something in the visually and
they kind of get outrun by somebody that
just spends the time and you know kind
of the nice Graphics so is there is
there like any efforts to try to make it
more like um you know in the sense of
what really matters which is the uh kind
of like kind of both matter to be honest
like the presentation also matters but
sometimes it feels a bit unfair that you
know you got somebody that really good
with Graphics but then doesn't have
anything working at the back end they
don't deploy it's not working so is
there anything we can do to make it more
fair in that
way yeah it's a great question I
think um many or most hackathons do have
uh criteria that you need to qualify for
so like uh I'm not sure the specifics of
eth global but I believe you need to
have deployed code and working code to
qualify for some prizes um that Mayan
not use universally true I'm not sure of
the circumstances but I do think yes
there's an unfortunate disconnect
between um developers doing really cool
valuable work and not getting recognized
in the ways they should because their
presentation just doesn't live up to
some of their
competitors
um I don't have a great answer to that
but one of the things uh that I will be
spending some of my efforts for in this
like at the top of the talk we talked
about um our team goals one of them
being educate and Inspire Builders I
think one of the things I'm going to
spend some more effort on is like a
better launching Point potentially for
helping um presentations get somewhere
faster um I think the simplest version
of that is just like slide deck
templates honestly that give you a
better heads up a better lean into like
what judges want to hear um but I'm
super curious about if anybody else in
in the room and Beyond has ideas about
how we can improve the ability for
hackathon participants to present their
ideas
effectively thank
you
sure just speaking on that um
obviously the the presentation itself is
quite important but I suppose there
could be some talking
about talking to the judges and and sort
of briefing or you having this idea of
waiting utility uh rather than just a
you know a pretty new startup kind of
product yeah I think you're on to
something there um some interface and
maybe like
one that happens earlier in the process
um because time is obviously such a a
constraint on in this process especially
if you're doing like a weekend hackathon
and you get like hundreds if not
thousands of submissions kind of thing
like some of the virtual hackathons have
huge audiences
um yeah so you
are at the mercy as a as a hackathon
project submitter you at the mercy of
the process that um eth Global in this
example facilitates and they've had a
lot of iterations they do a lot of
things really well but nothing will ever
be perfect uh so you're at the mercy of
their process and um the luck basically
of whatever judges end up uh reviewing
your project so not every judge reviews
every project that's
infeasible
um so yeah man some of this comes down
to like tough
luck um but I do think you're onto
something with ideating
about how we can better inform judges to
the real
utility
um yeah of of those projects you got my
you got my wheels turn in so thanks
curious to chat about this
more sure
going
to page now and I'd be really curious to
see your um ideation of like from now to
the hackathon looking through the
sponsors list you know what would be
your thought process on um this is a
type of things that I'd be doing and
just you know give us a bit of a you
know your idea of like well if it was me
and I've got from now to there and this
is where the money's coming from I'd be
going to talk to this person this person
this person I don't know if we've got
enough time for that but um be very
interested to get your let me do a time
check
we I don't know if anyone else
interested in that okay so um great
question I'm not super confident that
I'll have answers that will really
thrill and and inspire you here but okay
probably be better than
me
um but let's run with it and if anybody
I'm I'm going to like I want to see if I
can multitask and think through this if
anybody else um has ideas questions Etc
feel free to jump in as well so eth
Global um and you're talking
specifically about this weekend for E
we're going to the hackathon and you
know F first time and um Ju Just
wondering you know from the literature
that's already there and the and the the
like um the other gentleman said talking
to the people that's around and
obviously they've got their sponsors
list on this um page somewhere like what
what would your you how would you best
use your time from now to there yeah is
that something other people would find
in stream so I'm this is an awesome
question I am um I'm not going to
pretend like I will be give you the best
answer alone so I think this is like a
great opportunity to sort of crowdsource
the answer from the room um what I where
as a starting point
um my
inclination and like what gets me
excited is
um scratching my own itch basically So
like um pop-up faucet I wanted to see
exist um because in the hackathon prior
to uh the one we built this in or even
during um we experienced the pain of
using um testet faucets and trying to
rack up enough testet ether to do a
bunch of experimenting um so I really
wanted to see popup faucet exist um and
that was very motivating for me to go
and just make it happen to like spec out
the simplest way to get there and then
start building um so that's always where
I will encourage folks to start right if
you are scratching your your own itch
then you you effectively have to do a
lot less research on your target user
right because what do you
want
um there's a million other approaches to
this I would say one of the obvious
approach um options is just to take a
look at the prize list and um this is
going to be like a more I think
overwhelming exercise than many other um
eth Global or other hackathon events
because there are so many sponsors this
year so it' be tough I would guess to to
narrow down if you're if you're coming
um no preconceived ideas of I want to do
approximately X
and I just start running through this
list um sure I think you'll start to
generate some ideas uh it is a strategy
it might also be a little bit
overwhelming to ages like just looking
up each of these companies trying to
understand what they do looking at their
docks to try to see if they're um
intelligible straightforward
actionable um
yeah yeah it's a great Point um is there
like a a pool of people who have
specializations in certain things that
you're looking for maybe there's a
matchmaking of process for that
as um if I may paraphrase um
the the suggestion is is to use mentors
effectively um uh you can bounce ideas
off of them ask um other folks what they
want to see what they're interested in
um and a great like conversation
starter
and um yeah I suspect you get a lot of
great food for thought at least
um let us say where you you typically
see the this python oriented person sort
of approaching uh blockchain
problems another great question short
answer is um I don't know exactly but I
could speculate that
um chat Bots are probably a really
popular Avenue to go down um telegram or
Discord Bots because they're python to
build those out um and like our whole
industry lives on Discord and telegram
for better or worse so you can reach
your audience that
way that's my first thought
anyway any other questions otherwise we
can wrap it
up all right thank you buddy for your
time
cool thank
you thank you
l
for for
in
all
oh all
no
m
spe
okay hi everyone um welcome to the
session of today um we're going to be um
breaking some chains today if possible
uh thank you for coming and I hope you
have a great time this um let's try to
be as like relaxed as possible this is
going to be very interactive if you have
questions uh
that hello hello oh perfect so yeah as
as I was saying um let's make this um as
interactive as possible if you have
questions just let me know and stop me
at any time um the goal here is that uh
you guys are the ones that break the
chain or implement the tests and run
them on the live Network so for that to
work we need uh to take it slow maybe
and um and yeah if any questions just
just ask me or developers also run their
tests and in in in well our tests in in
in their to to their client uh this is
the main repository we're going to be
using it a lot so if you can um uh
access it and bookmark this link is
going to be extensively used throughout
the session set up the testing
repository we're going to uh add and
analyze a test for new EIP which is not
tested and there not there are no tests
anywhere because it's uh it hasn't been
approved for or CFI everything is there
um so yeah just please take your time
just go into it and uh
bookmarked
um and actually I'm going to give some
time in every slide so you guys have the
time to uh make sure that make sure that
you have everything in your laptop and
everything is set
up yeah also the the the slides are over
there so you can you can actually see
the presentation um you can pick ahead
of course um but if you want to just
go with the flow of the workload that
that's that's even
better all right so um the presentation
is designed assuming that you don't have
basically anything installed um so right
now what I'm going to do is present
every single tool that we are going to
use uh to run the tests um obviously uh
there are different os's and different
uh architectures that you your guys
should have in your laptops but if you
have any trouble installing anything
just uh let me or anyone in in in the
team know and they should be able to
help you out to
install yeah just like just put your
hand up if you want some help and we can
come over and see how you're getting
on yeah so yeah um the main the main
tool that we're going to use today is
the common line so this is very
essential to run any any of the commands
that we're going to use um this is
assuming that uh you already know how to
use so uh if you don't have it installed
uh don't worry uh we'll get to that
point eventually very readable it's like
easy to follow and anyone can basically
just get the gist of what the code is
doing that's why we chose it uh for the
for the for the language of our tests um
all right and we're going to use a
little tool that is called UB this is
basically like a a manager of versions
in in in in Python it's very new and we
just updated our repository to use it um
so I think this is going to make it even
easier for you guys to to to install
everything that is needed it it should
be like a simple common line and and
should you should be ready to
go um yeah git um the only reason that
we need G is just to fetch the the the
code from our repository so um right now
you should most likely already have git
installed in your in your PC but if not
um you can check in the common line and
you can check using git Das Dash version
um if you don't have G installed which
is unlikely uh please refer to these
links uh this is where you can install
it um raise your hand who doesn't have G
in in their
computer all right yet if if if you
refer to the any of those link you can
just easily install it um
Y and we're going to use an ID so if
this is not required um we use BS code a
lot uh because we have like uh plugins
and it's basically uh tailored to to use
BS code the repository I mean um and you
can use whichever ID you want is not
required but this make will make your
life a little bit simpler um you can get
it from from the from there that's the
QR code um um yeah it's recommended it's
not
mandatory um and yeah um there are some
extensions that we use in our in our
repository the main one that I recommend
for you guys to install is the python
one so if you are installing BS code uh
you might want to check this one out
because it really like highlights and
everything and it corrects some of the
code that you're writing so it's very
helpful it makes things much more
straightforward forward um yeah so
there's
that and yeah so yeah this is the main
repository um this is what we're going
to use basically for everything today it
contains all of the tools to execute
fill and generate tests in uh in in in
in in what we do so please go ahead and
just uh go up this link and just
bookmark it because it's going to be
used
sensibly um yeah another thing that
we're going to use today um we have a
live network uh it's a devet it's very
small it's only two two notes and H
special thanks to the e panda Ops Team
which is over there um thanks for
helping us uh set up this this network
uh the goal is to break it today this
link over here it contains links to all
the tools that uh are we're going to be
using to explore the Shain uh it
contains an Explorer it contains um uh
the fork visualizer if if that's the
name um but yeah basically that's going
that's going to be our our our goal and
I will go into that link a little bit
later in the talk uh to explain what
what each of the tools is is doing uh
but yeah please if you can please
bookmark also this link it's going to be
also used extensively
and this link should also be in the in
the docs in the in the in the doc that I
shared at the start of the
presentation um and yeah um I think this
is the last yeah the finally um if you
guys use metamask there is a possibility
that you can add this uh devet to your
metamask it will simplify send
transactions but it's not mandatory um
basically um just install metamask if
you want to if you want to send
transactions on the network it's not
necessary because our framework they it
it also um creates transactions send
transaction makes everything for you but
if you want to send other transactions
to the network that's also possible here
are the uh the the the characteristics
of the network the name the RPC URL all
of this is also in the notes that we
share at the start of the presentation
so if you want to copy that just go into
the link and just uh just you don't have
to manually just type anything in any of
that all right so yeah the theory so
there's going to be a little bit of
theory um just mainly to explain um what
we do how we do it and go over the
repository a little bit uh just explain
the parts of the repository the code and
everything um but I guess I I should
first ask is are there any questions so
far um yeah
yeah of course I think that link should
be the session C
uhuh yeah if someone can can please try
it out and to see if it actually links
to the the SES that would nice is a
different one okay
M
great all right so yeah I'm going to
start a little bit with the theory and
I'm going to go to the to the actual
repository just to explain what we're
doing um basically and there's there's
going to be more information later Dan
has a presentation today that's going to
be very awesome is going to go through
all the details of the of the repository
I'm just going to explain the basics and
what do we do with this repository that
creates the actual tests um yeah so um a
couple of years ago basically we were
creating tests using jaml and this uh
this is basically what we use to create
the test that all the clients the
different clients of ethereum consume to
verify that they're they were consensus
compliant um what is consens compliant
is whether you are ready or not to to be
in consensus with another client if
you're not you're probably going to be
uh forked out of of the chain because of
an issue so this uh the test that we
write is just to basically make sure
that all the clients if they pass them
they can be very with with high
confidence they can be guaranteed that
they're not going to Fork out out of the
chain um so a couple of years ago we
created this this repository uh the
execution spectus is a new Repository
uh it uses Python and we use Python to
programmatically create those tests so
we're still feeling um Json fixtures the
Json fixtures are consumed by the
clients but now what we what we have is
uh basically the power Python and most
most importantly the power of py test so
pest is the main framework that we use
to write uh basically every single test
it allows us to um very programmatically
create a lot of different different
scenarios very quickly so we have like
this single for example let's let's
imagine we have one test scenario and we
want to create different variations of
that that this is super simple with pyas
and I will show you how how to do it in
a little bit um so it requires um uh the
the downside of the execution spec test
is that we require an implementation of
a client to be able to fill test and the
reason why is that is because we cannot
actually execute the state transition so
the state transition is basically when
you get a transaction you you you fit it
into your evbm it modifies something in
the evbm that is the C transition we
don't have that code inside of of
execution spectat but we rely on an
external client to do so and Right Now
the default client that we use to fil
test is called Els is the execution
specs uh it's the python implementation
of the of the ethereum specification so
this contains all of go and we use that
to fill the test to to actually execute
transition um so yeah apart from that
our our repositories capable of filling
and verifying tests and running tests
against clients or even live networks
let me just open the link so you can see
how is it like um so yeah so yeah from
it's from the get-go we have um um this
link over here this is the documentation
so this the the repository we also have
a very comprehensive uh documentation
that you can access here um I suggest
that when you open the repository go to
the documentation also and go here in
the documentation and open the main the
main version which is the most
up-to-date version of the documentation
that we have uh but yeah going back to
the repository um it's very simple we
have two paths that are very important
the first one is the source code uh
basically this contains the framework
itself the the the the code of the
framework itself this is used to fill
tests um and it's it contains a lot a
lot of the logic that we use for example
it contains um the the one of the most
important ones is that we have the
definitions of every single Fork uh that
that has happened in etherum and even
the future Forks so if we go for example
to to this file you can scroll down here
and you will start looking into the into
the actual Forks so the first one
Frontier uh happened almost 10 years ago
it this contains the definitions that we
need for testing it doesn't contain the
logic but contains what we need uh to to
parameterize our tests um and you can
scroll down all the way and you can see
that everything is here we the the most
recent Fork that is under development is
PRACK this is the one and it contains
definitions for all the I don't know
pre- compiles H it contains definitions
for the system contract there's a lot of
new system contracts in in prag those
are all here because we need to know the
addresses to actually test uh their
their behavior um yeah basically and
also we have an even more in the future
Fork uh that is already defined here
which is the one that we're going to be
using today because it's the one that is
running in the devet that is called
Osaka it's a it's a dummy Osaka because
it's not really what's going into Osaka
but it's only contains one EAP um well
it contains UF in here but that's that's
uh that's that's not what we were going
going to use today um yeah and what else
is important here yeah okay so uh
another another important part is that
we Define fixtures for our code for for
the test sorry this is basically where
everything is defined for the output
that the client will eventually consume
we have different types of tests here
and the definition of for every single
type of test is defined in this in in
one of each of these files uh the main
ones is the blockchain type
this is uh basically just a test that
contains a whole blockchain inside of it
it's it's a fixture and this is how we
output it um in in into into into into a
fixture that the client can consume
um uh what else the BM is another
important part um this is how basically
how we write the code in here we don't
use solidity we use uh an like sort of
like an internal language which is very
into the to the evm code and up codes um
so be because solidity does
optimizations when it tries to compile
the code those optimizations hard hard
the the way uh that we test so for
example let's say that we're testing
some a special up code and we write our
solidity code and then we compile it and
then it optimize out the the upod for
some reason that is not helpful for us
because it can lead us to to think that
we are failing test but instead it was
because of solidity um so what we do
here here is basically just we Define
every single op code that we have and we
use Python magic to basically create
bite code itself so if you go to this
file you can see all of the op codes
that exist and even new ones that
haven't been implemented yet um yeah you
can you can take a look here um
basically you can construct almost any
type of uh bite code that that that can
exist you can use the upcut here to to
create it I'll show you in a bit how how
they are used in a test
um yeah any questions just of interest
is um 3our sleep
here someone called 3our sleep so um I
just wanted to say thanks to him because
he added all the documentation for for
the op codes he's an EPF fellow in
cohort
know yeah um yeah so let's let's go and
actually see some of the tests so
everything
um yeah from from the main from the main
uh route directory you can see the tests
here that's basically that's basically
where every single test that has been
created at least from uh from Shanghai
up to now that's that's where every
single test live and it's um sorted it's
um sorry ordered by by directory which
is the name of the fork so let's say
that you want to see what we tested for
for Shanghai let's just go into Shanghai
and just see what is in there you can
see four eips that those are all the
eips that affect uh the evm behavior for
Shanghai um we have only four here this
uh the warm come Bas the push zero which
is a new OP code um we have a limit for
the init code and the withdrawal so
there there are if you go inside of any
of this let's go into U PIR I think is
is the easiest one you can see that we
have some files but the main one is the
test file so um if you go in here you
can you can actually see the python code
that generates the tests for the push
zero um and it's um well this this one
is not that simple but let me see yeah
let me try another
example let me go to the easiest
one
Frontier um if you go to the theck so
this this is basically the easiest test
that we have so if you go into up codes
there's a test for the D up code which
is basically the easiest uh test that we
can do is just duplicate something in
the stack in the evm
stack um and yeah this is how we
generate it this is how a normal uh test
looks like so basically we have
definition for the function we have uh U
this test du which is the main function
that runs and generates these tests and
we have a parameterization this is one
of the best parts of P test it allows us
to parameterize tests to do the same
thing over with different up codes for
example in this in this uh in this
function what we do is we parameterize
um every single dob code and then then
we run basically the same code um I will
go into more more detail of what uh what
each of these lines represents in a
little bit um but just the main just to
get the main idea is that this is what
it looks like this is what we use and
this is what
almost every single test look like in
the in the E theum uh test
repository let me
see all right so back to the
presentation um yeah so I'm G to explain
briefly because this is really important
uh uh for anyone that wants to write a
test um so the main uh the main goal of
the test
is to do an action in the evm and this
is this is composed of three parts um
basically the first part is a setup we
do something previous previous to the
transaction we set up smart contracts we
send we set up uh accounts with uh with
ether that are going to send
transactions we set up balances we set
up announces um uh I I'll explain what
the nons is a little bit um but
basically the setup is how we set we we
We Lay the grounds of how our test is
going to execute um the second part is
the action H um basically the the the
most simple action is the transaction so
once you have set up your smart
contracts on once you have set up your
accounts something needs needs to take a
a modification into the into the evm and
this comes from the transaction uh
ethereum is not like uh event based uh
it's more like uh everything has to come
in every action has to come from a
transaction so this is the part that we
use in the test we basically um make a
transaction that is going to go
potentially into the into the smart
contract that we already created and
it's going to exercise the action uh
it's going to modify some code some some
storage uh even creates more smart
contracts um normally is for the simpl
tests that are only evm Centric these
are a single transaction but it can get
as complex as many blocks with many
transactions each uh for today we're
only going to use a single transaction
uh for all the tests but if you want to
see more more interesting tests we can
we yeah we can go into the into the into
one simple example and yeah and the last
part is the verification so once you you
create a smart contracts you send the
transaction to them uh you want to see
something happen in the in the in the
evm and the most the most uh common
thing that we check for is the storage
so um and let me explain if if if not
not everybody knows what the storage is
basically is the permanent memory of the
of the of ethereum so every contract has
the storage which basically uh saves
information basically forever until
until it touches it back to zero uh but
this is what we check when we we send
the transaction we check the storage we
also check balances it's less common but
we do that also and and we also check
the code sometimes where we are testing
for the deployment of the smart contract
we also check the code but most
importantly if you want to test
something it has to go into the storage
um even if it's like U something that
happened in memory you have to somehow
store it in the storage for us to be for
for it to be visible to us in in the
test um
yeah yeah okay so let let's let's get
started
um uh by the way how's everyone doing on
the installs has
everyone um the anybody has any
questions or just raise your hand yep
the last thing you said so
how so the
events we don't we don't have tests for
I mean we do have tests for event but
there most of them if you want to write
the test what what I meant is if you
want to write the test you don't you
wouldn't use events you have to is for
let's say you test a new upcode that
makes uh I don't know a addition or
whatever you have to end up using the
storage to save the output of the of the
of the of the action but the events we
don't we don't check them the way that
they are checked is when you do the
street transition you will have the the
logs receed you will have the uh the
receive hash and everything so that that
is implicitly tested but for us to be
observable it has to go into storage
basically
yeah all right um yeah so let's get
started um so the first thing that
everyone wants to do uh should should
should do is uh we're going to install
this tool that is called UB is going to
allow us to very rapidly uh run uh the
commands that we need um so that's
that's the command that you need uh
please go ahead and just run it if um if
if to get to get UV installed I already
have this in my machine installed uh let
me let me open up a common line here
yeah so u u is already installed but um
yeah please just go ahead and run this
command um uh anywhere in your machine
and you should be able to to install U
um depending on on the the environment
that you're using it's possible that you
might need to run this second command
but it will tell you so at at the end of
running UB you can just run this command
if if necessary and you will get get the
the um the the the environment set up
correctly um so yeah I can I can just
type anything and you can see that UV is
already installed um in my
machine oh by the way this this command
should also be in the in the notes so if
you want to just copy paste it just go
to the to the notes um and and just copy
paste it into into your common line uh
if anyone has any issues just uh let us
know
all right the next thing next thing that
we're going to do is that we need to
fetch the repository um we're going to
use the execution spec test as I said so
this is the command to get it copied to
your machine um run it anywhere where
you where you want to download the the
repository basically what it will do is
just uh copy from GitHub it will it will
copy the entire repository into your
local machine so you can start executing
stuff um yeah and then the second one is
just move to the execution spec test
just to start running stuff in inside of
there so I already got this here um so
this is what it looks like once you have
the um once you have the run the the the
GitHub clone command is it clone yeah um
this is what you should end up uh seeing
in your machine after it's executed um
it might take a while because the Wi-Fi
it's not perfect here but yeah just try
it out if anyone has any issues uh with
this command just let let me
know all
right all right so next thing is these
three
commands um so the first one is just to
set up um in case you don't have python
this is the one that sets up uh python
for you so if you run this um it will
automatically download the correct
version of python it will automatically
set up everything and it should be um um
it should be set up for you
automatically
um so just try that out let me just try
to run
it yeah there you go it seems like it
does nothing but what you can do
yeah IDE a few people came in late maybe
just go back to perfect expenses yeah
yeah yeah let me let me just real wind a
little bit uh so the for the people that
just came in this is the main link that
you will be looking at um just to
explain it again um this is a hackmd
that contains every single link every
single command everything that you need
is going to be in there so if you get uh
you miss something in the presentation
just go to here you can see it uh and
also there's going to be a link to the
presentation itself so if you miss
anything just go in there and and just
uh use that link I'm going to give it uh
a couple
uh time to just wait for
everyone um if you stick around and hunt
the bug then uh you can collect a pup
and if you're the lucky participant that
breaks the chain there'll be a special
pup for you
too
awesome so yeah let's go back to the to
the current
slide um yeah so yeah after you run the
First Command and um let's let's let's I
I just run it so right after that you
should be able to do something like UB
run Python and just the version uh
basically just
everything so basically everything that
we run inside of the repository is going
to be run using uh U so the main this is
basically what what you have to remember
to run anything in a repository UB run
is the prefect to everything basically
and what I'm doing here right now is
just I already created the environment
and I said I need python 3.2 which is
the version that is compatible with our
framework I just want to make sure that
that is what what we we're going to see
so let's see if that
worked so yeah it's going to
automatically do a lot of stuff for you
and then then you can see that uh it
worked uh it's very very nice to work
with duv because it sets everything up
for you um you don't have to install
anything not even python so as you can
see UV run automatically um runs in the
correct environment for you to to be
able to work
rapidly um yeah so yeah the next step is
basically performing the initial sync
what sync means is that UB has a lock
file which basically every requirement
that we need for framework it's located
inside of this file and UB sync what it
does is basically okay just go ahead and
download everything I need in the
framework so let's just do that it's
probably going to do nothing here
because I already did it oh yeah it's
going to download a lot of stuff um it's
basically just to prepare for us to run
any command in the repository um so just
going to take a while
perfect so basically we are we are ready
we're ready for to fill any test um um
there's nothing there's basically
nothing else that you need to do it's
it's that simple and we we are going to
verify that we actually can run um uh
the tests so this is the main command
this is one of the main commands we're
going to use two commands today so the
the first one is the fill command so
filling the tests is one of the first
steps where we deliver the test to uh
I'm sorry one of the first steps to
deliver the test to the client and what
we're going to do right now is just make
collection this means inside of py test
is basically just go inside of the test
repository and just look for any test
that you can find and if we just go
ahead and do that let's see what
happens it's going to collect everything
okay it's going to install Soul C
because um there are some test that you
s see so it's going to automatically
install and then it's going to collect
and you can see it's collecting every
single test so we got around
you're seeing here is everything it's
basically every single test for Every
Fork that we have uh you can be a little
bit more selective let's run only tests
for the fork of uh
Cancun and it's going to go down a
little bit in the normal number of tests
but basically yeah um the nice thing
about pest is that so when you write a
test for example let's say that I wrote
a test for Shanghai it's going to
automatically update it for Cancun which
is the next Fork so you're not only
creating tests for now you're creating
test for the future also so it's a
pretty cool feature that's automatically
done for us because of pest and how we
have configure the framework um so yeah
it's working so let me know if if anyone
had any trouble running it
um yeah
let's go ahead all right yeah the second
step is just basically opening uh
visually Studio code so let me just do
that um I already have the visual studio
code open here
um but if you want to open it just go
code and Dot which means open the
current folder in Visual Studio code
otherwise you can just go to visual
studio code and just open folder and
that's the same thing basically yeah
how's um how's everyone doing do we need
to take a moment just to get everyone to
speed like make sure they're all at the
same level is anyone having problem
cloning the repo or running UV for
example does everyone managed to do
that okay perhaps we just take a moment
and get everyone up to speed yep
was took me a while
I mean long
right for
hey um to the new new people arriving um
we're basically setting up um I'm just
going to go back to the to the first
slide to
um um if you want to rewind through the
through the slides or see that what we
have already done please just go to the
QR in there it contain all all of the
information that you will need um we're
just waiting on setups
all right I I think we can we can carry
on um yeah so let's uh let's continue by
um we're going to write the simple test
that we can
imagine um this is basically going to be
the simplest example and I'm going to
explain every little bit um so this is
this QR code is a gist you can go inside
and just uh copy basically copy paste
the uh the code and you can paste it in
under test Cancun that's going to be the
folder where you wanted it to be so
let's let's open up the the
gist basically just go inside
um copy everything
and we're going to create it under test
Cancun and just just put it there um
going to call it test
simplest simplest pi and just paste it
here all
right all right so I'm gon to I'm going
to go over the the all of the parts of
the tests so if you want to just uh
pause where you doing and I'm going to
just try to explain everything that is
happening in this
file all right so yeah every single test
basically looks like this um we rely a
lot on the on the framework that we have
so that's what is uh basically the most
of the Imports if you have used python
before just an import is basically just
a library that you have to import and
most of the the important stuff is
happening here
um then this line over here uh basically
we can write tests for any of the forks
um but some of the tests which are the
newer tests they only can run in one of
in the newer Forks so in this case we're
going to write a test for Cancun this is
the the test um this is what basically
is telling P test to only fil this test
for the for the for the can con fork and
this is um yeah this method definition
over
yeah yeah this is basically almost
everything that you need so to define a
test in Python the only thing that you
need is create a new file which in this
case we already did it's called test
simplest and then inside of that that
file we're going to create a method the
method is basically a test um in this
case it's going to do a couple of things
um the first the first part is the
parameters so what we need here is we're
going to create a state test the state
test is basically just a test with a
single transaction to one or more
contracts and that's it we have another
variation that is called blockchain test
which uh performs a test over an an
iteration of many blocks with many
transactions but this is the simplest
form that we use just one transaction
one the setup transaction output and
that's it um yeah and we also going to
uh use uh this parameter which is called
the pre it's basically the pre-state
we're we're going to use that object to
set up everything that we need for our
test in this case we're only going to
set up two things and these are uh what
we seeing here this is this is the first
thing that we need in basically every
single test we need a smart contract so
this is what's happening here in this
line we are telling the pre the
pre-state to deploy a contract for us uh
and in this case you can see here this
is not solidity this is uh this is
something that we we created for the for
the for the evm um testing uh basically
we're going to use two up codes here uh
this is one of the most important up
codes that you that you really need to
know when you're writing an AVM test
basically is the store save to storage
because this is what we are going to
observe in the output when we are
verifying the tests so basically what
this test does is just um please put a
one in in the store Key number zero and
that's it that's what this smart cont is
doing and then stop a stop execution
that's everything so what's going to
happen when we when this line of code
runs is going to deploy a contract with
only this in in the bite code and that's
it um we're going to see a little bit
later how the execution happens we're
going to execute this in a live Network
and we're going to try to match this to
what we see in the blockchain U that's
going to be pretty cool uh okay next the
other part that we need is some eoa eoa
stands for externally owned account it's
basically just a wallet um and we need
this because we're going to send a
transaction so the transaction needs
funds and this is what exactly what
we're doing here just create the center
for me with some funds in it and and
this is going to this is what what's
going to send the main
transaction um yeah so the transaction
looks like this very simple uh so the
destination of the transaction is the
contract address which we just created
here so basically when we deploy the
contract we get the address to it over
here and that's is what we use to to to
craft our transaction so we send the
transaction to that address to exercise
this code here all right and then also
the second line is here is the sender so
who is going to send the transaction
this the account that we just funded
over here so we just use that reuse that
over here and two two more things is
basically just uh how much gas is the
transaction going to pay for for the
execution um in ethereum we use the gas
which is the minimal for a transaction
is 21,000 but in this case we're ramping
out a little bit because we're going to
use the storage and that's expensive so
we're going to give it 100,000 and
basically any value that you want to use
here is fine and the last thing that the
transaction contains is the value we're
sending one way it's not one e it's one
way is one to the um one power ofus 18 e
sent uh with the
transaction and yeah and the last part
is going to is going to be the post
State this is the verification part that
we were talking about earlier today um
we're going to verify that something
happened in the block
and this is basically um check please
this address to be this account and the
account should have a balance of one
which is the value that we're sending
and it has to have a storage of one in
the in the in the zero key and that's it
that's everything that we're going to do
to check
um yeah and the last line is basically
just this part over here is um the state
test is please execute this this test
with this pre preallocation this
transaction and this post that's it um
so yeah let's try to F that test um it's
very
easy so let let me show you the command
to do
it so yeah let's
just let's just OB UV
run
Fork Cancun
test there you go um so yeah this is
going to f the test so as you can see
just U Run field for fork ganun and just
the name of the of the file I just
created so let's let's get that and see
what happens
um there you go that's it the the the
test is filled at this point um what
does that mean it doesn't mean that it's
executed in a client it just means that
it was it is now prepared um to be
executed on a client so let me let me
just redo
that and just
yeah yeah so now if you see the the the
files in the in the in the folder that
you have here you should see now this um
this fixtures uh folder and basically
this contains the test that we just
created let's go into state test and
then you can see that under Cancun and
simplest which is basically what we
created we can see this Json file this
Json file is the output that will be
consumed by by the clients for them to
to check their their their compliance to
the consensus um it contains very simple
stuff so you can see uh the environment
is basically how the blockchain looks
like at the moment of the transaction is
executed it contains the pre-state here
is the U the contract that we created so
this contract over here um this one it's
going to be depl deployed to this this
address and it's going to have uh this
code so if you see here you can see the
push push one is over here right here
the push zero is over
here and and and that is the the the the
first argument to the a store then the
finally you have the stop which is a
z0 and that's it so our the client when
it sees uh this fixture it should know
that the the storage at the start of the
the execution of the test it should have
this this uh this storage at that
address the second the second um the
second account that is created also is
the center of the transaction so that's
that is this one over here so the the
pref fund EA and it's going to be pref
funded with this amount of e um uh sorry
this amount of uh way um yeah yeah that
there not not not that much to it um
second um we have the transaction this
is the description that we just created
here so we have this this transaction
over here and we have um the SEC the
secret key to the center which was
generated by by this line so this line
not only creates a an account in the
state it also gives us this the private
key which is going to be used to to send
the transaction to sign the actual
transaction and that's that's what we
can see here um you have the address of
the of the sender you have how much eth
is going to be sent the data of the
transaction the destination of the
transaction the gas limit gas price and
all that all that stuff um and finally
what we're going to see here is um the
post State this this post state it means
that um the state rout of the of the
state of the blockchain it has to match
this otherwise you are you failing the
test um this is a little bit harder to
explain because um the the way that the
storage is uh stored in ethereum is that
you have this this tree this big tree
that basically just end UPS being one
hash um but we can see that a little bit
clearer in the other we are generating
multiple kinds of test also so the one
that we are seeing here is the state
test but we also generate blockchain
test automatically which is basically we
have like this entire blockchain in a
file uh we have the Genesis um it it
it's basically the Genesis is the first
block of the blockchain um but we also
have the pre-state and everything uh and
you can see here more clearly what we
expect in the poit of this of this
picture um this is not going to be super
important but anyway I I wanted to take
a look into how it looks um because this
is what we end up giving to the clients
um but yeah basically you can see that
the the end state of what we expect to
see you can see that the the contract
the 1,000 contract it has to have a one
in this in the in the in the zero key
otherwise the T will not will not
pass
um so yeah I think
I think that that's it for uh fixture
filling I want to jump into um oh yeah
so you can see the command here that I
just use in case you missed it um
but
yep go for mem sorry what's your
question
question why why three different why are
there three different uh test fixtures
for this one single python test so um
essentially we have different uh test
formats but test on like a different
granularity so we Define the test as a
state test which is like a lower
granularity than a blockchain test and
but from a state test we have a benefit
that we can wrap any TR like so state
test is a testing on the transaction
level so a single state change or I mean
you can have multiple transactions but
typically they're just one but the
advantage is if you have a transaction
you can always wrap it in a block in the
environment From the Block and so we
always generate a blockchain test from
that state test uh so you get a
blockchain test for free and that's
valuable because um then we can run the
tests in different environments where we
can only apply blockchain uh like we can
only pass blocks to the client um
yeah so yeah sorry um
just I saw some uh like requests
exceptions like HTTP errors like when
you were when people are trying to fill
if that happens just try again it could
just be a bit due to flaky internet
because we need to download uh the
version of eels from the execution specs
repo and if the internet's a little bit
uh flaky then this might time out so I
think if people I've seen if they've
triy it again it's generally worked so
don't give up
right all right that that is uh fine and
dandy but uh we want to see the actual
tests running a live Network so we can
do that um and it's a little bit more
exciting that just filling the picture
because you're going to see the outcome
uh so yeah let's just jump jump into it
and just run the the test in a live
Network so what what is the live Network
that we're working on um this is the
link uh that I showed earlier let's go
over there and just see what's happening
how's the network looking like um you
will see a couple of links here so the
first is the Json RPC this is basically
an execution client that is running on
the network and that can it can receive
your transactions it can send
transactions it can uh give you the
state of the network and everything um
but we also have Explorer we have two
explorers actually um and then you can
see here over
here this is basically the state of the
of the transaction right now okay
someone's already sending transactions
um perfect
all right so yeah um this this is what
you're going to use when you're sending
your your test to the network you you
are going to need to come here and see
that you're actually sending those
transactions to the network um right now
there's a couple ones um but it's going
to get a little bit more heavy the more
that we get into the into the into the
work workshop um what else we have we
have foron and forky these two two tools
basically just tell us uh what's the
health of the network how is it looking
is every client following the same chain
have they split and um basically what we
want to see here is we have right now a
healthy network but there's um there's
two versions of the client running in
the network and one of them is faulty
and I know it because I P the faulty
myself in there but the the goal is to
write the test that is going to make
this go split all right
um so hopefully at the end of the on the
on the workship we're going to end up
breaking this uh right now it's looking
healthy so no one has broken anything
yet that's fine um yeah what else okay
we also have a faucet here um again
thanks for the E pands team for all of
this they helped us a lot uh yesterday
to set everything up they're over there
thank
you and yeah and we also have faet you
can uh redeem um uh test it from here so
if you have an address just put it in
there and just start mining it it's
going to give you uh some e to test uh I
will wait a little bit because I'm going
to do the the um the execu the execute
part myself I'm show you how to do it
and then you can try it out uh by
yourselves all
right yeah so the first thing that we
have to do um uh we're going to use use
a command that is called execute it's
pretty new we just created it a couple
of months ago uh but it needs an account
uh to send the transactions so this is a
very Rim rudimentary um script to create
a new private key in an address to it um
basically it just generates a random
number please do not use this to store
anything valuable for you uh this is not
safe this is not crypto safe this is
just for testing purposes it's going to
use the the the python random generator
which is basically no no safe nothing
safe to use uh to store anything
meaningful all right but we're going to
use it just for testing purposes today
um please just uh follow the QR code you
can get the the the gist uh and you can
copy it to the execution spec test
folder all right so let's do
uhu that's
right obviously you're going to see the
the key that I'm going to hold so yeah
please don't don't uh don't troll me and
send anything from that
um let's see let's see okay so on the on
the root directory let's just create um
toch
y.p let's uh paste everything here all
right and then just U remember to use UV
run to to run the command uh gen key
that's let's go all right there you go
it's pretty easy um it generated
basically a private key it generated an
address so this is where everything's
going to come from in my in my in my
test um I'm going to provide this to the
execute command for it to be able to uh
to execute test but first we need to
take the address um take the address go
to the go to the faucet that we were
that we have in in this link uh over
here just go here Bas the address that
it give you and just start mining see
what
happens which
one that one yeah yeah
okay so I think we have funds let's see
just claim it all right it's processing
and what we can do is just go into the
um to the U devet uh main page and just
go to the Explorer and we're going to
copy paste the address that we gave to
the faucet and see if it actually has
some money all right so it does uh we
had 100 it which is uh that amount of
USD I don't I don't think so but anyway
um yeah so now we're ready to execute
the test um let's just do that uh let's
see yeah basically what I just explained
we're going to use the execute command
um you need the faucet to obtain the
fonts uh here's the link to the faucet
uh but it's also on the other page that
I gave you um if not possible if you
need uh for some reason the f faet is
not working just let us know we can send
you funds into the your to your address
um so yeah I just and also I already
check this uh in this page just um all
right go to this page and go to Explorer
paste your your address and you will see
the same thing
basically uh yeah just let's just do it
um all right so this is the command to
execute the the test on the live Network
that we're going to use to run uh right
now um you need uh you need to paste the
private key that you generated over here
and then the rest is basically the same
so let's just do that and see what
happens I'm gonna I'm going to keep an
eye on my the address that I give me a
second
so so
yeah to make it easier for me
yeah M perfect
um all right so
yeah so again UV run execute then just
modify the private key just put the the
key that the script gave you over here
just copy paste it here and yeah let's
just hit go and see what
happens and let me explain a little bit
of the of the
um uh the
parameters um so yeah the parameter over
here is basically just how much e should
I should the test take from the your
account in this case just take 10 e
which should be sufficient to send the
test um the the RPC chain ID which is
the deet um um that network ID the fork
uh this is irrelevant we're going to use
Saka
eventually but for this for testing
purposes it's fine whatever you put in
there is it can be can or prag or we're
going to use Osaka eventually and then
last uh but not least the name of the
test so you can see right now that it's
already running and you can see the
Green Dot here which means that the test
passed so let's see what that means
let's go back to the Explorer you can
see there's already transactions uh
going on over here so there's one
transaction out and there's one
transaction back back in so this is this
is the account that I just generated um
this is the the the the the E from the
faucet and this is the transaction out
that will uh um make uh that will fund
the transaction that is actually running
test so let's see what that that transa
that account is doing so this is a new
newly generated account that execute
created for me just to run the the the
test let's see how that let's see over
here okay all right so yeah so the first
the first transaction is just the the
funding again but then it's going to
create here over here it created a
contract what is that so if we go back
to the to the to the test the first step
in the test as you can see is the
predeployment
that it was created and then it was
called later but then let's let's focus
on the code that the that this code uh
sorry this contract contains so yeah as
you can see it's the same basically the
same code that we s saw earlier um let's
go back to the code put it
um side by side
yeah yeah all right so yeah this is the
code that we deployed so basically just
to push operations this is the one over
here this is the
zero over here the SS store is the 55
over here and lastly the stop so as you
can see we deploy the contract of the
test in the live running Network um it's
it doesn't end there because we need to
ex execute the code to actually see what
uh what happens so let's let's see just
yeah yeah
and okay so so the contract was created
and then the next transaction is this
one over here and that one is the the
funding of the account so we need a
sender for the transaction and that is
how it was funded um we funded that
transaction with uh one e only and that
is the one that is that is the account
that actually sends the transaction to
the contract so let's open that uh that
account see what what it looks like
all right so yeah it's funded and then
it it called the contract so let's see
how that looks
like all
right perfect so yeah as you can see
this is the transaction that is defined
over here in the in our test so this
transaction um we set up a couple of
things so the contract address the
sender is that the one that we just
funded and and most importantly you can
see other other properties such as the
gas limit is over here it's it's going
to use the same gas limit um and it's
also going to use the same value so the
value is over here exactly so it's not
one e it's um uh one to the to the power
of minus 18 e so it's basically nothing
but that is what we sent over here um so
yeah how the main question I think is
how did the test pass
how do we know that it passed um so what
execute does in the background is
basically uh execute the transaction but
also go into the contract after it was
executed to see to see this
stuff uh to to to verify this so what we
can do is actually just modify something
in the code to see what it looks like
when the transaction sorry the test
doesn't pass so let's let's do that just
now let's modify um let say the the
storage let's set set it to something
else which is not going to match with
the storage over here and let's just
send the the the test again to see what
happens
yep no I it's executing again do not
have to fill any anything it's actually
the execute command takes the python and
it runs the the com the python lines
into the into live Network so the
filling process is is is is not
necessary in this case yeah yeah
so yeah the reason why it's taking a
little bit is because um it waits until
the the contract is deployed the
transaction is funded the sender is
funded so all of that it has to be done
done serly because everything has to be
there uh for the transaction to to pass
and as you can see it already failed um
it's going to tell me why in a little
bit uh but it it first even if the test
failed it tries to return the funds
because imagine this is a deet it's the
the the the if that we're sending
doesn't matter but let's say that we're
running in sepolia which is a little bit
more limited so that's why even if the
test failed the the execute command
tries to get back the funds from all of
the accounts that were involved with the
the test so yeah it's complaining right
now um basically what it's saying is
that okay you told me that the value of
this of zero at this address it had to
be uh it had to be uh one but it
actually came out as two and this is the
modification that we did over here um
yeah so you can you can this way verify
um that the the the that the test is
actually doing something and verifying
stuff um so I so let's let's wait until
um has anybody else uh executed
something uh how's did it work all
right yeah
Yeah so basically it but it goes to the
RPC and tells you okay how many how much
e is left in the account just substracts
the cost of the of the refund
transaction and that just sends
everything everything back that's that's
that's basically it
yeah um let's let's do let's change it
up um a little bit so let's create
another contract um let's create another
contract that calls into the into the
first contract let's call it uh contract
address number one contract address
number two so let's do that call so the
the let's let's make it so that the
first contract calls The second contract
um so yes this call and
then address is going to be oh it's
going to be the way
around so one all right
and this is just to just to show how it
can create multiple contracts in the
same test so yeah basically the
modifications that I just did is just
let's create uh two contracts now
instead of one let's the first one is
going to the first one is going to uh do
the SS store the same thing that we did
before and the second one is going to
call into the first contract so it's
going to be an internal call we should
see that on Explorer if everything went
went all right so um let me see if I
didn't make a mistake
sorry sorry ah yeah of course yeah that
is very true yeah the balance is going
to be incorrect thank
you perfect all right um yeah let's just
execute it and see how it
goes let's let's see let's see life
um see
perfect
yeah yeah so there you go
so all right so yeah there there you can
see um so we are now creating two
contracts instead of one so this is the
this this account is the test
coordinator so the first thing is that
it gets the the funds the second the
second part is going to create the
contracts two of them this time
um and lastly is going to um let's
see lastly is going to do a contract
call and the contract call is going to
go into the first contract that we
created so this is 0x 827 let's see
where is that
oh wait
wa
M yeah so yeah let's let's see it by
side by
side there you go so yeah so the first
the first contract that we have is um
the the the first contract creation this
is going to do the SS store and the
second one over here is going to be the
the one that calls the first one that we
created so this this one um no this one
is going to call this one so let's see
and then lastly the the third the third
transaction we're going to see is Al
also the the the the funding of of the
center so let's go to to the funer to
see how the transaction went so because
we we Al we're Al going to see the
Contra call to the first contract let's
see
that and see how it goes um yeah of
course so you can see right here um so
the the transaction is mostly the same
but what happened is that we're going
into into the first contract and this
first contract it made an internal call
to the other contract so you can see
this right here which is the
um which is the um the the the is done
because of the call uh up code that
we're using on the on the other contract
so now you can you can you can see that
the two contracts were created and when
we called into the contract the first
contract the entry point contract it
made an internal Al call to the other
contract so let's see if the test passed
actually there you go it passed um but
now the verification is a little bit
different because instead of verifying
the first contract the one that is the
entry point we are verifying another
contract which is the one that's receiv
receiving the call and setting the SS
store uh over
here y
was any anybody else uh able to
execute
yep parison and then when I Lear it on
the test it only shows like the back and
for Trans it doesn't show the contract
so I'm not exactly I see okay so because
there's uh there must be a contract the
sorry this one this one is the one that
is doing everything basically oh okay
it's not the key that provided yeah yeah
so the key is only uh the key sends to
the test coordinator and the test
coordinator does everything that you
define in the test got you very
good so what what's happening is that um
um the transactions that we are seeing
over here they are not there the only
the first one is sent from the private
key that you entering in the execute
command the rest go to a test
coordinator what what we call it the
test coordinator is the one that creates
the contracts and sends transactions um
so that's why you might not be seeing
the the transactions in the in the in
the in the in in the account that you
that you funded from the
faucet let's see how
how many how many transactions are we
seeing so yeah that's a lot of movement
all right um that's
great so yeah all right so everyone's
running the tests and luckily or
unluckily we haven't seen any any any
deviations in the in the chain so the
chain is still healthy um let's let's
let's try to test uh make another test
and let's try to uh change uh the change
this thing to see if we can figure out
how to break it um
yeah all right so we already did that um
modify the simple test is basically just
we can change the smart contracts at uh
add more smart contracts our
parameterization I didn't didn't um do
that but we uh we can we can do an
example in the next next uh next test
and yeah change expected outcomes that's
another thing that we can
do all right so let's let's see a little
bit on how we can test a a new ethereum
feature so what happens when we receive
a new AAP and we want to test that uh
this is the this is basically the work
that we do um when we are uh preparing
for new
Fork um so every every change that goes
into ethereum happens because of an
ethereum improvement proposal um they
are uh they are basically the updates
that go into the fork and that uh they
get approved and uh and then we
Implement them and we have to implement
test for this uh this is the
repository uh that we can um that we
basically we we save everything uh the
all the all the all the eips come into
here and um and this and basically you
can see the whole history of ethereum
over here uh you can see from the very
first EIP you can see that new CS for
prag and all that everything is
here so today we're going to focus on a
an untested uh EIP which is the 5920 it
introduces a new OP code and the goal
here is to make a test that uses this up
code that breaks the chain um so what
what does this this thing do let me just
go over the EIP it's very simple the
idea is that
um the idea is that in ethereum every
time that you call from a smart contract
into another contract you if you want to
send ether you have to make a call which
means that you're going to execute the
code that lives in the other smart
contract so the thing uh the thing that
this up code changes is that you can use
this up code to basically just send
ether to another account and do not
execute anything which is very useful if
you don't want to do like uh re-entry
iny and you don't have to have any
reentrancy problems and all that stuff
this is the out code that you eventually
in the future you could use to prevent
all that stuff um just send e uh to
another account don't don't execute any
of the
code yeah normally we use call and
delegate call to call the other account
send send some funds into it and just
limit the amount of gas that the the
contract receives just to make sure that
it doesn't execute not anything that
doesn't have to
execute can stop
yeah all right
um um I'm going to stop a little bit is
there any questions so far how's
everyone doing um questions uh issues
that you're
seeing with the code or
anything yes
sorry oh
sorry have we done already any other
transactions
uh not only minting or not only
minting no we we we send the transaction
but no there was no meeting
using theet to get oh F was it's was it
was the single transaction
we
I so if I send an ether to an contract
that doesn't Implement any
fallbacks does it still work or would it
revert
um I think I think with this you can
work around the fallbacks because it
will send if even if there's absolutely
no code uh if there's a code that uh
revers the transaction because it
doesn't want to receive it this would
basically just uh skip that so yeah it
will render some of the fallbacks uh
unusable that is that is that is true so
yeah that's that's one of the reasons
why this has not made it into the into
the chain um because it's there there
are some edge cases that exactly what
you mentioned you can you can work
around the fallbacks with this thing uh
you can already do it if you use
self-destruct you can basically send any
amount of the to any contract even if it
doesn't want to receive e
yeah so yeah let's proceed
so yeah um we're going to um we're GNA
assume that this uh EIP goes into Osaka
it's not the case Osaka as it is right
now it's only going to introduce the eof
EIP but we're going to assume that it's
going to inaka anyway um so for that
matter we we need to add the Osaka Fork
into this file uh for everything to work
uh in in this case um let's see let's
see in this specific case we already
have Osaka in in in our definitions so
it's not a problem we don't have to add
it uh but in the case in in when you are
implementing some EIP that goes in the
future that is uh later than Osaka you
would need to go into this file and
create uh the new Fork but this is not
the case it's not necessary Osaka is
already there that's what we're going to
use all right
all right and lastly since we are
creating a new up code we need to
include this in in in our in our in our
in our in our framework so the way we're
going to do that is basically just this
is the code that you need to add into
into the etherum um test evbm up code
file so let's just go ahead and do
that again this code is uh this link
should be in the in the in the hackmd
that is that was provided at the start
um but otherwise uh yeah just feel free
to to open this link and this we're just
going to basically just copy the
code I'm not actually
sure actually there was an issue and it
was fixed because of that
okay all
right so yeah let's let's go ahead just
copy the code and let's just put it in
the in the evm in and sorry the ebm uh
up codes
file
um there you go so this is the thing
that we're going to use uh to um
actually use the the new up code into
into our
code so again again uh just go to this
link um copy the code come here to the
up code.
p and inside of the class up
code just basically just copy paste it
at the end as you can see
here I'm going to give just one moment
all right um
and finally um we can write this a test
from scratch but in this case we already
have a template um for the simple St
that it's going to use this sub code um
so let me just uh open it up and and we
we can just uh analyze what's happening
over here um
yeah so yeah this is basically the first
test that we are going to create this is
the simplest test that you can imagine
for the EIP 5920
um it basically just tries to use the up
code uh but the catch is that you're
going to send money to a the contract
that execut some code in this case up
store as we did in the previous test you
remember that that's the thing that we
going to use to test storage um but you
shouldn't see this change in the in the
execution so what should happen is that
from one contract that is going to pay
the other contract it should not execute
this code so instead of uh writing in
the postate that we should see a one in
the key in the zero key as the previous
example we're going to expect that to
see nothing in here so that that would
prove to us that the pay up code sent
the eth without executing any code so
let's just do that let's just copy the
code and we're going to right now going
to paste paste it okay let me I I skip
one bit um so
yeah in the in the test repository um we
normally when we are creating a new Fork
we come here and create the new uh Osaka
folder for example the the for the the
folder for the new Fork um so in this
case I've already created uh the the
folder for the file so you can place it
here so basically just create uh inside
of the test o SAA folder just create EIP
to create uh uh first the the file that
is required for python to recognize
there's something here which is the
underscore uncore init underscore dop
and it can have nothing in it it's just
going to be there but the other that
we're going to create is the uh test pay
testore
pay.
Pi which is which is where we're
going to paste the the new the new the
new test um that we just creating um so
again uh very simple test just use the
up code uh to a given recipient verify
that it doesn't execute code and we
actually can just go ahead and run it uh
it's going to be the exact same command
that we use the only change that we're
going to see is that we are going to
execute this new file instead of instead
of uh instead of the the other file that
we were using so let's go ahead and just
do it
okay and another important difference is
that um where is it okay instead of fork
Cancun we are now actually using NOA and
the reason is that we need uh to make
sure that there is U no compatibility
issues so we're going to that's the only
change that we're going to make so for
Goa and then also point to the new test
and let's see what happens
let me just copy the address that we are
using for this just to follow up on the
on the transactions
Perfect all right so yeah the test is is
currently running
um it's already passed but yeah let let
me just again explain a little bit um
it's um it's basically again just
creating two contracts the one at let me
let me open up the test side by
side all right so it's creating two
contracts the first one is going to use
the uh the s store um and this one is
the one that is going to get paid um the
second one is the one that uses the pay
off code to pay to the first uh contract
so um what we should see here actually
is let's open up the the
contract and see what happens um where's
value now there I got it the other way
around so
yeah so yeah the first contract the
first the first contract is this one it
contains the SS store let's see the the
code inside of the
um
wait yeah
let
e for
I think yeah I think I think it should
work but um I'm not seeing the the
balance change but
ex yeah yeah yeah but the problem is
that uh I'm not seeing that balance
change here so it should should be the
balance should be one in
here um because this is one that receive
the paid up good it might be that uh
there's a problem with the Explorer
um yeah we can
be yeah yeah sorry
um all right let me let me just change
the test a little bit so what happened
was that the the two contracts were
created and the problem is that I'm not
seeing the balance change in here I as I
I think that it might be a problem with
explorer that it's not updating the
balance or
um or it might be some some other issue
but what I want to do to verify that it
works is maybe just change the value
amount and just see that the recipient
contract it should have the balance the
New Balance um which is two let's see
let's just run that again and see what
oh there you
go also let's see if the Shan is
still it's having no problem still
all right so yeah basically it's working
but I'm not seeing the updates in the in
the Explorer it might be because it's
not expecting some extra up code that is
not called to change the balance balance
of the of the of the account but it
seems to be working here because we have
this uh let's let's just change that to
see to some other amount to see if it's
it it should fail now then
send it
again yeah so now we're seeing the value
that is it has to be two and I just
hardcoded one just to make sure that it
it's actually detecting the the change
correctly where's the recipient okay
yeah there you go so yeah it's working
it's just not in the Explorer for some
reason um so yeah we I think we found a
bug in in the in the bu Scout Explorer
it's fine um yeah the the verification
is working we are paying the contract we
we saw that the Des pass when we were
checking for the balance that is equal
to the value amount so it was fine and
when we modified that amount it it
failed so yeah it's working it's just
not seen in the Explorer for some reason
um yeah we found the bug not not the way
that we wanted to find the bug but we
find the bug anyway um all
right let me go back to
the to the
presentation
yeah um yeah so with that in mind um
this is like the first very very first
step when you are testing a new AIP um
you basic basically do the simpl test
first just to make sure that everything
is working but we can expand uh the
testing and we must expand the test the
the desk coverage to include many other
different scenarios including Edge case
scenarios that is very essential for us
to see that the upcode is working before
it can actually uh reach mainnet um just
some examples um of just very simple
test that we that we would do if we were
testing uh AIP 5920 just try sending for
example more balance than you are
actually have because you are paying yes
but if you don't have that balance there
should be an exception um what else try
sending balance to precompilers which
which is um important addresses in the
etherum blockchain we have preol for
many things but just to make sure that
it doesn't execute anything uh with the
pay code you would uh try sending uh
some some some e to that to that
pre-compile um test running without any
enough gas that's a very important one
to make sure that uh that you you that
it R actually runs out of gas it doesn't
send the E uh try sending the balance to
yourself that's another another option
um and yeah basic up Cod stuff U we we
saw that it needs two parameters uh just
try to do a stack underflow by just
putting one parameter and see that it
fails correctly that's just one example
um yeah um there are there are some
things about 5920 is one of them is is
that it doesn't um specify a lot uh
things um we normally when we are
developing the test there are a lot of
times when we read the specification and
it's not clear enough so one of those
those example is how um um how how
should it behave when it doesn't have
enough enough funs so that's one thing
that we should definitely test and add
to the test cases um
yeah all right so but another one is
that um
what should happen uh what should happen
to the to the to the account when you
are already doing a call and then you
pay uh use the pay up code you shouldn't
see any difference in in what it's
called the return buffer um so that's
that's what we're going to do right now
we're going to write that test and see
happens all
right so yeah very simple um Let's do
let's do first a
call and that let's store
Perfect all right so let me just explain
quickly What's Happening Here
um so we have two contracts again uh the
first the first one is just basically
just returning information to the first
contract all right and the second one is
calling into it so uh what happens is
that if we if we call a contract you're
going to get what is called the return
buffer so you will see in that buffer
you you will see an one single bite
because of the return uh the return
property so what happens is that if we
call and then we do the pay operation we
shouldn't see any modifications to the
return buffer right so because we are
not executing any code we shouldn't
there should be no reason why the return
buffer is like modified or even cleared
or anything um so yeah let's um let's
just do that this is this is an OP code
that is basically just gives me
information about what is in the return
buffer in this case it's going to give
me the size of the return buffer I
should see a one still because um
because I'm calling first then I'm doing
the the P operation and there shouldn't
be any modifications so let's see what
what what happens when I uh when I try
to store that and then um yeah let's
let's see just what
happens and the interesting
thing
mhm all right
so the the test here ideally should
pass but we already know that there's a
consensus difference between the two
clients so we're going to probably see
the test pass here but let's see what
happens with the network once we uh once
we execute this
it's taking longer than usual and that
might
be let's
see there you go
Perfect all right it's not it's not as
as clear as I would like to but you can
see now that only one is following the
chain we just found the consensus book
basically just by trying to follow the
spec implementing the test sending it to
the network and we can see that now
exactly there you go we can see the
split
here this is a very very simple test and
this is why we we create these tests so
this doesn't happen on mainnet or even
in the test Nets um yeah one client is
progressing the other one is not
agreeing with what it saw just because
one line of the op code was different
and the result was different what from
what it expected
all right I'm just going to um continue
with the presentation just try to wrap
it up um so yeah what we can learn from
this um so yeah um this shows importance
of the consensus test uh if we didn't
have this basically this could happen on
the on the on the live Network on Main
net or on a test net uh we don't let it
happen because we write the consensus
tests and this is the importance of the
consensus test all the clients before
they they they join a a test net uh or
or even a Dev net they must pass the
consensus test that we create this is
very important for them to not Fork out
of the chain like we saw happen uh today
um if one another important part is that
um if a if a client they are running
tests everything is passing but they are
sure that they found a bug in their in
their client and we didn't catch it that
is feedback feedback that has to come
back to us because we have to create
more tests to make sure that their their
Edge case or their scenario is properly
tested so it doesn't happen in our
client um yeah also specs can sometimes
be under specified um it happens uh
there's sometimes that when the EIP
writer is thinking of the of the use
case of the of the the feature they
don't think of all the US cases so it
had happened that we are implementing a
test and we don't know what the outcome
should be we go back into the EIP we
improve the EIP we specify the thing
that was under under specify and then we
update the tests um so yeah it's a it's
a it's it's a it's a running process um
it's it's never U It's never enough
until we are already tested with most of
the clients most of the clients are
passing and that's when we are sure that
the um that we can hit the test Nets uh
with with the with the new
feature yeah um yeah one ex one great
part of having uh uh the theorem open
ecosystem is also so that test are also
verifiable they are open and so I
encourage everyone that if you feel uh
there's a uh there's a new feature that
you feel unsafe about we encourage you
to go into the tests they are open you
can everyone can verify what we're
writing what the test that we're writing
so if you find something in the in the
eips that you think that is under tested
uh you can also be even legible if the
feature already hit mainnet you you can
also be eligible for a bounty so uh it's
good to write test it's better to
receive money to write tests so there
you go uh you can use a repository if
you find something that you think is
critical one thing that you should
consider is that if you trigger such an
issue on a on on on a main net or a test
net you're no longer legible so
basically if you find you think you
found something by using your test or
any other means go to this page but do
not send a a a breaking transaction into
the into any test net because that will
make you not eligible I think um for CR
consensus critical tests or cons sorry
consensus critical issues you can get up
you trigger it you loose you lose that
so reach out uh uh explain us the
problem and we are we're going to try to
make sure that the clients fix
everything before making everything
public yeah that's basically it
yeah yeah so if you enjoyed today and
enjoyed writing tests uh like I mean the
main main message is uh reach out to us
and like I mean if you want to work with
us contribute with us get in touch um
but also like you can find us if you go
to a
documentation um you can go to getting
started getting help and then you can
find all of our like details
to get in touch with us and if you
really enjoy it and you're at a bit of a
loose end um then feel free to apply for
the job that's on uh ethereum's lever as
a protocol tester so we have a position
open for execution spec testing and
consensus spe
testing of course
um and I'm just going to show like the
test coverage so if you if you want to
browse for test cases it may best best
to not like browse the source code but
go to our documentation make sure you're
on Main and go to test case reference
can can you show
no where is
it so you can find all of our contact
details here and just feel free to reach
out um and otherwise um You' really we
covered a lot today in the workshop but
uh if you'd like to see a little bit
more and a little bit of a history then
feel free to come to our talk today on
stage one at
me I've got the
QR thank you everyone
I like you if if you enjoy it it's great
very well
that's great to hear because I struggle
a lot to yeah to to see I mean it's a
lot of information and and um we tried
to put it in a condens way it was it was
really struggle but I I I'm glad that
you guys enjoyed it I'm kind afraid that
is there any
PR but you prepare a
lot following the
steps yeah yeah yeah we try to make it
easy for everyone to join question about
EF
EPF is the plan for next year NF I I to
why all right that's that's great that's
great um so probably uh I'm not the best
person to to to answer that I from my
perspective I think it's it's great that
we have it's great and I think the
people that kind of come out are very
valuable they they amazing so I think
probably next year it's going to happen
but if you want a compute danc I go to
the EF day there's a classroom right now
happening and they are presenting the RO
so you can also learn nor when it's
going to
be see examples of of what people has
inside of which yeah a lot of
interesting about that it is
classroom another question I saw the job
job and I wonder why
should be Jo
there yeah because uh there's a little
bit
more yeah I mean not not really because
it's too late but um the Slayer research
team they want uh a position to be F at
their list so we can make through right
now so the execution uh Team we have
plenty of testers of demitry and Spencer
they all have
so we're basically cover we are under a
lot of yeah we have a lot of work but
it's not the end of we can cover but for
Slayer they really need a tester for
their their to be basically just have
the tester rules classes on and just see
the code and see that everything is
actually tested so yeah that's that's
the how many
cons so the there's basically two uh so
the cons M no no no sorry not members I
understood teams so there there are two
teams uh the one is the consensus R&amp;D I
don't know how many people is in that uh
but the consensus Rd is one and the
other is I forgot the name um there's
another team that is also looking into
the research part and the and the sorry
the application part of the of the
consensus specs they they are a lot more
involved in the actual writing of the
code of the cons it's pretty interesting
but it's like more um more for example
more heavy on the on the on the
algorithms because you have to know
Casper you have to know all the all the
consensus mechanism that that is really
really
intensive academic exactly exactly
execution is more like uh we we we test
new out codes which is like Computer
Sciences like more more more hands down
more more grounded um we do do see a lot
of cryptography but it's it's not that
coming it's more like computer science
problems they see more stuff yeah more
research in touch with the members in
the consensus uh testing team yeah I
think the best you can do is um well the
consensus are on the U there's a there's
a Discord Channel and and you can join
that and you can follow the uh the the
discussions there um so I think what I
would do is uh if you are really
interested in in in in in Touching that
part and aspect of the of theem is that
I would go into the specs repository
just see what is happening and just read
new vs and everything just maybe and
maybe try opening a PR by yourself uh to
see to to to get their attention uh of
the of the of the maintainers the thank
you so much no problem glad to glad to
that you enjoyed enjo yeah yeah
yeah Mario
do do you know Mario or or or Josh have
you seen them they not yet
IE they are here and they're having the
EPF dat right now so you can go and
maybe between presentations just hit
them M and say Hey I want to be part of
this and then get their attention um
it's important because they they they
review and it's better if they know the
person personally uh so I think it's
it's a good chance that you can go in
there and just talk to them and
see yeah yeah there there's a classroom
right now I think Spencer should know
exactly which
class if you want to ask
him
sorry okay
okay
never
so
bad I think
you have
way
was
St
p
so EX
back back
I
Hal
spe for
Happ
say
than
that's
you about to keep
I mean
thanks so much IRA
that's quick
she
Prin
look out
yeah
minut
you know this time
okay let
true
love
oh oh
wel
C
good
it like
I know I know
is
m e
than e
you e
hello everyone uh great to be here my
first Devon talk ever uh so super
excited you join me um I'll be talking
about the counter protction I have been
building a def consumer app in Brazil uh
it's called picnic we have been in the
front lines trying to get web two users
to be on chain and execute transactions
on chain and the idea here is to share
what we learned um so who are we like
building consumer defi app very focused
in Brazil right now um we are seeing
like really interesting feedback from
users
um so like when I go to conferences in
Brazil and I meet people there uh it's
really nice to see that people really
like the product connect and see the
vision and see the benefit in using
day-to-day and there's two metrics I
really like about that there's something
called Shan Ellis score that is
basically uh a form you send your users
and you ask how disappointed you would
be if you canot use the product anymore
disappointed which is a compelling thing
that people really care about what we're
doing and we're seeing really good
repeat usage so once a user swaps
there's a 57% the user will chance the
user will swap next month um so this is
really good we'll put that a bit into
context but it's a real world use case
that we have been seen repeat usage and
on the D5 front with account abstraction
we are doing really good volumes uh so
we're doing a close to half uh the swap
volumes using RC 427 across the main evm
chains and why did I decide to apply the
stock uh and and come here to to bring
what we have learned I think we talk a
lot about Mass adoption and though
everyone needs to be on chain but I
think that this is very vague and
Abstract uh there is I mean at least on
the talks I have been
participating there is not a whole lot
of depth on how you actually do that
like from the point we are right now how
do we evolve this thing to really get
people
to mass adopt it and and use it dayto
day and as we are building uh something
with like a few thousand users and we
have been shipping
iterating and learning uh I thought it
would be valuable to come here and share
uh what we have been seeing um
for who this talk I think it would be
valuable as everyone that's interested
in Mass adoption and getting the Nuance
on on how to get there uh it will be
mostly focused in strategy and product
is talking about what decisions we took
why we took them uh so Builders people
on ecosystems VCS I think everyone can
see some value here um it should be uh
pretty open so if if you have any
questions at any point in time just
raise your hands we we can make q&amp;as and
and talk a bit and explore topics I
think
they're uh
very I'll give a brief overview and we
can deep dive on in a specific topic we
want to uh I don't have I have 50 slides
or so but I don't think it would be
enough to cover all the time so yeah we
have time for Q&amp;A I think it would be
valuable and to give you a sense on what
we're covering uh I'll start giving you
uh an overview of the account
abstraction landscape uh kind of what's
working what's not then we'll talk about
bit uh which kinds of users see the most
value from this piece of technology and
how should we approach the the two set
we have what's working best then are
going to picnic uh trying to give a
sense of product decisions what work
what the and and uh small tweaks we made
that make a difference we're going some
through some of our user research and
then going after
like What are problems we see today how
can we solve that how is the road map
for the future
like I think we learned some cool stuff
but there's a lot of work ahead um so on
the account abstraction
landscape uh if I would summarize
account abstraction in one slide you
basically get a bunch of different
problems like authentication uh guess
like teaching users that you need a
specific token for a specific chain to
pay for gas I think that there's no way
this thing will be Mass adopted just
because of that one thing seed phrase is
another thing that is like doesn't make
sense to have to teach someone about a
SE phrase to be able to onard it right
people should just be able to use it and
the thing should work same as chains and
like transactions approv swap anything
that gets a bit more complex is it's
just too much work if you're talking
with the average person um so account
protction it solves most of the these
issues or at least give you more options
on things you can build and the result
of that it should be that um it should
be usable by Web Two users so account
abstraction I think that a fundamental
promise is like
you can break the bubble and you can
make those products usable by a much
wider
audience and it's growing like if you
see the charts most dashboards you see
things like this so this is number of
deployed smart accounts across the main
evm chains uh Trend looks
good uh not act exponential but still
healthy and it's kind of obvious it
should grow like you're making it easier
to use so like if something is easier
people just use it more right uh but if
you do some more detailed analysis and
you look at individual projects the
trend is not usually that just make it
easy and things will go this kind of
pattern that you see like spikes and
things dying down this is is very very
common across the space
um not sure who has seen that but there
this retention rates for the whole
account abstraction space so like this
is like 2% retention for the first week
the the best one we have here in all
ones is like 12% which is reasonable but
like most are four or three is really
really low retention so for every 25
users you get only one returns next week
to do something so there is this uh
problem with repeat usage and uh the the
main thing here is like why this thing
happening right like why people are not
coming back to do transactions next next
week why the value is not being
sustained um and just to get a sense who
here is using account abration Wallets
on like a monthly
basis okay so five people and who he is
using Wallets on a monthly
basis
yeah and this is kind of my point I
think I don't use I like I I use picnic
but it's a different use case I don't
even think Pi about picnic as a
wallet but account abstraction wallets
are not a very good solution for web Tre
native users I think they are worse than
youa wallets for web Tre natives the
first one is you pay more gas there's
gas overhead to be able to use account
of traction
wallets second thing is limited use
cases um so if you want to deploy in in
a new chain if the wallet provider using
it doesn't support that chain like if
you want to do that
manually maybe you can't maybe you can
but you need to be a developer so it's
it's this weird thing that uh
you you can't do whatever you Ed to do
you don't have that much Freedom uh
there's stbs that won't work with that
if you deploy it on ZK sync you have a
different address so there's all those
weird curve
quirks that yeah it is worse in terms of
use cases and you also need to learn it
so like I spent my a lot of time around
the smart contract wallets I know how it
works I trust it
but if you talk even with the typical
web tree native user there's a learning
curve here is probably the most
sophisticated piece of that cohort so
people get it how it works but like uh a
lot of people is why does it have a
different address where's the S phrase
of the smart cont quality and all those
questions that come up that you need to
educate and that is a learning curve and
in the end like you your paymark gas you
have less stuff to do but you already
learned how to operate a eoa wallet so
why you're going through all that hassle
like you don't really need a smart
contract wallet you can do it without so
that that's the thing that's like trying
to put uh accounter projection as is uh
in the hands of web tree
natives is not the path I think 7702
changes a lot of that but for now uh it
hasn't worked I have I don't know of any
examples and the examples I know that
are working well in a different
direction and and the question is okay
so web Tre
natives not really working so for who
this technology adds value and the thing
we have been seeing is
like uh people that cannot do it
otherwise so if you have someone that
wants to do something on TR be it
because you wants a a product that's
noncustodial or want to buy a token
that's not available anywhere this
person doesn't really know how to use an
EA then you can deliver a lot of value
because it's not a matter of like being
easier than the alternative is being a
matter of like can I do it or can I not
do it and the person like doesn't have
the option of the
EA and and getting specific use cases I
think it's it's an important one as well
like poly Market I would put in that
bucket World coin in that bucket that's
people that is like
more
uh if you abstract the uax and you make
a very simple flow very easy that that
seems to to work much better than trying
and the the thing that we're seeing like
this is the kind of chart I showed like
you got spikes you you got web users you
got a lot of hype but it's very hard to
sustain it the one on the right is
picnic that's weekly transactions for
the past few months uh you don't see
necessarily the big big spikes but it is
retention is really good so people come
they use the product they like it and
they keep using it
um and the idea here now is like to give
you a sense on what are the product
decisions that we made and why the thing
is working but now like any question so
far how is that
going just okay I'll keep pushing and
then we can do Q&amp;A later or because
already went to like 20 slides and yeah
let's see how that goes um so
the things like the idea here is is go
to the things we I think we did right
and what were the key learnings we had
in each of the steps um so first thing I
think one of the ways I describe picnic
is that it's a centralized exchange like
experience or a finch like experience
but everything running on chain and I
think focusing on that very very core
use case it has
been it makes the product much easier to
build uh it makes the product much
easier to understand for users there's a
simple use case you can you come to buy
and sell tokens
basically and it make makes it easier to
use there is just a single
flow and one thing I think uh we spent a
lot of time is just like okay account
abstraction is really nice I think it's
a fundamental building block if we want
to to deliver uh we like dii for a wider
audience for web 2 users but what else
beyond that do we need to build so what
other building blocks are key and
critical and I'll give you an overview
of the the whole product this uh we see
here is basically like the main uh
pieces of the flow I'll get a bit more
in detail but basically you can sign in
with Google you can sign in V mail if
you want to connect with an external
wallet you can as well and once you sign
in uh one of the critical things we
spent a lot of time thinking about is
how to
integrate um onchain with offchain so
that this thing here this is uh iban Ian
is basically a European bank account so
the second line is a bank account number
if you transfer money to that iban this
is EUR this is live in Europe uh we're
mainly in Brazil but we're also present
in Europe and I think this is a better
example because it's onchain bank
account that's the abstraction I'm
making if I transfer Euros to that
iban uh Euro stable coins are
minted in the wallet as soon as the
money arrives and if you transfer1 you
receive like1 in your wallet and you can
spend from there and this is like the
swap FL so like let's say I transfer €
wallet I can buy ARB with that uh so
that's kind of the flow is very similar
to what you would get in a fch very
similar to what you get in a centralized
exchange but that's all happening on
chain uh with pretty pretty abstracted
ux and by every one of the components of
that flow um so it's basically
authentication on and off ramp gas
chains transactions and a few other
tricks um on the authentication part um
you basically have Google email and
external wallet uh a a very peculiar
thing we learned like we have been
iterating with this sort of product for
almost two years uh we didn't start with
uh connect with the stal wallet that's
something we added much
later and it's really interesting at
least on our perception that just giving
the ability for the user to connect with
an external wallet connect with metamask
or anything else uh most users are not
using that that is fairly complicated
and and not really the point of what
we're doing but it helped increase trust
a lot uh maybe not necessarily with the
end user but for example content
creators and YouTubers and and people
that really helped us grow they trusted
us a lot more when we added the option
to connect with metamask because now
it's much easier to understand that
things are actually happening on chain
and this is actually noncustodial so
that that was a a small detail in the
user flow that makes a lot of difference
in how you Market it and how you access
users and how you can distribute
um some other thing that I think it's
mentioned adding external wallet layer
was adding the external wallet
integration part of your uh effort to
onboard web3 natives because you you
mentioned somewhere in the beginning of
your talk that the the user is he's not
a web3 native when it comes to a it's
somebody who is outside right so what
what made you feel this was important
um people ask for it like a few users
ask for the external wallet uh option so
that's why we added it is just like
people are asking quite a few let's
Implement that but it's like 15% of our
users use external wallets right now so
it is significant but in my perception
the biggest gain we got from the
external wallet was the trust that
people see you can connect with anal
wallet so they understand quicker it is
noncustodial um yeah
but if we're seeing Web Two users
migrate to external wallets after they
start using with email we have not been
monitoring that um I don't think it's
happening that much uh still like people
use email lugin still a lot um so we're
much more in the path to improving email
login and getting a a
better uh security can could you get a
microphone there can can I get some help
with the mics
titles um but yeah the external wallet I
think is mostly good for for trust so I
I'm curious did you build your own
custom Mo or did you use something off
the shelf uh we're using magic link
magic link yes yeah but that's just for
the email right is or is it also Google
authentication we we have for both okay
gotcha gotcha and that the external
wallet is a separate thing yeah it's
separate the external wallet it's it's
directly I think it's contic kit that
connected with wagi and that's wag yeah
all right thank you okay
I'll keep you a permanent
mic yeah and one interesting learning we
had on this off piece is that getting
something that is more
centralized but is more
reliable is is much better than more
decentralized and less reliable like if
you're having trouble with like 3% of
login cases which we had with the
different provider that's a really bad
thing like this thing cannot break never
it's like it's very important to be
super super
robust um so now which I think is
probably one of the most interesting
pieces uh is the integration with uh
Fiat the off offchain onchain
integration um we we were doing defi
native stuff before and we had uh we
worked with a French protocol with
Jarvis they did a lot of uh not exotic
stable coin so they did the Brazilian ra
stable coin Japanese Yen stable coin and
spending time there uh with the founder
made me realize that stable coins like
local stable coins are the best possible
solution for on and off
ramp uh that's for mainly two reasons
first is unit off account so like people
in Europe are already used to thinking
in Euros so all your balances are in
Euros like Brazil is the same everything
is in re and in many many countries is
like that so if you're funding an
account you're already thinking your
currency better to keep that way right
it's it's just easier less cognitive
Overlord things just
work and one really cool thing that I
don't see a lot of people talking about
stable coins make money just sitting on
the money so they get the treasury y
like in Brazil they get paid 10% a year
just to hold R eyes in Europe it's like
so they have a revenue stream just by
holding your euros and give you stable
coins um so like they can incentivize on
off ramps or they can subsidize on
enough ramps which is what we have been
seeing both in Europe and Brazil we have
uh free and very fast and and very good
and on and off ramps and that seem
sustainable like we're not subsidizing
it that's the business model for the
stable coins so it is the both from the
e perspective as well as from the
economics pers perspective the long-term
way to onard
users and it's free and instant it's
it's a really really good uh uxx like
you can go from bank money or bank
account in Brazil to money or bank
account in Europe through picnic in 5
minutes and you can do the inverse as
well if you have a fast Bank in Europe
that's usually the botton neck um one
cool thing we did this was more
recent but uh across the app we're not
calling uh stable coins by their name so
the Euro stable coin we use is URI from
monum but we just call it Euros U for R
eyes is BL we just called it R eyes uh
we had uh quite a bit of feedback
especially on the less sophisticated
side of users like okay a deposit reiz
and I got this weird thing called BL
what is that um so those small details
they matter a lot especially when you go
to less sophisticated users so I think
uh spending time there in in improving
small
Details Matter a lot um one other thing
that I think is worth mentioning is kyc
and ux to to be able to onramp we had a
different uh onramp provider uh before
the the ones we had have right now and
it was a quite bad kyc process it was
confusing not very well polished I think
it it's worth spending a lot of time in
getting kyc works really good uh
conversions is day and night I think
that one of the things that that made us
able to grow and see some repeat usage
was getting the the flows easy enough
for people to onboard and start using
and then be able to keep
using um gas abstraction this is
something I think very cool that we did
like you can pay gas in whatever token
uh the user has in its wallet so here is
dollar say USD but like even if you have
some random mem coin that is listed on
picnic and the our process for listings
basically if it's in coin gecko is in
picnic we just scrape that and and list
the tokens we accepted uh so if you have
basically among like 5,000 tokens you
can use that to pay for guas so it is uh
just fees it you don't really need to
teach the user that y you need to get a
separate token to pay for this
transaction the thing just works like uh
you have Pepe or whatever you pay gas
and pepe and it's all good um any
questions
here so are you abstract in exchange for
them then yeah we actually hold the pepy
and say sell it later so and we we
settle with the pay Master yeah and
connected to the previous slide as well
so like do you did you find that you
needed any kind of uh regulatory
approval to realiz a product like this
cuz it's like quite a lot of money
handling in like at at like 20,000 foot
overview I'm just CU how the regulator
saw
it yeah we see ourselves as a a tech
provider mostly all the things we do you
could do without us for the most part
yeah and so it's still like not very
clear what we need and what we don't uh
at some point I think it will probably
get regulated now I think there's a lot
of gray
on 100% St
so uh I think that's there's a there
there's still an opportunity for us like
uh being noncustodial um uh not being
regulated if we were to hold uh users
money uh perhaps we should the
regulation the ster the
St yeah exactly yeah yeah and is that a
barrier to adopt usdc for
example is that a barrier to adopt usdc
as well or uh cuz I saw Euro and and
real but but we could adopt usdc but the
thing is that Circle does not provide a
dedicated ramping service like uh monium
for end users um they have as far as I
know they only have like ramping for
institutional institutions so if you
want to do like a a retail uh solution
we would need to find another provider
provider that could do the kyc like a
moonay or something like that on and
they would have a fee on it it would not
be probably one to one makes sense thank
you so like uh the relationship with the
stable coin is is directly with the user
so the user transfer money to the stable
coin provider and the stable coin
provider mints directly in the user
wallet it's not like
yeahand that we see over there post it
from like you generate
one the iban we see here it's one for
each wallet and that relationship is
directly from the user with the stable
coin provider the stable coin provider
has an e money license in Europe and
then they provide the Ian to the
user
yeah uh it gets created as soon as the
kyc is approved uh sometimes it's like
within a minute to three sometimes it
takes a bit
more um I was curious to know if the kyc
was made with the Sam sub or do use any
other uh third party provider kyc is
always handled by the partners so the
Brazilian real stable coin has its kyc
flow the Euro stable coin has its kyc
flow and one of the problems we're
getting is like how to make those people
talk together because it's quite bad ux
to make your use your kyc for every
product and especially with rwas and
things like that that can be really
painful so yeah those Solutions of like
reusing K sharing kyc that's really
valuable just want to add one thing
there because there are so many things
that we need to do to improve uh as a
company as a and as a as ethereum and
and and crypto as a whole and this kyc
sharing scheme is one of them like how
are we going to manage
identity and if we think like this is
just one use case of stable coin on off
ramping but then you you you can plug in
for example debit cards and if the debit
card provider is different from the on
ramping solution will you need to do
another kyc for the debit card so it
doesn't make sense so we need to find a
solution where like KY shared it's still
decentralized and everything it's
a big problem yeah just uh a ux thing
that I we found has been really
irritating is for stable coins because
they always they they're not don't
exactly Peg the the users get confused
as to why they're why they even see that
second amount and like what that means
and how do you explain that to
them it it is indeed a problem um we
solved it somehow but by the stable the
stable coins that um have direct on and
off ramping we just packed it to the to
the value because they do have they are
packed in fact because if you have 100
eres and you want to withdraw 100 EUR e
you're going to get1 e so they are
essentially packed uh they might not
value one the same in dollar terms when
you swap them into a DEX for example but
that's another issue that's another the
problem that you you mix with slippage
we've mix with liquidity but we just
packed it into the UI and it works cool
you okay nice happy to see some
questions thank you
um so it's a two-part question the first
part being that uh can you go oh yeah
okay no that SL yeah so now that you see
here it's uh Dollar in usdt on the op
Network and the resulting currency is op
on the op Network now if I want to
change and take it on a different
network so does it act like a swap or a
bridge or both that's do both like look
that yeah it's the same okay so um so
that's one part of the question and the
second part of the question is that uh
can I switch from one uh currency like
the euro to maybe a dollar or to maybe
an Indian rupee or whatever is available
at that moment can I switch between two
Fiats can I uh transfer money between
two Fiats and uh how do you keep up with
the exchange rate of the day that is my
question yes uh so the best use case we
have for that like we have ramps both in
Brazil and Europe um and you can like on
ramp R eyes you get BL which is a in
real stable coin and you can swap on
chain BR for E the way that happens
that's usdc BR liquidity pull on un swap
V3 there is a liquidity pull between I
think usdc and URI also on uni V3 or
another Dex someone routes make all the
badge and you go from R to euros and
then you off ramp the whole thing takes
somewhere on that range it depends a bit
on how long Banks process and a really
cool thing is it's really fast cheap and
and thex is really like is faster than
wise it's cheaper than wise and
yeah one like we received
some it's more of a bet perhaps um for
the new user we implemented a separated
Swap this is like the complex swap that
J is showing perhaps um we have a
dedicated swap just for Fiat that we
that we're trying to experiment but
exactly like users that own ramp with
Brazilian Riza want to offramp with
Heros and vice versa they could use the
specialized swap just for fat so this
can be like a money exchange used case
also yes it could sure thank you so
much okay
um and here we we also experimented like
the last thing I was talking about just
to go back is you can pay gas with
whatever token you have um and one thing
that usually helps quite a bit is is
free transactions um so like we got gas
sponsorship on polygon and base uh it
helps uh users are happy not to pay but
surprisingly uh people like it we didn't
see that much difference in in volume
for free gas on the cheap chains uh so
this ux is so so good that like people
use it and it is not a blocker as you
would expect maybe in in a different
setting just because you don't need to
educate about anything on the Chain a
lot of people are chain chain
abstraction might be off what what the
current meta on that is but what I'm
calling chain abstraction is
basically this list of assets it's mixed
like the all evm chains with we support
they are mixed here you cannot know
beforehand which chain are you settling
it like our mental model there is like
our typical user isn't knowledgeable
enough and not sophisticated enough to
to Really Care and and and to be able to
make an informated decision on where to
to settle that trait how to do it so
it's just abstract and it's like what do
you want to buy you click and you buy
and and the thing works
uh you can still see the chain here so
like above you can see polygon below you
can see Arbitron but the the key thing
here is like how do you avoid the user
to think which chain I think is a really
bad ux pattern to to so like which chain
do you want and there will be users that
will be like what is a chain I don't
know what that is what do I do here and
and just making the thing work with
sensible defaults uh that you can
execute and give the the user the token
the user wants I think that's that's a
good way to think about this this
problem is a good pattern uh and one
important thing uh we did here is to
avoid high gas costs uh we have a bunch
of warnings if you're using ethereum M
at on on picnic just because of of the
gas cost it's it's fairly expensive
especially for Brazil which is not it's
a developing country so like income is
not that high and it it it is really
expensive to trade there and even with
the warnings people trade there and get
really upset when they realize they paid
a lot in fees so it's actually quite
hard to trade on ethereum mayat on
picnic you need really to want to do it
you need to select manually the the the
chain it it is not the main flow we
use um transaction batching um The appr
Proven swap thing
this like we approve every swap for the
exact amount the the swap is taking
place but it's it doesn't few anything
it's just a proven swap it's you just
click the button everything happens be
behind the scenes and one interesting
episode we saw earlier this year um WiFi
was hacked uh we use Wifi a lot but as
we never did like infinite approvals or
approvals that were larger than the the
Swap and it's always Atomic so there
there were no
allowances
made uh no user funds were compromised
although like one of the main uh
Partners we use was hacked pretty badly
and this is a
like the the way I think about this is
yeah sometimes you solve for problems
that we're not really thinking about I
don't think like doing approve every
transaction was a deliberate decision
but we're not thinking about that when
we chose to to build an account
protction that that decision was mostly
because of U but once you get more
flexibility to to build what you want
you also get some interesting benefits
for example the the safety
thing uh other things uh we did on the
product that I think could be
worthwhile we have redundancies for
everything so I mentioned we use lifi
for swaps but we also use uh XY we use
squid router we use zerox we use the
bridge and it's really nice to
to be able to like if something breaks
you get a second layer uh Pedro who's
helping me answer his the questions he
used to work in aviation so it's a very
appreciated background to think what
happens if something fails so and that's
super key uh for what we're doing stable
coin
liquidity was something that we had to
think quite a bit about not uh our main
focus but uh at first like we we
basically bootstrapped the BL USC pool
on polygon and we spent a lot of time
like how do we ensure this thing gets
pged and uh how do we get
liquidity PE people and and the way we
solved that really was with growth so
the the stable coin thing started
working well as soon as we we got growth
and that there was fees and the now we
have some telegram groups that people
are up the pool and some nice organic
things some community Community that's
forming around that because people can
make money with that now so incentives
still
work uh we overbed for gas as a default
like explaining to users that oh now the
network got more expensive that you need
to send another transaction I think
that's a a very bad pattern so just
making things work and and uh not
overloading the user with uh decisions
and information that the user will
probably not understand I think it's uh
valuable uh one thing that happened with
a few more web tram native users is
people would get a smart account address
and they would send money to
that uh but it could be in a chain that
were not applied so for example in this
product went live it was polygon only
will launched first there because of the
stable coins and people would send usdc
to arbitrum but we not applied there and
it was hell to to get they had to wait
until we deied on
arbitrum uh so for this kind of thing
getting people to choose the chain and
then check if that asset will be shown
in the UI some friction there uh helped
a lot with uh customer support uh yeah
one you want no one cool thing like uh
once we
started getting a bit more traction and
and getting
more users customer support has been
very very insightful to to get the like
uh common
mistakes like people yeah sending money
to contract address of the token and all
those repeat mistakes
uh you need to be build a lot of the the
UI and the product to avoid that that
thing and it has become that that we
have been able to pretty consistently
get uh tickets
down um and yeah and from all those
things those small details and the
tweaks I think we got to a place that uh
it's a product that is competing at
least in some very specific use cases
against centralized exchanges uh there
are people moving money out of binance
and and putting into picnic that's a
real thing and those are not
sophisticated users for the most most
part those are not people that would be
here or uh would be Technical and super
deep on the space is just users that
they want to buy
crypto um and one thing I think it would
be valuable here is is to get a sense on
what kinds of users we are seeing using
picnic and what we're they are doing and
how they're interacting and thinking
about our
product uh so like this is volumes that
we do uh
platform now is
swaps uh 1.4% is yield uh interesting
thing is we started with yield that was
a first isation our first hypothesis
that people want yield in dollars like
if we give them 10% a year on on dollar
yield it will explode not really uh
people ask a lot of questions if you
offer them 10% a year or or even more at
some point we had 20% like what is Smart
contract risk like how how do I think
about this and it's a a very hard quest
to to actually deliver this to
non-sophisticated
users uh at some point in time we added
swaps and that's where we started seeing
traction we double down on that and that
that's what's working now uh and to give
your depend on like what people are
swapping to the most SWA token is the
Brazilian real stable coin that's
BL uh it's the most OP because if people
want to sell and offramp they will all
go through berly so that's like a one
way path uh second is usdt uh so that's
uh a lot of the usage us USC you have us
in second USC in fourth and there's also
us d c that's on polygon so among the
top 10 you have three USD stable coins
so big use
case and then uh repap Bitcoin uh rep
salana eth uh Paul pandle but it's uh
very similar to the distribution profile
you see at the Brazilian centralized
exchange people buy a lot of usdc but
they they buy a lot of majors and all
the other tokens so it's similar users I
think uh that's the way you have been
interpreting we run some surveys uh we
do that every couple months to get a a a
post on on how people are feeling about
the product how what's working well
what's not uh we did one a few weeks ago
this is is quite
recent uh had 100 people answering 61%
of the the people that uh answered they
said they would be very disappointed if
we stop uh building the
product um
so that and and this has been a trend so
I think we have been able to to really
get the to users that value the the
product and really use it
frequently and when we ask them like
name the the top three things you
like the by far the most like thing is
easy of use and I think this can be
break down into many many different
things it's like it's the easiest way to
on ramp the easiest way to offramp if
you're a slightly more sophisticated
user but it goes to like it's the
easiest way to buy tokens in a no
custodio way or is the easiest way to
buy brat on Bas or anything that is a
bit less supported by traditional
Central
exchanges um low fees so one of the
things we're really bullish on Defi and
actually the reason why I got really I
decided to Pivot my career to defi is
def is T can be very efficient we were
able to build this product with five
people now we have seven but this is a
product that had like a few thousand
tokens a few Chains It's a quite complex
product but because we are building on
chain like we just leverage the
infrastructure and it's it's an order or
two orders of magnitude uh easier to
build than something that that would be
centralized and one of the direct
consequence of that is you can charge
cheaper fees for your users you're not
spending that much to maintain
it that's that's so that's like that
five people built this from scratch ESS
how long did it take
you yeah it take a lot more time I think
pivoting and find what to build yeah but
like when you decided on this last
version like how long did it take you to
get to
today um we we actually decided to do
this uh on devcom
bot which was what two years ago two
years ago yeah okay very cool we after
bota we launched it I think six months
afterwards like perhaps in March or
April of uh the next year so it's been
perhaps um an year and a half very very
cool so another question more like a use
case question than anything else so
let's say I want to buy property in
Romania which can accept Euros in bank
accounts would your would I be able to
send for example usdc to your
wallet then convert it to EUR e and then
off-ramp it in Romania
yes you would oh yeah that is awesome
man
like I I was hoping that would be the
answer but like yeah and the kyc
requirements like are decided by the
local partner right okay cool awesome
thanks guys this is
great when monium and BR are issuing the
currency there's a gas cost right
uh do how how how does it work like do
they subsidize the gas cost when when
they're issuing and also do they charge
anything like let's say I deposit 100
high do I get 100 high like how does it
work if you deposit 100 R you get 100
stable coins and you offramp that you
have 100 R it's like for free you want
pay and they pay for the gas fee
themselves they pay for the gas fees and
they pay for the bank transfer fees as
well monar as well mon as well and the
way that works and why that's
sustainable is that they make money on
the yield
so they can subsidize the gas fees and
the bank costs as well
mhm uh I saw that you mentioned Bitcoin
but it's rapid Bitcoin right because you
don't support Bitcoin native yes it's
rap Bitcoin uh we are hopeful
in a few months we'll be able to allow
withdrawals to bitcoin wallets so there
is some cool intense stuff happening
that should allow yeah uh and maybe
maybe some Bitcoin L2 zvm that that's
one of the key things that users ask for
U it's super on the road map uh any
other questions
comments okay and thank you for the
questions it's it's it's nice oh okay
sorry how did we get to the percentages
that is a survey like a Google forms we
sent to users and they answered and yeah
that was their answers and then we do
some categorization
work yeah uh yeah so low fees uh cost is
something that we we are Keen to deliver
and to be very competitive on as well uh
speed that was actually quite surprising
for for us I think that like it takes
longer than uh centralized exchanges for
for a few use cases you you need to wait
for transactions to confirm but still
like depending on what you're comparing
to the the experien is very smooth for
the on ramp is super fast and think
works well uh long custodio is is in
there uh but uh it's relevant I think
it's quite related to ease of use if you
talk with people and have conversations
that it is a a strong component on on
why they differentiate us from other
services and the main way we have been
Distributing is focusing on on being old
custodial I think that's the clearest uh
differentiating factor it's like if
picnic ceases to exist users can still
retrieve funds there is a path for them
to to recover everything even without us
and the on and off ram thing it's also
quite
cited uh one thing we we're enjoying
doing is see seeing the
evolution of uh those answers across
time so the there's three bars here
there's a light gray on top not sure on
how clear that is but ease of use for
example it was below
we have
been hammering on is like how to make
this thing easy to use and yeah users
are seeing that and then based on their
feedback we have been iterating
adjusting the product to get there so
it's it's nice to see that's becoming
easier to use uh low fees is also
improving I think most of that was
probably due to liquidity uh we fixed
improved the stable client liquidity and
and it got cheaper to use speed is is
quite a new thing and interesting I
don't understand that that
deeply um noncustodial I think that
that's an education piece and and people
are starting to appreciate that but
that's the general Sense on how this is
evolving and when we ask users to like
what they would like to see uh on picnic
now uh there's native Bitcoin is is the
second thing that people ask more often
uh now that we have delivered a swap use
case I think quite well
people are asking for yield quite a bit
so it is the most ask for
future how to to they get yield product
and there is a bunch of different yeld
things in there and also credit
card uh which was uh interesting thing
we found out and cool thing if we see
this over
time um the main thing that used to be
asked was like please add more
networks and more tokens so this the
more chains and more cryptos it used be
the gray bar at I don't know 16% of
users were asking that we made it uh
multi-chain we added like eight
different chains and then it dropped to
the very smallish uh orange bar so it's
it's cool to see that like
uh the the features actually uh Drive
user perception and drive user
behavior um do you have any insight uh
into the type of user that's replying to
this question so you said you have 50%
using external wallet 50% using the
embedded wallets within the app do you
know uh where these lines in terms of uh
the replies to the to both
questionnaires have you run that no I we
don't know it specifically but like in
general we have a very low usage rate of
external wallets like 15% uh 15 yeah so
pretty much the majority is like email
or Google so we assume pretty much those
are the same thing the same people
thank you uh I also see in this chart
that demand for a mobile app is that a
mobile app that's going down and usually
we see mobile apps as the fundamental
barrier we talk about it a lot why
normal you nor normal users they're not
adopting cryptos because it's hard for
them to temp to get there and also in
major developing markets especially
India where I come from everybody is on
mobile and so is much of Southeast Asia
maybe Latin America uh in the markets
that you seem to operate why do you see
this to be the
case yeah our Theory
here on why people are asking less for a
mobile app is because the ux got a lot
better so I think in a sense that they
were asking for a mobile app because the
ux was not that good so
they yeah it's it's 50/50 yeah like um
uh 50% desktop 50% mobile generally in a
protocol if I'm not mistaken like the
rule of thumb is a third mobile two
thirds desktop so since we're doing like
a consumer app the we have more mobile
than desktop
generally and it has been increasing
right it used to be like 7030 or
something like that I think the path
forward is is mobile first and getting a
mobile app is is very important either
way for other reasons as well um
anything you wouldd like to comment here
or and just to make the point of the
single chain multi-chain thing uh this
is basically when we launched
the picnic and on more chains and you
can see like uh we get incremental
business line so there is a new volume
that maybe wouldn't helpen otherwise
if we didn't support more
chains and yeah the the way we are
thinking about this is like every time
we solve one of these people will use it
more so if we had native Bitcoin the
bitcoiners that don't want to use picnic
because they cannot withdraw to a
Bitcoin wallet maybe they'll start using
it either because
it's fast either because it's it's cheap
or either because it's non custodial
it's better than centralized exchanges I
think there's a few different reasons
why people connect to this
product and okay any questions any other
okay uh I live in Argentina it's very
common to use Trum usdt uh have you talk
about tackling that I didn't see it in
the list and um I think
could be an opportunity right
yes uh Trum in Brazil I I which is our
Major Market I think is relevant but I
think as far as I
know Brazil AR like due to the currency
issues it's quite expensive so in
Argentina it's much more expensive like
the gas Fe and so so it makes more sense
to use TR so but in Brazil it's not that
much bigger of a deal because if there
were developing country don't have the
same kind of isues as Argentina so TR is
not as big in there but it is Big you
know like roselo like it is still quite
expressive as well but we don't need to
rely that much because we don't need
really really really cheap fees yeah and
we we do receive requests about rum um
uh but it it has not got gotten to like
a high priority in our discussions yet
Perhaps it will be but right now we
haven't
yeah okay
um yeah and this is the last session and
the idea here is basically to talk
about uh it is growing I think it's
healthy but the thing we really really
need to see is the the charts something
like this right like growing 7% week
over week and and and seeing the the
real Mass adoption happen right like get
this to to a meaningful
a group of people like what we have now
I think it's it's a good first step but
there's a lot of work to be
done and like the the way I see this
this vertical this consumer defi thing
uh the account abstraction for this that
specific use case of doing similar
things of what you do in a centralized
exchange is for it to become the main
way to handle crypto like uh I don't see
any fundamental reasons why centralized
exchanges should exist I think uh defi
has a lot of issues a lot of very hard
engineering problems to be
solved uh but in the end of the day like
for the end
user if you get like a very easy way to
have non-custodial wallets that's very
cheap and you have access to pretty much
any product you want what is the
compelling
case for using a centralized
exchange uh I think we haven't got to
that point now and there is a lot of
work to do to to get there but once we
get there
uh we will see that charge so that chart
I think is like if we solve the ux
issues the engineering issues and and
deliver a really really compelling
product I think we'll see like
tremendous adoption and tremendous
growth
um and on the challenges side at least
the things we see that that needs to be
improved uh security is the one that's
top of mind for me now uh the the way
that people are interacting with picnic
and and quite a few similar applications
is still through email and like in the
money business like in the banking
business exchange business trust trust
is is a very very very fundamental
component like everything is based on
trust people only use your product only
use your service if they trust you and
like not having like having a single
point of failure I think it's it is
quite bad so if the email gets
compromised and you get compromised
funds I I don't think that that will
scale I don't think that will get to
mass adoption because people will
realize it it is not uh the best safety
you could get so if you use a bank you
get something that's much better than
that uh so we have been spending some
time on like how to improve this and how
to like make redundancies
recoveries uh like inheritance I think
there's all that surrounding problems
that needs to be solved that you can
actually
deliver uh something that has a lot of
the benefits of noncustodial system
systems and distributed systems to the
end user in a way that the the person
doesn't need like to to spend a lot of
time and and to to take a lot of
responsibility of maintaining the
security for for their own
assets um education I think it's uh a
big topic still so people want to export
the private keys of smart contract
wallets uh
people there's all those uh uh barriers
of trust and and getting people to be
comfortable with something that's
different uh and like getting people off
exchanges I think that's all the process
uh we have been really focused in
producing content that's the main
distribution Channel we have found is
like find people that understand what to
do and and can explain what we do in
terms the their audiences is understand
and I think that's a fundamental pillar
going forward is like how do we get this
message across and we get people to care
about what we're
building uh polishment is this is other
improvements but I think mob app as we
said is uh a strong component uh you can
get a better a few safety tweaks it's
you can get push notifications it's it's
better ux generally and I think it
matters like having great UI having
great animations I think that's great
being fast uh and yeah things just work
you don't have any cognitive overload
costs is also one like liquidity is
not that good still with the local
stable coins uh you can do like $1,000
trades to two five if you go 10 20 50
not there yet so a lot of work to be
done on that side as well and there is
one way to think about it we need to
close gaps with centralized exchanges so
we need to allow users to withdraw
Bitcoin uh credit card is is something
else as as we saw but
like getting users to a point that there
is no reason to use a centralized
exchange and everything works as well or
better uh using decentralized rails is
the the path to go forward
here and at some point it will be better
than saxis it will be safer it will be
cheaper and you will be able to do more
things than you would to be able to do
in a centralized
exchange and then I think the crypto
natives maybe much earlier with 7702 but
my mindset is like we push this thing we
make it work for web 2 Natives and as
the thing improves like 7702 and other
cool things that are coming around it
will get good enough that we go back to
the one of the first slides that this
technology is not really geared towards
web Tre natives I think it will be good
enough that even people that uh could do
otherwise we'll say like okay I I would
rather use the MC with recovery and all
those cool features that I don't need to
worry about maintaining my seat phras or
getting my own security set up and
this thing is already all the main
chains I use and has all the key
protocols I use and it works fine but I
think it's yeah step by step and
building for the web to users those are
the early adopters for this kind of
technology and that that was it uh happy
to take more
questions and
um picking up on the trust slide we
don't need to go there but uh how are
you folks monetizing on on the product
like how can you be sure that picnic
will be there
tomorrow so on the monetization aspect
it's still quite similar to to a
centralized exchange we take a fee on
swaps it ranges from uh 0.1% to 0
when we launch more vertical so if you
launch credit card we'll get uh some
Revenue there if launch yield we get
some Revenue there so the way we have
been thinking about monetization is like
be very aggressive with costs because I
think that's one of the Strategic
advantages of building onchain but
really building the product so you have
many different uh revenue streams that
on the whole you you can make money and
make this a booming
business any more
questions okay I think we're done it was
a pleasure uh thank you very much I hope
you enjoyed it uh if you want to contact
me I'll be happy to to share a bit more
and yeah thank you for staying for 1
hour and a bit
you speech
spee
spee speech
h
m oh
oh o
yeah hello everyone uh Welcome to our
Workshop today I will be hosting a
workshop about building a smart pasky
wallet with a can obstruction so so uh
my name is farad and I am a software
engineer at clave so we're building a a
kind obstruction wallet on zkn with
paskis we're trying to simplify the user
experience of the crypto usage uh in the
wallet
level so I will be firstly giving the
technical background about pasis a
account abstraction uh pay masters some
other technical details about the um
account abstraction and the uh pass keys
so then we will be going to uh live
coding so if you want to join to the
coding part uh you're
invited so firstly I will be talking
about what is pass Keys account
abstraction smart wallet and the explain
some
technical um terms about it so uh
probably you have used paskis before if
you if you use paskis before you can
raise your hand
yeah there are lots of people uh pas
keys are basically uh tools for doing a
two Factor authentication in the web in
the current uh state so big companies
started utilizing pasis with uh their
authentication flows like Google Amazon
and other web two companies so uh why
don't we use it why why don't we use it
on the uh blockchain industry uh so will
be explaining those and then we'll be
talking about the account abstraction so
account abstraction is simply a way to
have your wallets in a programmable way
with a different verification methods
like uh like any custom logic that you
can apply on the smart contract level to
verify your
users uh account abstraction also
introduces The Bash transactions where
you sign uh where you sign only once for
multiple transactions so instead of
doing uh approval and transfers or uh
some other multiple operations with
different signings you just sign once
and send those trans transactions at the
same time uh account abstraction also
introduces pay masters where you can uh
sponsor for your gas sponsor the gas of
the users uh or users can pay with any
erc20 token for their
gas uh so we will be also utilizing
pasis today in our uh live coding
session we will be building a gasless
pay Master to sponsor the gas uh of our
users and also we will be building with
the native account
obstruction uh it's pretty similar to
the normal account abstraction but
introduces it in the protocol level of
the uh rollups in the current rollups
and we will be building on a rollup
called ZK sync
uh because we have a short amount of
time uh we have only two hours and we
will be building a complete wallet from
scratch from zero to the production
level kind of a production level
wallet uh also we discussed about Pas
keys and uh why it's not used in the
current blockchain world it was the the
reason behind that is that uh the
ethereum also Bitcoin uses uh a elliptic
curve called SE P250 6 K1 so uh it's
kind kind of a elliptic curve which
produces signatures and you can validate
those signatures on the smart contract
level by simply calling some libraries
ecdsa
libraries but the signatures given by
the pass keys are different so in the
current modern devices like your iPhones
your uh Android phones and also Mac
devices uh produce a signature that is
odd to ethereum world
so these signatures are uh given in the
different elliptic curve called
p256 or also SEC uh p256 R1 maybe You'
have heard of it so there's no uh there
is a no optimized way in ethereum to
verify those
signatures and uh precompile contracts
are uh introduced using uh rip
optimized way as we do it for normal uh
ethereum and Bitcoin
signatures so today's goal is a building
an authentication with Pas Keys uh in
the wallet level so we will Implement a
simple transfer functionality uh with
the with your Biometrics uh we will
introduce gas transactions with uh pay
masters and we will be using multi call
to get multiple uh token balances for
your uh account so normally in the
normal wallets you just have to send
multiple trans uh multiple uh RPC calls
to the network to get the balance of
your account but with the uh with multi
calls you can just simply uh collect the
users balances with just one RPC call
and we will be also building this and uh
we will be also seeing the bash
transactions as I previously uh
discussed about which is a like
combination of transactions with the
same signature at the same time you're
just sending multiple transactions
instead of sending instead of signing
those transactions uh multiple times so
this is important for wallet user
experience uh if you have used aoas
before you probably know that in the for
example in the swapping if you want to
swap from usdc to eat for example you
have to first approve your usdc and then
swap uh and even if the tap is not
implementing it correctly you will have
approvals Left Behind uh maybe an
infinite approval which might be risky
for the future so with the Brash
transactions you can handle everything
in a way that it's secure it's easier to
use and just sign once send once and
done
so we will be firstly uh setting our
repository in the uh Workshop so I will
be going back to the going to by going
back to my computer so I prepared some
starter uh repository for
today uh it's simply a repository that
helps you to start your uh
coding it's speci for today so you can
uh if you want to join the workshop and
do the live coding you can go to my
GitHub
account and uh in this QR there's a
repository for uh getting
started and uh let's see uh let's see a
bit what is inside this repository so
it's uh it shows you the ways how you
can set up your uh development
environment
uh with with the packages it gives you
the SDK for working with the smart
accounts also with Pas keys and uh you
will be initializing it uh it talks
about the components of the SDK uh and
um also creating a pass key for your
account using the existing Pass Key
sending transactions uh and sending bash
transactions are also described in the
readme so uh we will start by simply um
cloning this repository and then I will
be going to the live coding and also
explaining some past keys after like
showing how you can clone this
repository and uh set up your
development environment so we simply I
will simply go to my um terminal
and go to
my working directory and create a test
reposit test uh folder so that I can
just simply
write it clone and
uh the URL of the
repository so it will be cloning some
files and it's in the
test
um so oh sorry I cloned in the wrong
place so I will be cloning again
uh also on the readme file it shows you
the way how you can use the sub modules
because we will be using the uh open
source contracts developed by us so that
there's no uh need to worry about the
smart contract s so that you can easily
start to your uh development on the
client side so I'll will be also showing
the uh those contracts and we'll be also
building a um Pass Key validator
contract uh from the existing ones and I
will be explaining uh the things that
you should do on the pass key validation
uh on the smart contract
level so uh to update the sub modules
which is located in the repository you
just simply need to copy and paste uh
this inside the
repository so it's cloning the files
from the sub module itself so
uh yeah it's
there and you need to also use some uh
private keys to deploy your um deploy
your smart contracts and also deploy
your smart accounts so in our contract
stack it it's uh defined that you need
to use the same private key for uh
deploying contracts and also uh
deploying the smart accounts produced
with the uh
produced from the factory contract that
we are going to deploy so uh I'll to not
expose my uh private key I will be just
uh using the pre cloned version of the
uh repository so everything is
here and I will be starting to the uh
contract deployment but also let's go
back to our slides and discuss more
about uh the smart contract deployment
so uh today we'll be deploying these
contracts with just one uh
command so I will explain their purposes
so we have some uh six uh or seven
contracts yeah the badge caller contract
will be used for sending badge
transactions um the implementation
contract will be used for the main
implementation of our wallet uh the
registry contract will be used for
storing your um addresses in the smart
contract to identify that this account
belongs to your contract stack uh the
gas pay Master will be used for
implementing gas transactions the proxy
is not important for today it's for
future you can use upgradeable uh
contracts to like you can uh upgrade
your contracts in the future to change
them if you
need so the py validator will be used to
validate the pasy signatures that we
will be uh also showing how you can
build pasy validator contract and also
the account factor is the is basically
the contract that deploys that produces
your accounts one by
one and also uh since we're building the
Pas key uh validator contract we need to
understand the components of the pass
key authentication so the pass key uh if
you try to sign the with the pass key uh
try to sign a message with the pass key
it simply produces uh an authentic data
that contains the information of your um
RP ID hash and other related stuff to
your authentication whether you gave the
Biometrics or not whether uh user set up
some Flags in the authenticator the
client data mostly contains the uh
challenge that you want to sign
challenge is basically the message that
you want to sign it's in the it's called
challenge in the web Alton uh standard
also the signature uh that will be
provided which is a p256 signature as I
previously mentioned so we will be
showing the uh how you can verify and
create create a um Pass Key message and
verify it on the smart contract level so
it's simply the hash of the
authenticator data uh plus like the
concatenation of the authenticator data
and the client data hash uh
um so let's go back to the main part
where we'll be building the wallet from
scratch
oops Yeah since we cloned our uh
repository we can continue uh by setting
up our uh deployments so um I will open
a terminal in my Repository in my um
local repository so that I can go to the
uh contracts repo so in this contract
repo you can just simply um after
putting your environment variable you
can simply go to
uh like we will check whether we have
enough balance in our account in the in
this uh private key that that private
key belongs to so I have uh I will be
using a ZK syo test net which you find
which you can find the details from the
chain list or uh any other
source and uh since I have enough gas to
pay enough um ether to pay for the
deployment I will
be um I will be just running a command
to deploy them but firstly we'll need to
go to the smart contracts repository and
um build our build our
validator contract which is a pass key
validator so in this contract stack you
see the an existing Pass key validator
but we will not be using this uh today
today we'll be building our own because
this contract contains some uh constants
to optimize your uh optimize your gas
but uh for today we don't need them
because uh you need to debug your
authenticator data and client data that
I described right before to make it uh
like optimized so I will be just uh
copying this
file and also uh creating a new
validator over here calling this Pas key
validator
Devcon and pasting this to here so in
the validate signature you can see that
uh there are two types of signatures
that we can have so the Val the first
first signature that uh included that's
included in the first if block is simply
the optimized way to uh verify this
validate this signature but we'll be
using as I said the uh the nonoptimized
way to uh validate this signature so I
will be just removing this
part and just keeping this validate fat
signature uh function over here so let's
uh check the components of the fat
signature that we called um so it
contains the authenticated authenticator
data that comes from the Pas key
authentication the client data suffix
which will be concatenated with the the
given Challenge and the client data pre
prefix which is always the same so you
can simply uh hardcode
it and also
uh the RS formatted signature will be
provided from the client side so that
that it gets uh
validated uh we have some Malil checks
over here and also the flags are uh
controlled so that uh it contains the
user presence and the user verification
flags of the uh authenticator data uh if
you go back to
slides over here you can also go to the
Mozilla docs about authenticator data
and uh about the client data over here
so that you can see that
the uh client data Json or client data
includes your challenge itself the
challenge will be the transaction data
uh simply so the concept is instead of
uh signing random messages in the uh Web
Two world we will be signing the actual
transaction data uh as a challenge so
that we can understand what kind of uh
transaction the user sends and what kind
of transactions to
validate so
um everything in the Pas key world is
Spas 6 to4 URL encoded so you need to
make sure that your challenge uh and
other parameters are also in the base 6
to4 URL format so um we concatenate the
challenge data prefix our challenge uh
Bas 64 and the client data
suffix and then create a message by
simply uh like hashing them and
combining them together and then call
the uh p256 verifier contract which is
defined with the um which is defined in
ZK sync uh core so when we go back to U
the Explorer of the ZK
sync when we paste this address it's
simply 0x1 100 you can see that the
contract exists here so it's a p256
verifier uh contract that is a
precompile contract so that uh it op in
it uh verifies your pass key uh
signature in a optimized
way uh let's go back to code and remove
some uh stuff over here because these
are simply for optimization as I told
the authenticator data hard code version
is also not needed and uh we can
simply remove this function too because
this is the optimized uh signature
verification we're not using this
also and uh I think everything is right
except the name uh Pass Key validator
Devcon we will be calling this like
this and it looks fine and and we can
simply continue by running the compile
command to generate our um contracts uh
to compile our contracts and get their
artifacts and we will be using the
deploy MVP script which simply gets all
the artifacts and deploy the contracts
one by one as you can see and it gives
required um Constructor parameters to
the each contract so that they work well
together and then it simply logs the uh
those contract addresses so that we can
use them on client level and we will be
using
the um Pass Key validator
Devcon uh as as I uh named it like this
let's check the name again to not
fail uh yep it looks fine so I will be
calling the deploy
MVP um
command and the contracts are getting
deployed there so it will take like two
to three
minutes uh since here if you have any
questions you can uh feel free to
ask or I will continue to the client
level and explain some components of the
client uh it's also in the same
repository yep uh do you have a
microphone by the way or yeah you can
ask
yes uh they were at the
validators uh folder mhm and I just
copied and pasted the validator pesky
validator do soul and created a uh clone
of it and simply just copied pasted this
file and removed some of
them okay so what exactly do we have to
remove uh so you need to
just uh from from this contract you just
need to uh remove this
part and
uh just keep the validate fat signature
and also some uh constant values over
here like this line this line this line
and yeah that's it uh but you can also
use the same contract for this uh
Workshop because they both going to work
because the client site just uses the S
second part mhm so it's uh just enough
to use the existing contracts okay thank
you yeah
sure
um here it is
so yeah I will be moving to the client
level if the contacts are deployed it's
still getting deployed but let's go to
the GitHub and see uh the real see the
more documentation about the
existing um
client so um we will be defining our
smart wallet SDK that which is I called
in my mpm package so there I created an
mpm package for this Workshop so that uh
it gets uh easy for you to get started
you will be just copying and pasting the
smart contracts that uh produced from
the previous step after our deployment
and uh we just need to initialize the
smart wallet SDK instance and give the
chain ID which is 300 uh which is the
chain ID of the sapoia zking and the
contracts also optional the AP URL will
be used for deploying your contracts so
as I pre previously mentioned you need
to uh deploy your smart accounts with an
AOA and you need to put the uh the
private key of your uh of your deployer
of your smart contract deployer to the
client level somehow in a secure way so
that you're you're also able to you're
also able
to um deploy the smart accounts in a
correct
way so the SDK includes the core uh
which is helpful for preparing the
transaction call data the deployer will
be used for deploying your smart uh
accounts uh the multicol will be used
for having multi-read operations and the
web o instance will be used for uh utils
for the P keys it's simply an extension
uh over uh web to simplify the P key
operations so I will be showing those
functions like we will be uh running
the uh client application on our local
and code each part one by one so here
are the smart contract addresses as you
can see I will just copy and paste it to
the to my client side so I can go to the
uh to my client and I will be
initializing my SDK on the source and I
will call it sdk.
TS so we're working
with mostly typescript because there
there are lots of libraries to work with
and it's quite going well with the uh
web
development so uh what we need to do is
let's put them here uh but we need to
also get the codes for
initialization so yeah this these are
the codes for the for ini initializing
your SDK we just import the smart wallet
SDK and
then uh set the contract
addresses and we don't need API URL for
this Workshop because we'll be using the
Local Host one so you don't have to
override it but if you want to deploy it
somewhere in the in the web to uh share
with your friends you will need to
update this API URL value with your
domain so the SDK instance is ready we
can close the terminal for now and uh we
can start our development environment as
also describe in this read me so uh so
you don't have to do anything after this
you just need to run the mpm Run Dev to
run the development run the development
environment so I'll go to the
client and run the dev environment
uh so I need to just
um I need
to uh go back to my uh previously cloned
version because like my private key
exists there so it's called it's in my
smart wallet uh directory I can go to
clients and just mpm run Dev
so as you can see it started the Local
Host 3,000 for the
development when we go to Local Host
that says that uh you either need to
create a smart wallet or log to an
existing one so um we will be
implementing all these steps like
creating and the logging part so that
you are able
to uh like create a new account and also
the log to the exist to an existing
account so to do this let's also check
the architecture of our client
application it's simply comp it simply
contain some components like UI
components some constants which are uh
which defines the token addresses they
are pictures and stuff some hooks to get
balances and it uses the some Global
State Management tools for uh storing
the credentials in your
local and also uh some UTS over
here and the main thing happens on the
views so in the um when we go to the
layout uh you can see
that uh there's a you can see that uh on
the um
um on the there there are two views like
home View and the old view in this part
we will be seeing the uh so when we run
the our development environment we only
see the out view where the
authentication happens like there are
two steps the deployment and the uh
login so we will be firstly implementing
deployment so let's go back to our uh
readme file and just C copy and paste
this uh registering part and put it to
deployments we need to import the SDK
that we created the SDK instance and
finally it gives us the status and if
it's one uh it means that your
deployment is successful and you can
continue uh and do some other operations
like setting a global State and uh
more so I will just throw an error if
the deployment is failed
then uh set up some Global State over
here so there's a hook in the repository
called Uh set
credential so this set credential is
simply holding the credential ID of your
pasy it's the unique identifier for each
pasy and the public address that is
produced when uh you deploy the account
so so we need to create our credential
first of all so the credential is simply
the pass key ID and the public address
and we will set the global State as you
can see and then we will be initializing
our uh core instance with the given
credential and we will also set
the uh set this credential to the local
storage because when we refresh the page
we need to somehow get the latest
account that we log in or registered so
that uh I also created a storage
instance storage uh util so that it's
helpful for like setting
Json uh formatted uh values to your uh
local
storage so it's also defined with a
storage keys.
credential it's simply a
string value that defines for which key
this value should be set and also uh you
you will need to pass the credential
over here and also use the set Json item
because this credential is an object
value so it works uh so Ed it works so
it only accepts uh string values uh on
the other uh case so we will just use
the set Json item function so let's go
back and see whether uh it's going to
work so when I try to uh press the
create smart wallet
button it will probably fail because I
missed some part but I will explain
soon so it's loading because it cannot
deploy because we need to deploy our uh
smart account in an API level which is
defined in the route TS inside the app
so nextjs applications allow you
defining apis on the client level so
that you can secure put your environment
variables in your inside your app and
use them on the server side it's it
creates a node environment for your
client application so here we need to
put our Factory contract address that we
produced before which is also we put
also uh to
the uh SDK instance creation part and I
will just paste this account Factory to
here and as you can see it's thrown an
error because it couldn't find the
address of
our account Factory so I'll go back and
refresh and try the deployment
again I will give
my uh
Biometrics and it should work yeah so we
deployed our first account we can go to
the block Explorer and see what's
here so uh when you see as contract over
here it means that uh you have deployed
a like there's a contract uh associated
with this address so this is not a dummy
address so there's a contract uh we
failed to verify this contract but
anyways uh it's simply the main
implementation
um so what we can do now is simply go
back to the uh our application and see
that there's a disconnect button over
here uh it means that log out from your
smart account and we will implement the
login part to use the same Pass key so
when you go to the uh passwords of your
device and go to the Local Host you can
see the pass Keys over here like this is
the one that I created in the latest
time uh like 3 minutes uh like 1 minute
ago so the pass keys are abounded to
your domain so if you create a pass in
your Local Host you can only use it on
your Local Host so you have to be
careful about this if you build an
application so pass keys are as I said
bounded to your domain and only used in
in the domain that they are
created so we will implement the login
part to use the existing Pass key that
we created like two minutes ago uh it's
also defined in the readme so you can
just simply copy and
uh paste this inside the old
view old view uh if you forgot it's the
it's simply this
page it's simply this page and uh in the
login account function we will be
implementing the uh log to the existing
Pass key I'll just remove the comments I
will again build the credential object
which is the P key ID and the public
address which is located inside the P
key response.
user handle so user handle
is the pass key ID that we provided in
the in the registration part and when
you try to uh let's let's read a bit
this code
so um this library that I buil is
actually using a passwordless id/ webon
uh open source package which is also
doing some pasy operations
and in the authentication part it simply
passes the credential ID and a random
challenge uh during to sign in the login
and some OD uh options like some uh
other
configuration and during the creation
during the registration we
simply um get a random username which is
uh the the current date and also the
random
challenge uh to create our P
key so in the login account we we should
have to do the same thing like the set
the global State set the local storage
and also connect our SDK to the to this
credential so when I go back and refresh
and press the log into existing wallet
as you can see the uh the pass keys are
shown here this is the latest one that I
created and uh I pressed this to choose
it and give my credential give my uh
Biometrics and I logged into my uh smart
wallet so it says loading because it
cannot fetch the balances so we will
implement the setting balances we will
also implement the uh like restoring our
state because when I refresh the page as
you can see it's gone we have to press
log in again and sign in but we uh have
an easier way so when we set the local
storage as you can see in the Local Host
there's a credential
value which stores our credential ID
which is a pasy ID and the public
address that I created in the in the
last
registration and uh to use this we have
to go back to layout uh there's a
component called State
Setter and it simply gets the
credential from the local storage by
simply calling uh get Json item from the
storage instance and you need to import
these values from the like store and the
utils
to uh get the types since we are using
the typescript and also the set
credential Global State Setter again
comes here and uh again we need to
connect the
sdk.
core.
connect with this credential
so you simply build an object which has
a P key ID and a public address set it
to your store set it your Global Storage
set it to your local storage to restore
it and use this Valu for sending
transactions so when I refresh the page
as you can see it's already restored and
it's the same address that I previously
deployed so there are two views uh two
main views over here which is a receive
and send we will Implement a transfer
functionality and also the receive is
already there so it this QR code
contains your uh address so that we can
fund but before funding let's solve the
balance fetch issue which is located in
the use balances query hook uh there are
some com commented places so we will
implement it uh from scratch let's just
commented uh let's just remove the
comments and as we previously saw
there's a multicol instance inside the
SDK and it already contains the get
token balances function which is simply
sending uh some it will it simply
generates some
um RPC calls and combining them together
like it's it calls balance of function
for uh
the erc20 interface and also the for E
it's not the same as erc20 so you need
to call some other uh values some you
need to make some different RPC calls so
it contains there you can read the codes
from here but I will not go deeper just
call the get get token balances and also
the pass the addresses of the tokens
that you want to get the address of so
import the balances which is a simply
uh the mapping of string mapping the
mapping of the addresses to the balance
of the of that
token and um we will set the global
state of the
balances um and also there's another
Global state that is called is balance a
set which is used for controlling
whether we are uh we could successfully
fetch the balances or not so uh um it
should be ready so there's also when we
go back to the balance of square as you
can see it refreshes this query every 10
seconds so it will get your balance in
every 10 every 10 seconds and you will
see the updated uh
balance so uh when we go to home as you
can see we have uh fetched the balance
of eat usdc and the teer and the Teter
um so we will be using with ether today
because I don't have enough uh usdc and
on testet I will be showing the like
operations with The Ether but the uh
erc20 tokens are quite the same with the
ether uh if you want to generate
transaction uh but I will be showing how
you can create transaction call data
with the util that I
built so uh to do this we have to F
first the our account we can just go to
receive copy our address go to my
metamask and I will send some money to
my wallet and let's see whether I can
see it uh in my client implementation so
I will send some e to it like let's make
it 0.005
E and uh I'll go back to home and see
whether this refreshes
yeah as you as you can see I have now
this eat I can transfer to someone else
I can use bash transactions to send it
to multiple users at the same
time and when I go to send as you can
see this place is also not implemented
uh when I go to send view this is the
this is the place of this page this is
the codes of this page and uh we will
implement the transfer functionality but
first of all Let's uh comment this out
because it also uses some utils from the
library that I built and also gets the
balances from the global state which you
can access by simply
calling uh use balances
hook so uh it also formats this big
number which is defined in eers uh it's
simply formatted to an human readable
way so you don't have a so that you
don't have a like 18 decimal values on
the UI it's some somehow pries it to a
six
digit let's go back and see that we can
see our our available tokens uh in our
wallet and also in send view let's see
what states we have we have a value that
uh simply holds this this place you can
just enter some uh like digits the the
amount that you want to send the eat
amount and the address of the recipient
so of course you can improve this
implementation to send to usernames for
example uh that we also do uh our own
clay wallet so that you can send uh to
your friend's username instead of
addresses or you can also improve this
to accept the ens uh of your friends so
that you don't have trouble by just
copying and pasting the 20 byte address
every time so I will send the money to
myself right now I will not implement
the that resolver like ens resolvers and
stuff I will just copy and paste the
receiver address and send some uh eat to
it let's send 0.1
eat and
uh to send an eer we need to implement
the transfer logic of course when I go
to my readme file as uh as you can see
here we have uh an implementation for
sending the exact amount of
ether so I will just copy and paste
this by importing the SDK I can access
the core and for the two value I will
set the receiver and the value I will
set as the amount that I entered which
which is stored in the value state so
you need to also parse the eer value
because uh it the eer has a decimals of
like multiplies this uh value to the 10
understands how much amount you want to
send and also you will be uh calling the
sign and send function from the SDK so
we went to the node modules and see
what's inside so this uh function also
appends a pay Master to your uh
transaction so that you don't have to
worry about paying the gas so you will
simply pay for your users gas so that
people just simply can uh send
transactions without worrying about how
much ether they have for the gas so it
gets the transaction by calling the sign
function it simply does some uh some
interesting stuff from the uh things
that I implemented you can also read
those codes from the uh repository it's
uh open source but uh since we don't
have to worry about the difficult Parts
over here we just have to create the
transaction uh which
simply like sets the transaction object
for your blockchain set some uh required
parameters like gas price gas limits
chain ID and other
parameters and uh we will be signing
with the pass key and then sending this
transaction to the network to get uh
validated it go back to the client
application and press
send this uh transaction will probably
fail because we again didn't do
something that we should have
done so as you can see it errors with
the failed to validate a transaction the
reason is pay Master validation
error so when we go back to our
addresses that we deployed on the
client we have a gasless pay Master over
here so let's paste this to the Explorer
and see what's
inside um so I'm in the main net I
should go to the sapoia
okay as you can see there's a contract
called gaz's pay master and it has no
balance
inside but since we are paying for the
fees someone has to pay for the fees and
this pay Master will hold some ether
inside to sponsor your transactions so I
will send some money to this pay master
so you need to eventually check your pay
Master address if you want to go in
production so so that you don't get out
of funds so that users don't have to pay
for the gas I'll just paste this address
to the to my metamask and
send uh let's send
$100 it's too much for now but anyways
it's the test not
e so when I
refresh as you can see my money is here
so that I can start sponsoring the
transactions of the users
uh let's go back to the client and
refresh
again so I have 0.005 eat and I will
send again this the same transaction the
exact same transaction that I previously
did copy my copy paste and my address to
the receiver and send 0.001 eat to this
address I'm again giving my uh biometric
Authentication
so it pends the signature and sends the
transaction so it
will the balance will be uh updated in
down to
address on the Explorer and see the
transaction history so what happened
here so in the transverse part as you
can see I just now sent 0.001 eat to
this address address let's go to the
transaction and see
inside so here uh the zc casing Explorer
shows that this fee is paid by pay
Master uh which uh has an address of
this and uh it paid for the three cents
fee let's close this
page
um so we can simply we can improve this
part by
simply uh calling the
another um function over here to update
our state much faster like I will be uh
I'm using a react query for this uh
repository so it's a helpful tool for uh
sending an API request to somewhere or
sending like RPC calls Etc um I will be
just calling a fretch queries function
from the react query and passing
the uh the key of
the um balance fetcher query which is
defined here as you can see it contains
uh the queries it contains the balances
value which is a string value and the
public address of the of the user so
that we set the balance for each user
each registered user so to so to refresh
refresh the query uh I need to call this
refresh query function and also pass the
query key so let's try it and see
whether it works I will again paste this
address and start and send let's send a
bit low amount so we can see full
balance okay it went down um as you can
see my balance went down so um for the
next
part we will be um sending a bash
transactions so as I previously
discussed bash transactions are used for
combining multiple transactions in the
together so that you just sign the
transaction once and
then uh send to the network so we will
be using some uh utils again from the
SDK that I built but we will be sending
an e amount to different addresses so
let's go back to send View and expand
this part as uh
like at another state as receiver
two and also the value to to send also
different amount uh to to different
addresses
the selected token will be the same and
I will be putting another input over
here so that we can also uh set the
state for the second receiver so this is
the receiver one and this is the
receiver
two uh so this sets the set this States
this this sets the state for the
receiver to and also contains the value
of the receiver
to and this is for the first receiver so
let's go back to the send and as you can
see we can see now two inputs we have uh
to set we can set we can just remove
this value too to send the same amount
to not lose
time and uh I think we are ready but we
need to implement
the uh bash transaction function so I
will comment out this part and
simply uh
start again by using the bash
transaction util from the core instance
so as you can see there's a function
called get patch get patch transactions
get patch transaction and it simply
accepts array of
transactions which has a two
address a value and a call data so since
we are transferring e we will be just
setting the value and the two amount two
Fields so when I go back to my
um get bat transaction function
implementation I will be setting the two
as uh receiver
and my second two value as the receiver
two I will also putting the value as the
as as I did before like I have to
multiply it by 10 to the power of 18
since eer has this decimal I will be
setting the same amount for this uh for
second uh
receiver again I will need to call
the uh sign and send method from the
from the transaction instance that I
created and also refresh the
queries so let's go back and see how
much balance we have
so we have
two different addresses to transfer
money to different addresses with the
same transaction so I'm setting my
address as the first as the second
receiver and also
my
um my main wallet as a first receiver
and let's set the amount of 00.
one and start sending transaction by
again we need to uh give the biometric
authentication so that it goes to the
smart account smart uh account py
validator and gets verified as you can
see my balance is down to
go back to
the block Explorer and see the
so uh in the transfers it seems like uh
like multiple transfers but I actually
sent it with this method uh to the
blockchain so that it
sent it
transferred twice but actually I sent
one transaction so let's go to the
transaction and see what happened
again so as you can see uh our wallet
transferred 001 eat to this address and
this address with the same transaction
and also we sponsored for the
gas so um let's go
back and um see what else we can do I
um I think the implementation is done
for our wallet so what we have in the
end so we have a smart wallet that we we
can log in and like in the beginning we
all of course like deployed our smart
contract and now we can just simply uh
log into it with our
biometric which uh has like we have a
multile RPC calls in the home uh page so
that we fetch the balances for different
tokens we have a send functionality
which we can send multiple
uh which we can send ether to multiple
users at the same time with the same
transaction so that like you don't worry
about the uh gas fees and uh other stuff
and we sponsor the transactions with the
gas this pay
master and we also have a place to
receive your uh funds from different
wallets so that you deposit uh you top
up your
balance and you can of course like uh
uh disconnect and create a new wallet
continue to your path with the new
wallets and do additional
things so um let's talk about a bit uh I
can accept some questions if you have
any
yep thanks
y uh if you're building a mobile wallet
there's no restriction for the web views
on iOS side but Android doesn't allow
you to uh use your pass keys on the web
view um currently um I think there are
Pass Key wallets that are built in the
browser level and they're using uh
another like they're using a popup to
navigate to users to their domains in
another window and there they uh sign
for the transaction in that domain so
that they can use that same Pass key for
different uh yes it works for the iframe
on the browser
level uh
can you associate
multiple
key can you associate multiple pass keys
to a single account abstraction
wallet so yeah um the contracts that I
showed uh is a a modular account that
can have multiple public keys inside so
you can assign like as many as possible
uh as many public Keys as possible
possible to the smart account so how it
works in this contract that I showed it
simply tries to validate over all public
keys so at the end if it finds a correct
public key uh it validates the
transaction otherwise it fails so uh
this is possible because of the like rip
this transaction is taking too much gas
but uh with the compile contract you can
just uh like validate through through
the all public keys and it takes like
not too much gas and in the current
rollup State it's just like sents some
sense uh that that's just on ZK sync uh
currently the pre compile contract is
deployed to ZK sync and Kakarot I guess
okay and some other rollups are also
integrating it and they will be live
probably in the uh short amount of time
but since it's live on zking I showed
the demo version of the wallet on zking
got it thank
please so yeah during the deployment you
provide a salt to your
account uh so like you you generate a
random value for each uh wallet so that
you don't have uh like you don't run
into the trouble that you try to deploy
the same address so in ZK sync there's a
function called crate 2 in the um system
contract so it computes the address for
your Sal value so uh I can show from the
code
actually so during the deployment part
on the client side
we simply call the factor call the
function from the um deploy account uh
from the factory contract which is
called deploy account we passed the salt
value to the uh deploy account function
where it calculates the uh public
address and uh it's a deterministic way
actually with the same salt you produce
the same
address but the problem is uh that
it's different for the other chains for
the ZK sync the crate 2 produces a
different value for uh different public
address than for for example from base
uh so that uh this is the current
technical problem on going cross chain
with zking and other chains so you prod
you cannot produce the same address for
Z casing and other
chains yeah
car the elip car function are different
on the mobile phone and smart contract
so I guess is make that verification on
the smart contract is insanely expensive
yes exactly so uh when uh we can go to
beginning so um normally the transaction
um we will go back to here so yeah
normally um the ethereum and the Bitcoin
also uses a elliptic curve called SEC
p256 K1 but the pass Keys uh and secure
Enclave also uses a uh elliptic curve
called p256 or SEC p256 R1 which is
different than ethereum as you mentioned
so it's really cost it to uh verify
those transactions but there's a rollup
Improvement propos proposal called 7212
which was an EIP before which is
developed uh from our team actually uh
some folks from our team let's go to
the uh definition of it and see what it
recommends so this proposal creates a
precompile contract that performs a
signature verification in the SEC p256
R1 curve so that it's the verification
cost will be the exactly equal to the
verification of the SE p256 K1 curve so
in our case we don't run into the
trouble there are some other like
optimized smart contract implementations
that we used previously but they are
like almost taking 50 cents for each
transaction which is quite High uh But
like after the blobs it's like it's less
but again using a uh precompile contract
is always much more optimized yeah
please I'm next sorry here here here on
the right oh okay sorry um so my
question is um we didn't get into that
part probably but uh you said that pay
Master is paying fee for transactions
right so um could we get into that part
like
um you're trying to send a transaction
for address a to address B but some
other address is paying for for fees
how is that uh done in in your example
so you mean a volet b pays for the yeah
VA a no no you have um I'm sending a
transaction from address a to address B
but some other address C for example is
paying for fee which is the your case
right uh where pay Master is paying fees
right am I right did I get it uh correct
like currently the pay Master is a
separate contract that contains a
balance inside which has a custom code
inside so it checks uh it calculates the
how much gas it the wallet a should pay
and it checks whether I have a balance
the pay master has a balance uh of that
value and pays for the gas but the
wallet C uh I cannot imagine a way
because not C address C you are sending
right yeah uh but the thing that I
didn't get probably or was not presented
is that you were saying that address a
won't be charged for a fee exactly yeah
so some somebody else is paying that fee
uh and that's what I'm asking how how is
that done yeah uh like the the payer the
payer is actually the contract itself so
with the account abstraction uh you can
create a contract and put some money in
the contract so when you send money from
your account to another account that
contract you add that contract address
and uh like prepare a pay Master data
it's called pay Master contract put that
pay Master data inside the transaction
object so it uh also like um checks for
the balance of the pay Master contract
and the pay Master pays the fees yeah
and that's that part is clear but if
contract does that if contract is paying
for fees and um address a that is sender
needs to tell to that contract what to
do and uh that's possible only through a
transaction and the fee for that
transaction needs to be paid yeah who is
paying it the pay Master contract and
that yes yeah that that part is not like
I will show like the pay Master uh
addition to the smart con like the
transaction in uh generation so when you
um go to
the so this is the the code that I built
for the SDK so it's simply when
you um try to send a transaction it
append a pay Master to the transaction
data so this append pay Master is
simply adding the the gas pay Master
address and S telling that this is a
general purpose pay Master which is uh
Gas pay master in in our case may I
interrupt you here sure so now we have a
transaction like setting from setting to
setting data setting custom data right
yeah but that transaction needs to go to
a contract that contract will know what
to do next right yes and that costs
something
y so does it mean when I see that
transaction on the eer scan that I'm not
the center of it no not uh like it's
actually like this in the other chains
but zking supports a native account
abstraction so that there's no bundler
you just send this the custom type of
transaction to the zking network using a
provider provider instance of the eers
for example and contract like the the
network itself understands who should
pay the gas and uh who actually sent the
transaction so you actually correctly
see the sender and the pay Master on the
Explorer level but in the other chains
it seems that uh someone else sended a
transaction it's actually shown in the
internal transactions like there's a new
tab in eer scan maybe you noticed that
yeah yeah yeah it shows in there but in
in the zking uh since there there's a
native account
abstraction uh it's it's shown in a
correct way okay thank you
welcome
yeah uh this kind of an aside but do you
know the latest on the uh proposal that
you just mentioned in terms of
integrating that to an L1 like adding
the pre-compiled to main net let's say
is that going to happen or is that just
kind of
blocked uh yeah there there are some uh
like updates about this uh like in the
internal talks with the ethereum team uh
there are some talks about like
implementing this to the uh main net but
the actually
the the the proposal is uh suggested by
the aash from like he's sitting on the
left side of you maybe he can answer
about this question like whether it's
going to be happening on the main net or
no hey current next hard work pctr is
currently very overbooked with lots of
proposals so I don't see that's very
realistic for the pectra but it's still
on the CFI list and if some of the cevs
or client teams focus on implementing
the this this proposal and advocating
that much we we can have it on ethereum
maybe in pectra maybe in Petra B which
is separated into two forks but at least
now we have on each major rollups
including optimism and optimism eor
rollups Z casing all zing gastic chains
and in arbitrum soon I think we are
having adoption and it's it's still good
do you need on L1 for example why why do
you need
L1 I'm
okay yeah any more question yes
please hello uh I'm curious to know like
how this can be used in a real world so
what I understand we used private key to
deploy contracts then we have used
client the UI part and we are uh sending
the funds uh
so if we have private key we can use
that private key directly and send the
funds so how this can be used in real
world in real world you mean right so uh
the private key on the like in the
client level is actually for the
deploying the trans deploying the
account for the first time so it's not
used in other cases so in the first part
when you deploy an account someone has
to send a transaction but there's no
signer in the beginning uh so we use
that private key to initialize our
contract after that we can just uh throw
away that private key and do not use it
uh we will be using just uh the pass
Keys uh private key which is actually
like uh it's embedded inside your your
device so you cannot uh like reach it uh
you just you can just sign transaction
with that without knowing what the
private key is so in the real world you
can have an account abstraction wallet
so you deploy this wallet with the some
with some private key you just throw
away that private key you will not use
it and have a somehow um like Hardware
level security in your phone some kind
of of a like the most probably the
secure way to uh send the transaction
with the account abstraction right now
so we're currently building that kind of
wallet uh so there are some real world
usages yes got it clear and I have
second question uh uh that is we have
run it on Local Host right so I can run
it on separate machine and the client
not a contract and use the same
addresses uh and I also create a uh Pass
key there so I can have two pass keys
for single account if I have the
addresses the pay Master address and all
the addresses we get after deploying to
contract so I can deploy multiple
instances of that and access the same
account is that I'm understanding
correct yeah yeah I got the question uh
like in the first part you can of course
you can like move pass keys from one
device to another if you want to say if
you want to use the same Pass key in
different accounts and it's
automatically done on iOS and it's
automatically done with the Chrome uh as
far as I know like if you create a pass
key on your first Android device and uh
like combine like use the same Google
account for those two uh devices you
will have the same Pass key on the same
devices but on the same part on the
second part uh you asked about using two
pass keys for the same account yes this
is also possible uh you can have two
public keys inside your smart contract
to verify true uh and you will just add
one owner to your smart contract and
then add another owner to your contract
uh you can add x amount of uh owners to
your contract so that you will have
multiple pass keys for the same
address okay got it thank you yeah but
uh you will be like each Pass Key
belongs to the one domain so you cannot
change the domain after that so you need
to be careful about the py creation so
where it's created whether that domain
is accessible uh
like some other Concepts if you want to
go to production uh
yeah so yeah
um oh there are some yo there are some
questions from the I didn't know that
there are some questions from the live
is there a live example of pasy
wallet um yeah there are some pasy
wallets exist in the ecosystem so one of
them is coinbase smart wallet which is
accessible on the uh browser level so
you can just simply use your uh browser
to access to the uh smart accounts also
there are some mobile wallets which one
of them is we are building called clave
and uh like these are two different
optim these these are two different
implementations one is the mobile one is
the uh web implementation but they're
trying to solve the user experience
problems on the
ecosystem can you show clay and how it's
used in real life uh well it's it's
probably not allowed to do some uh
like uh like commercial things here but
like you can see on YouTube for example
you can uh go to the uh our website and
get cave.
and see uh the real world
usages and how we like simplify the
crypto experience for the newcomers and
also the existing
users if for example iCloud key store
safe to use for pass Keys um thinking
Pass key doesn't have same security uh
doesn't have some security issue
probably it's a question
um um so the iCloud key store
actually this is not the like normally
uh credit card information in your iOS
devices for example the pass key private
key is stored also at the same place
so um when you create a pass key its
private key is stored in the um separate
place from your devices uh from your
devices operating system so that it's
quite safe to put your pass Keys uh it's
called the secure Enclave you can search
about it on the internet so um
it's I would say Prett it's pretty
secure as like putting your Apple uh
like your card information to Apple
y
ler like during the thinking the uh
thing is that for example for iOS
devices you um add your devices to your
trusted Circle uh of course there there
are some there might be some attack
vectors but uh also some uh security
measures are taken for securely uh like
syncing those um pass Keys through your
devices like if you want to access a
pass key from your other device for
example or add that device to your
trusted Circle you just you just have to
uh pass through a two- Factor
uh on the Apple side and do some
additional stuff but if you uh if you
want to not sync it you you can also
continue with that option uh this the
example that I shown also like syncs it
to your Chrome uh account so that you
can use it in different uh like um
places also Android I guess introduced
some new stuff with the pass key so if
you create a um Pass key on your
Chrome you will be able to access it
from your phones also so they're also
bringing some additional things
additional
updates uh currently it supports the Z
casing era network will it support other
networks in the future such as
evm um optimism Su
Solana well uh as I previously told uh
there are some technical difficulties on
calculating the same address on ZK sync
and other networks like oh like like
optimism and other like evm chains um
for salana and other uh other
blockchains it's kind of different
implementation so probably we our next
goal might be going to cross chain in
the future when uh we have enough
technical
um capability to do it but right now we
are only uh going Z casing because uh
we're trying to make the ux much more
simpler uh and when it's cross chain and
the addresses are different and there
are no ways to do
um like multiple for example we are
currently supporting a social recovery
method where you can add your friend as
your guardian so uh if you if something
happens to your phone for example or you
Le lose your pass key somehow you delete
it accidentally you can uh request your
friend to recover your account in 48
hour time loog so this is also possible
with the account obstruction and with
the smart accounts so um when you go
cross chain you have to like add those
Guardians in different networks one by
one send transactions for each Network
and this is probably going to be solved
with the um keystore roll Ops in the
future if there are going to be a good
implementations of them um
but yes since there are some technical
difficulties we are trying to keep the
uh user experience as simple as
possible and
yeah what would be the best method to
implement a social recovery in a P key
system so the contracts that I showed
also contains a like the contracts are
designed in a way that you can add
modules to your contract and the one of
the modules that we built before is the
social recovery the social recovery
contract is simply uh helps you to
recover your accounts uh using your uh
friends their uh other like other
wallets you can assign them as the
guardian to a Smart contract and uh give
some time loog some uh threshold like
maybe you will require two of your three
Guardians to accept the uh
recovery uh recovery request and your
account will be recovered
after um after like some time Lo time so
uh in our implementation we
just uh for Simplicity we make the me we
allow only three Guardians and only one
of them can uh complete the recovery
process because it's kind of difficult
to get uh approval from
uh multiple Guardians and one Guardian
is probably enough for recovering your
account we also uh support ZK email uh
we will be supporting soon it um the ZK
email helps
you um adding emails as your Guardians
to your smart contract so in this
case the email that you send have a dkim
signature and you can just verify that
signature on chain using some uh cool
stuff that ZK team built and you just
assign your email as a guardian and then
uh you just recover your account by
sending an email so that's a pretty good
feature for the user
experience in
the uh in the real
world what is the typical transaction
cost for pasy transaction on ZK sync so
typical transaction as you prev to so
it's probably one to three cents it
depends on the network availability but
it's the same as sending transaction
from your AOA uh because there are
precompile
contracts uh the cost is pretty low and
you don't have to worry about the gas
fees on Z
casing so yeah any other questions I
think no questions from the audience and
then also no questions from the
chat uh we can stop a bit earlier uh so
today we build a simple version of the
smart account uh on our browser oh
there's a
question uh if the pasy standard is
upgraded in the future how can we
guarantee the I think the question is
trimmed somehow but if the pasy standard
is upgraded in the future it will
definitely be the backford compatible
with the existing implementations but if
you uh like want to update your py in
the future with the new uh with the new
uh standard in the future like let's say
if the pasis are if the P keys are going
to be Quantum resistant in the future
you can just simply create a new P key
and update your owner in the smart
contract so that it will continue
working with the new
standard uh yeah we built uh smart
wallet with that works with p keys today
we sponsored the users trans
transactions using Gaza pay masters we
sent multiple transactions at the same
time uh the all the codes are open
source in the repository that I uh shown
in the beginning it's in my GitHub
account and you can of course like use
it for your own cases um if you have any
plans in the future to build uh cool
wallets to simplify the user experience
uh thanks for joining
got
fre
back oo
